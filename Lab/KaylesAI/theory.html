<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>미제르 케일스: 재귀와 메모이제이션 분석</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- KaTeX -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" crossorigin="anonymous"></script>
    <style>
        body { font-family: 'Noto Sans KR', sans-serif; background-color: #f8f9fa; color: #212529; }
        .pin { width: 20px; height: 60px; background-color: #fca5a5; border: 2px solid #ef4444; border-radius: 10px 10px 4px 4px; display: inline-block; margin: 0 4px; transition: all .3s ease; box-shadow: 0 4px 6px rgba(0,0,0,.1) }
        .pin.removed { opacity: .2; transform: translateY(10px) }
        .pin-container { transition: all .5s ease-in-out }
        .node { padding: 8px 12px; border-radius: 8px; border: 2px solid; transition: all .3s ease; cursor: pointer; min-width: 60px; text-align: center }
        .node-p { background-color: #dbeafe; border-color: #3b82f6; color: #1e40af }
        .node-n { background-color: #d1fae5; border-color: #10b981; color: #065f46 }
        .node-computing { background-color: #fef9c3; border-color: #f59e0b; animation: pulse 1.5s infinite }
        @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:.7} }
        .memo-item { transition: all .5s }
    </style>
</head>
<body class="p-4 md:p-8">

<div class="max-w-5xl mx-auto bg-white rounded-2xl shadow-lg p-6 md:p-10">
  <header class="text-center mb-10 border-b pb-6">
    <h1 class="text-4xl font-bold text-gray-800">미제르 도슨스 케일스(Misère Dawson's Kayles) 분석</h1>
    <p class="text-lg text-gray-600 mt-2">재귀적 사고와 동적 계획법(메모이제이션)의 힘</p>
  </header>

  <main>
    <!-- 섹션 1 -->
    <section class="mb-12">
      <h2 class="text-2xl font-semibold text-gray-700 border-l-4 border-red-500 pl-4 mb-4">1. 게임의 정의와 목표</h2>
      <div class="space-y-3">
        <p>
          <b>케일스(Kayles)</b>에는 여러 변형이 있습니다. 이 페이지의 데모는 설명 편의를 위해
          <b>일반 케일스</b>를 사용합니다. 일반 케일스(옥탈 0.77)는 한 번에
          <b>하나의 핀</b> 또는 <b>인접한 두 핀</b>을 제거할 수 있습니다
        </p>
        <p class="bg-yellow-50 rounded-md p-3">
          <b>중요</b> — 메인 보드에서 사용하는 규칙은 <b>도슨스 케일스(Dawson's Kayles, 옥탈 0.07)</b>로,
          <u>한 번에 인접한 두 핀만 제거</u>할 수 있습니다. 이론은 두 변형 모두에 유사하게 적용되지만,
          세부 수식과 예외 처리는 다를 수 있습니다
        </p>
        <p>
          <b>미제르(Misère) 규칙</b>에서는 <u>둘 수 없게 만드는 사람이 승리</u>합니다. 즉,
          “마지막 수를 둔 사람이 지는” 정상규칙과 반대의 종료 조건입니다
        </p>
      </div>

      <div id="game-demo" class="mt-6 p-4 bg-gray-50 rounded-lg text-center">
        <p class="mb-4 font-medium">
          아래 핀들을 클릭해 제거해 보세요 <span class="text-gray-500">(이 데모는 일반 케일스: 1개 또는 인접 2개 제거)</span>
        </p>
        <div id="interactive-pins" class="flex justify-center items-end h-24"></div>
        <button id="reset-demo-btn" class="mt-4 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition">초기화</button>
      </div>
    </section>

    <!-- 섹션 2 -->
    <section class="mb-12">
      <h2 class="text-2xl font-semibold text-gray-700 border-l-4 border-blue-500 pl-4 mb-4">2. 정상규칙 분석: 스프라그–그런디 정리</h2>
      <p class="mb-4">
        핀을 제거하면 긴 줄이 <b>둘 이상의 독립 구간</b>으로 나뉘고, 각 구간은 동일한 규칙의 하위 게임입니다.
        이런 <b>공평 게임</b>(impartial game)은 정상규칙에서 <b>스프라그–그런디 정리</b>로 분석할 수 있습니다
      </p>
      <ul class="list-disc list-inside space-y-3 mb-4 pl-4 bg-blue-50 p-4 rounded-md">
        <li><b>그런디 수</b> \(g(S)\) 는 상태 \(S\)의 님값을 의미</li>
        <li><b>Mex 규칙</b> \(g(S) = \mathrm{mex}\{g(S') \mid S' \text{는 } S \text{에서 한 수로 도달되는 상태}\}\)</li>
        <li><b>합의 님합</b> \(g(S_1 + S_2) = g(S_1) \oplus g(S_2)\)</li>
        <li><b>P-포지션</b> \(g=0\), <b>N-포지션</b> \(g\ne 0\)</li>
      </ul>
      <div class="bg-yellow-50 rounded-md p-3">
        <b>주의</b> — 위 정리는 <u>정상규칙</u> 전용입니다. <b>미제르</b>에서는 종료 규칙이 반대라서
        일반적으로 \(g=0\)만으로 승패를 판정할 수 없고, <b>예외 처리</b>나 <b>전용 분해 규칙</b>이 필요합니다
      </div>

      <div class="mt-6 p-4 border rounded-lg">
        <h3 class="font-semibold text-lg mb-2">재귀 호출 시각화</h3>
        <p class="mb-4">아래는 정상규칙의 그런디 계산 구조를 간단히 시각화한 예시입니다</p>
        <div class="flex items-center space-x-4">
          <label for="recursion-pins">핀 개수:</label>
          <input type="number" id="recursion-pins" value="7" min="1" max="15" class="w-24 p-2 border rounded-md">
          <button id="visualize-recursion-btn" class="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition">재귀 트리 생성</button>
        </div>
        <div id="recursion-tree" class="mt-4 p-4 bg-gray-50 rounded-md overflow-x-auto whitespace-nowrap">
          <p class="text-gray-500">이 시각화는 재귀 호출의 구조를 보여주기 위한 단순화된 표현입니다</p>
        </div>
      </div>
    </section>

    <!-- 섹션 3 -->
    <section class="mb-12">
      <h2 class="text-2xl font-semibold text-gray-700 border-l-4 border-yellow-500 pl-4 mb-4">3. 문제점과 해결책: 메모이제이션</h2>
      <p class="mb-4">
        동일 상태에 대한 재계산이 폭증하면 시간 복잡도가 지수적으로 증가합니다.
        <b>메모이제이션</b>으로 이미 계산된 값을 저장해 두면 동일 상태는 O(1)로 회수되어
        실제 탐색량을 크게 줄일 수 있습니다
      </p>
      <p class="mb-4">
        또, 한 줄 \(n\)을 여러 구간으로 쪼갠 상태들의 가짓수는 대략 <b>분할수</b> 성장을 보입니다.
        고전적으로 \(p(n) \sim \frac{1}{4n\sqrt{3}} e^{\pi\sqrt{2n/3}}\)로 근사되며
        \(e^{\Theta(\sqrt{n})}\) 급의 준지수 증가를 가집니다
      </p>

      <div class="mt-6 p-4 border rounded-lg">
        <h3 class="font-semibold text-lg mb-2">메모이제이션 비교</h3>
        <p class="mb-4">아래는 정상규칙 그런디 계산을 예로 들어 메모이제이션 효과를 비교한 데모입니다</p>
        <div class="flex items-center space-x-4 mb-4">
          <button id="run-compare-btn" class="px-4 py-2 bg-purple-500 text-white rounded-lg hover:bg-purple-600 transition">계산 비교 시작 (n=14)</button>
        </div>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div>
            <h4 class="font-medium text-center mb-2">순수 재귀</h4>
            <div id="recursion-stats" class="p-4 bg-red-50 rounded-md text-center">
              <p>총 함수 호출: <span id="rec-calls" class="font-bold">0</span></p>
              <p>소요 시간: <span id="rec-time" class="font-bold">0</span> ms</p>
            </div>
          </div>
          <div>
            <h4 class="font-medium text-center mb-2">메모이제이션 적용</h4>
            <div id="memo-stats" class="p-4 bg-green-50 rounded-md text-center">
              <p>총 함수 호출: <span id="memo-calls" class="font-bold">0</span></p>
              <p>소요 시간: <span id="memo-time" class="font-bold">0</span> ms</p>
            </div>
          </div>
        </div>
        <div class="mt-4">
          <h4 class="font-medium mb-2">메모 테이블 (<code>memo</code>) — 계산된 Grundy 수</h4>
          <div id="memo-table" class="p-4 bg-gray-100 rounded-md font-mono text-sm h-48 overflow-y-auto"></div>
        </div>
      </div>
    </section>

    <!-- 섹션 3.5: 미제르 규칙 개요 -->
    <section class="mb-12">
      <h2 class="text-2xl font-semibold text-gray-700 border-l-4 border-emerald-500 pl-4 mb-4">3.5 미제르 규칙에서는 무엇이 달라질까</h2>
      <ul class="list-disc list-inside space-y-2">
        <li><b>터미널 값이 반대</b>: 더 둘 수 없는 상태는 N, 즉 현재 차례가 승리</li>
        <li><b>그런디 직접 적용 불가</b>: 정상규칙의 \(g=0\) 판정이 그대로 통하지 않음</li>
        <li><b>실전 해법</b>: 보드를 1들의 연속 구간으로 나누고, 길이 \(\ge 2\) 구간만 남긴 뒤
            “자식 중 P가 있으면 N, 모두 N이면 P” 규칙을 <b>재귀+메모</b>로 판정</li>
      </ul>
      <p class="mt-2 text-gray-600">
        메인 보드의 AI는 이 <b>미제르 전용 DP</b>로 n ≤ 120 범위에서 정확히 승패를 판정합니다
      </p>
    </section>

    <!-- 섹션 4 -->
    <section class="mb-12">
      <h2 class="text-2xl font-semibold text-gray-700 border-l-4 border-gray-500 pl-4 mb-4">4. 최종 데모 (정상규칙)</h2>
      <p class="mb-4">
        아래 데모는 <b>교육 목적</b>으로 <u>일반 케일스의 정상규칙</u>에 대해 그런디 수를 계산합니다.
        <span class="text-gray-600">미제르 규칙의 정확 판정은 메인 보드에서 별도의 DP로 수행됩니다</span>
      </p>
      <div class="mt-6 p-6 bg-gray-50 rounded-lg shadow-inner">
        <div class="flex flex-wrap items-center justify-center gap-4">
          <label for="final-pins" class="font-medium">핀 개수 (1-500):</label>
          <input type="number" id="final-pins" value="200" min="1" max="500" class="w-32 p-2 border rounded-md text-center">
          <button id="solve-btn" class="px-6 py-2 bg-red-500 text-white font-bold rounded-lg hover:bg-red-600 transition text-lg">결과 계산</button>
        </div>
        <div id="final-result" class="mt-6 text-center text-2xl font-bold h-10"></div>
      </div>
      <p class="mt-3 text-sm text-gray-600">
        팁: 메인 화면의 상단 배지에서 선택한 핀 수의 <b>초기 포지션(선수승/후수승)</b>을 즉시 확인할 수 있습니다
      </p>
    </section>

    <!-- 섹션 5: 미제르 도슨스 케일스 빠른 판정기 -->
    <section>
      <h2 class="text-2xl font-semibold text-gray-700 border-l-4 border-rose-500 pl-4 mb-4">5. 미제르 도슨스 케일스: 선수승/후수승 판정</h2>
      <p class="mb-3">
        아래 입력으로 <b>도슨스 케일스(0.07)</b>의 <u>미제르 규칙</u>에서, 길이 \(n\)인 한 줄 시작형의
        초기 포지션이 <b>선수승(N)</b>인지 <b>후수승(P)</b>인지 정확하게 판정합니다.
        (브라우저 내 <b>재귀+메모</b> 알고리즘 · n ≤ 120 권장)
      </p>

      <div class="mt-4 p-6 bg-gray-50 rounded-lg shadow-inner">
        <div class="flex flex-wrap items-center justify-center gap-4">
          <label for="mdk-pins" class="font-medium">핀 개수 (2-120):</label>
          <input type="number" id="mdk-pins" value="60" min="2" max="120" class="w-32 p-2 border rounded-md text-center">
          <button id="mdk-solve-btn" class="px-6 py-2 bg-rose-500 text-white font-bold rounded-lg hover:bg-rose-600 transition text-lg">미제르 판정</button>
        </div>
        <div class="mt-3 text-center text-sm text-gray-500">규칙: <b>인접한 2핀</b>만 제거 가능 (도슨스), 둘 수 없으면 <b>현재 차례 승리</b> (미제르)</div>
        <div id="mdk-result" class="mt-4 text-center text-2xl font-bold h-10"></div>
        <div id="mdk-time" class="mt-1 text-center text-sm text-gray-500 h-5"></div>
      </div>

      <div class="mt-6 p-4 border rounded-lg">
        <h3 class="font-semibold text-lg mb-2">시간 복잡도 요약</h3>
        <ul class="list-disc list-inside space-y-2">
          <li><b>정상규칙(일반 케일스, 0.77)</b>  
            — <i>메모이제이션 적용 시</i> 길이 \(0..N\)에 대한 그런디 수 일괄 계산:  
            <b>시간</b> \(O(N^2)\), <b>메모리</b> \(O(N)\)  
            (각 \(n\)에서 가능한 분해가 \(O(n)\), mex 구성도 \(O(n)\) 내에서 처리)
          </li>
          <li><b>미제르 규칙(도슨스, 0.07)</b>  
            — 한 줄 \(n\)에서 분해로 생기는 <b>세그먼트 멀티셋</b> 상태 수가 대략 <b>분할수</b>에 비례:  
            <b>시간/메모리</b> \(\approx e^{\Theta(\sqrt{n})}\) (준지수, subexponential)  
            (실전에서는 n ≤ 120 범위는 브라우저에서도 즉시 판정 가능)
          </li>
        </ul>
      </div>
    </section>
  </main>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  if (window.renderMathInElement) {
    renderMathInElement(document.body);
  }

  /* ---------------- 섹션 1: 인터랙티브 핀 데모 (일반 케일스 예시) ---------------- */
  const interactivePinsContainer = document.getElementById('interactive-pins');
  let demoPins = 7;

  function createDemoPins() {
    interactivePinsContainer.innerHTML = '';
    for (let i = 0; i < demoPins; i++) {
      const pin = document.createElement('div');
      pin.className = 'pin';
      pin.dataset.index = i;
      pin.addEventListener('click', handlePinClick);
      interactivePinsContainer.appendChild(pin);
    }
  }
  function handlePinClick(e) {
    const index = parseInt(e.target.dataset.index);
    const pins = Array.from(interactivePinsContainer.children);
    if (!pins[index].classList.contains('removed')) {
      pins[index].classList.add('removed'); // 1개 제거
    } else if (index > 0 && !pins[index-1].classList.contains('removed')) {
      pins[index-1].classList.add('removed'); // 인접 2개 제거 예시
    }
  }
  document.getElementById('reset-demo-btn').addEventListener('click', createDemoPins);
  createDemoPins();

  /* ---------------- 공통 계산 로직: 정상규칙 그런디(일반 케일스 예시) ---------------- */
  let memo = {};
  let callCount = 0;

  function mex(s) { let i = 0; while (s.has(i)) i++; return i; }
  function getGrundy(n, recursiveFunc) {
    callCount++;
    if (n <= 0) return 0;
    const next = new Set();
    for (let i = 0; i < n; i++) {
      next.add(recursiveFunc(i) ^ recursiveFunc(n - i - 1));   // 1개 제거
      if (i + 1 < n) next.add(recursiveFunc(i) ^ recursiveFunc(n - i - 2)); // 2개 제거
    }
    return mex(next);
  }
  function getGrundyPureRecursive(n) { return getGrundy(n, getGrundyPureRecursive); }
  function getGrundyMemoized(n) {
    if (n in memo) return memo[n];
    const r = getGrundy(n, getGrundyMemoized);
    memo[n] = r; return r;
  }

  /* ---------------- 섹션 2: 재귀 트리 시각화(정상규칙 그런디) ---------------- */
  const visualizeRecursionBtn = document.getElementById('visualize-recursion-btn');
  const recursionTreeContainer = document.getElementById('recursion-tree');
  visualizeRecursionBtn.addEventListener('click', () => {
    const n = parseInt(document.getElementById('recursion-pins').value);
    recursionTreeContainer.innerHTML = '<p class="text-gray-500">트리 생성 중...</p>';
    callCount = 0;
    setTimeout(() => {
      const root = buildTree(n);
      recursionTreeContainer.innerHTML = '';
      recursionTreeContainer.appendChild(root);
    }, 10);
  });
  function buildTree(n) {
    const node = document.createElement('div');
    node.className = 'node inline-block m-2';
    const g = getGrundyPureRecursive(n);
    node.textContent = `g(${n})=${g}`;
    node.classList.add(g !== 0 ? 'node-n' : 'node-p');
    if (n > 1) {
      const children = document.createElement('div');
      children.className = 'pl-4 border-l-2 border-gray-300';
      children.appendChild(buildTree(n - 1));
      if (n - 2 >= 0) children.appendChild(buildTree(n - 2));
      if (n - 3 >= 0) children.appendChild(buildTree(n - 3));
      node.appendChild(children);
    }
    return node;
  }

  /* ---------------- 섹션 3: 메모이제이션 비교(정상규칙 그런디) ---------------- */
  const runCompareBtn = document.getElementById('run-compare-btn');
  const recCallsEl = document.getElementById('rec-calls');
  const recTimeEl  = document.getElementById('rec-time');
  const memoCallsEl= document.getElementById('memo-calls');
  const memoTimeEl = document.getElementById('memo-time');
  const memoTableEl= document.getElementById('memo-table');

  runCompareBtn.addEventListener('click', () => {
    const n = 14;
    runCompareBtn.disabled = true;
    runCompareBtn.textContent = "계산 중...";

    // 순수 재귀
    callCount = 0;
    let t0 = performance.now();
    getGrundyPureRecursive(n);
    let t1 = performance.now();
    recCallsEl.textContent = callCount.toLocaleString();
    recTimeEl.textContent  = (t1 - t0).toFixed(2);

    // 메모이제이션
    memo = {};
    callCount = 0;
    memoTableEl.innerHTML = '';
    t0 = performance.now();
    getGrundyMemoized(n);
    t1 = performance.now();
    memoCallsEl.textContent = callCount.toLocaleString();
    memoTimeEl.textContent  = (t1 - t0).toFixed(2);

    const sortedMemo = Object.entries(memo).sort((a,b)=>parseInt(a[0])-parseInt(b[0]));
    sortedMemo.forEach(([k,v], i) => {
      setTimeout(() => {
        const item = document.createElement('div');
        item.className = `memo-item p-1 rounded ${v!==0 ? 'bg-green-200' : 'bg-blue-200'}`;
        item.textContent = `g(${k}) = ${v}`;
        memoTableEl.appendChild(item);
        item.scrollIntoView({ behavior: 'smooth', block: 'end' });
      }, i*50);
    });

    runCompareBtn.disabled = false;
    runCompareBtn.textContent = "계산 비교 시작 (n=14)";
  });

  /* ---------------- 섹션 4: 최종 데모(정상규칙) ---------------- */
  const solveBtn = document.getElementById('solve-btn');
  const finalResultEl = document.getElementById('final-result');
  function isWinningNormal(n) { return getGrundyMemoized(n) !== 0; }
  solveBtn.addEventListener('click', () => {
    const n = parseInt(document.getElementById('final-pins').value);
    if (isNaN(n) || n < 1) {
      finalResultEl.textContent = "1 이상의 숫자를 입력하세요";
      finalResultEl.className = "mt-6 text-center text-2xl font-bold h-10 text-red-500";
      return;
    }
    memo = {}; callCount = 0;
    const g = getGrundyMemoized(n);
    const win = isWinningNormal(n);
    if (win) {
      finalResultEl.innerHTML = `핀 ${n}개는 <span class="text-green-600">정상규칙 기준</span> 시작 플레이어의 승리입니다 (g(${n}) = ${g})`;
    } else {
      finalResultEl.innerHTML = `핀 ${n}개는 <span class="text-blue-600">정상규칙 기준</span> 시작 플레이어의 패배입니다 (g(${n}) = ${g})`;
    }
    finalResultEl.className = "mt-6 text-center text-2xl font-bold h-10 text-gray-800";
    if (window.renderMathInElement) renderMathInElement(finalResultEl);
  });

  /* ---------------- 섹션 5: 미제르 도슨스 케일스 판정기 ---------------- */
  const mdkInput   = document.getElementById('mdk-pins');
  const mdkBtn     = document.getElementById('mdk-solve-btn');
  const mdkResult  = document.getElementById('mdk-result');
  const mdkTimeEl  = document.getElementById('mdk-time');

  // 미제르 도슨스 전용: 세그먼트 기반 정확 DP
  // 규칙: 인접한 2핀만 제거, 둘 수 없으면 현재 차례 승리(=터미널은 N)
  function getRunLengths(arr) {
    const runs = [];
    let cur = 0;
    for (const v of arr) {
      if (v === 1) cur++;
      else { if (cur > 0) runs.push(cur); cur = 0; }
    }
    if (cur > 0) runs.push(cur);
    return runs;
  }
  function boardToStateMDK(board) {
    // 길이 >=2 세그먼트만 남기고 내림차순 정렬
    const segs = getRunLengths(board).filter(x => x >= 2).sort((a,b)=>b-a);
    return segs; // Array<number>
  }
  const memoPN_MDK = new Map(); // key: "a,b,c" -> boolean (isP)
  function stateKeyMDK(segs) { return segs.join(","); }

  function isPFromStateMDK(segs) {
    const key = stateKeyMDK(segs);
    if (memoPN_MDK.has(key)) return memoPN_MDK.get(key);

    if (segs.length === 0) { // 이동 불가 ⇒ 미제르에서 N
      memoPN_MDK.set(key, false);
      return false;
    }
    for (let i=0;i<segs.length;i++) {
      const m = segs[i];
      for (let k=0;k<=m-2;k++) { // 인접 2핀 제거의 왼쪽 인덱스
        const L = k, R = m - k - 2;
        const child = [];
        for (let j=0;j<segs.length;j++) if (j!==i) child.push(segs[j]);
        if (L >= 2) child.push(L);
        if (R >= 2) child.push(R);
        child.sort((a,b)=>b-a);
        if (isPFromStateMDK(child)) { // 자식이 P면 현재는 N
          memoPN_MDK.set(key, false);
          return false;
        }
      }
    }
    memoPN_MDK.set(key, true); // 모든 자식이 N ⇒ 현재는 P
    return true;
  }

  function isP_MDK_for_n(n) {
    const board = Array(n).fill(1);
    memoPN_MDK.clear();
    const segs = boardToStateMDK(board);
    return isPFromStateMDK(segs);
  }

  mdkBtn.addEventListener('click', () => {
    let n = parseInt(mdkInput.value);
    if (!Number.isFinite(n) || n < 2 || n > 120) {
      mdkResult.textContent = `2–120 사이의 정수를 입력하세요`;
      mdkResult.className = "mt-4 text-center text-2xl font-bold h-10 text-red-600";
      mdkTimeEl.textContent = "";
      return;
    }
    const t0 = performance.now();
    const isP = isP_MDK_for_n(n);
    const t1 = performance.now();

    if (isP) {
      mdkResult.innerHTML = `핀 ${n}개: <span class="text-blue-600">후수승 (P-position)</span>`;
    } else {
      mdkResult.innerHTML = `핀 ${n}개: <span class="text-green-600">선수승 (N-position)</span>`;
    }
    mdkResult.className = "mt-4 text-center text-2xl font-bold h-10 text-gray-800";
    mdkTimeEl.textContent = `계산 시간: ${(t1 - t0).toFixed(2)} ms`;
  });
});
</script>

</body>
</html>
