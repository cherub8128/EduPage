<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>확률의 세계: 독립 사건 탐험하기</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- KaTeX CDN 추가 -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" xintegrity="sha384-n8MVd4RsNIU0KOVEMeaPoAbJNdMYGNpaLCITPbUdaJblrzJNE2agrdMLIHN5EQGk" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" xintegrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzYCEHPNKAqv8i5HuaMusnvENqVd+BovHtCQ" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" xintegrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
        }
        .shape {
            width: 40px;
            height: 40px;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            margin: 4px;
            border-radius: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .shape-circle { background-color: #ef4444; border-radius: 50%; } /* red-500 */
        .shape-triangle { 
            width: 0;
            height: 0;
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
            border-bottom: 35px solid #3b82f6; /* blue-500 */
            background-color: transparent;
        }
        .shape-square { background-color: #22c55e; } /* green-500 */
        .coin {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: bold;
            color: #64748b;
            background: linear-gradient(45deg, #f1f5f9, #cbd5e1);
            box-shadow: 4px 4px 8px #94a3b8, -4px -4px 8px #ffffff;
            cursor: pointer;
            transition: transform 0.5s;
            transform-style: preserve-3d;
        }
        .coin.flipping {
            transform: rotateY(900deg);
        }
        .quiz-option {
            transition: background-color 0.2s;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 p-4 md:p-8">

    <div class="max-w-4xl mx-auto">
        <header class="text-center mb-12">
            <h1 class="text-4xl md:text-5xl font-bold text-gray-900">확률의 세계: 독립 사건 탐험하기</h1>
            <p class="mt-4 text-lg text-gray-600">
                어떤 사건이 다른 사건에 영향을 주지 않을 때 '독립'이라고 합니다. <br class="hidden md:block">
                여러 실험을 통해 독립 사건과 종속 사건의 차이를 직접 체험해 보세요.
            </p>
        </header>

        <main class="space-y-12">
            <!-- 실험 1: 복원 추출 vs. 비복원 추출 -->
            <section class="bg-white p-6 rounded-xl shadow-lg">
                <h2 class="text-2xl font-bold mb-4">실험 1: 복원 추출 vs. 비복원 추출</h2>
                <p class="mb-6 text-gray-600">주머니에서 공을 뽑을 때, 뽑은 공을 다시 넣는(복원) 경우와 넣지 않는(비복원) 경우의 확률 변화를 비교해 봅시다.</p>
                <div class="grid md:grid-cols-2 gap-8">
                    <!-- 복원 추출 -->
                    <div>
                        <h3 class="text-xl font-semibold mb-3 text-center text-indigo-600">복원 추출 (독립 사건)</h3>
                        <div id="restoration-bag" class="h-48 bg-gray-100 rounded-lg p-4 flex flex-wrap content-start"></div>
                        <div class="text-center my-4">
                            <button id="draw-restoration" class="bg-indigo-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-indigo-700 transition">공 뽑기</button>
                        </div>
                        <div id="restoration-prob" class="text-center font-mono"></div>
                        <p class="text-sm text-center text-gray-500 mt-2">뽑은 공을 다시 넣기 때문에, 다음 공을 뽑을 확률은 항상 동일합니다.</p>
                    </div>
                    <!-- 비복원 추출 -->
                    <div>
                        <h3 class="text-xl font-semibold mb-3 text-center text-teal-600">비복원 추출 (종속 사건)</h3>
                        <div id="non-restoration-bag" class="h-48 bg-gray-100 rounded-lg p-4 flex flex-wrap content-start"></div>
                        <div class="text-center my-4">
                            <button id="draw-non-restoration" class="bg-teal-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-teal-700 transition">공 뽑기</button>
                        </div>
                        <div id="non-restoration-prob" class="text-center font-mono"></div>
                        <p class="text-sm text-center text-gray-500 mt-2">뽑은 공을 제거하기 때문에, 다음 공을 뽑을 확률이 계속 변합니다.</p>
                    </div>
                </div>
                 <div class="text-center mt-6">
                    <button id="reset-exp1" class="text-sm text-gray-500 hover:text-gray-700 underline">실험 1 초기화</button>
                </div>
            </section>

            <!-- 실험 2: 동전 던지기와 갬블러의 오류 -->
            <section class="bg-white p-6 rounded-xl shadow-lg">
                <h2 class="text-2xl font-bold mb-4">실험 2: 동전 던지기와 갬블러의 오류</h2>
                <p class="mb-6 text-gray-600">동전을 던지는 것은 대표적인 독립 시행입니다. 앞면이 연속으로 나왔다고 해서 다음번에 뒷면이 나올 확률이 높아질까요? 직접 확인해 보세요.</p>
                <div class="flex flex-col items-center">
                    <div id="coin" class="coin">?</div>
                    <p class="my-4 font-semibold">다음 결과 예측: <span class="text-blue-600">앞면 50%</span>, <span class="text-red-600">뒷면 50%</span></p>
                    <div class="mt-4 w-full bg-gray-100 p-3 rounded-lg">
                        <h4 class="font-semibold mb-2">결과 기록:</h4>
                        <div id="coin-history" class="text-lg flex flex-wrap gap-x-2"></div>
                    </div>
                     <div class="text-center mt-6">
                        <button id="reset-exp2" class="text-sm text-gray-500 hover:text-gray-700 underline">실험 2 초기화</button>
                    </div>
                </div>
            </section>

            <!-- 실험 3: 비복원 추출과 모집단의 크기 -->
            <section class="bg-white p-6 rounded-xl shadow-lg">
                <h2 class="text-2xl font-bold mb-4">탐구 1: 비복원 추출과 모집단의 크기</h2>
                <p class="mb-6 text-gray-600">비복원 추출은 이전의 결과가 다음 결과의 확률에 영향을 주므로 항상 <strong class="text-teal-600">종속</strong>입니다. 하지만 모집단의 크기가 매우 크다면 어떨까요? 아래 버튼으로 모집단 크기를 선택하고 확률 변화를 관찰해 봅시다.</p>
                
                <div id="exp3-setup" class="text-center my-4 flex justify-center gap-4">
                    <button id="setup-small-pop" class="bg-sky-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-sky-700 transition">작은 모집단 (총 21개)</button>
                    <button id="setup-large-pop" class="bg-violet-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-violet-700 transition">큰 모집단 (총 2100개)</button>
                </div>

                <div id="exp3-run" class="hidden">
                    <div id="shape-box" class="min-h-[12rem] bg-gray-100 rounded-lg p-4 flex flex-wrap content-center items-center justify-center relative overflow-hidden">
                        <!-- 도형 개수와 애니메이션이 여기에 표시됩니다. -->
                    </div>
                    <div class="text-center my-4">
                        <button id="draw-shape" class="bg-amber-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-amber-700 transition">도형 뽑기</button>
                    </div>
                    <div>
                        <h4 class="font-semibold text-center mb-2">다음 시행의 확률</h4>
                        <div id="shape-prob" class="text-center font-mono flex justify-around"></div>
                    </div>
                    <p id="shape-conclusion" class="mt-4 text-center font-semibold h-12 flex items-center justify-center"></p>
                </div>

                 <div class="text-center mt-6">
                    <button id="reset-exp3" class="text-sm text-gray-500 hover:text-gray-700 underline">실험 3 초기화</button>
                </div>
            </section>
            
            <!-- 실험 4: 비례 표본 추출 -->
            <section class="bg-white p-6 rounded-xl shadow-lg">
                <h2 class="text-2xl font-bold mb-4">탐구 2: 비례 표본 추출과 독립 시행</h2>
                <p class="mb-6 text-gray-600">
                    모집단과 <strong class="text-emerald-600">정확히 같은 비율의 표본</strong>을 비복원 추출하면, 남은 모집단의 확률 분포는 어떻게 될까요? <br>
                    아래 상자에는 <span class="text-red-500">동그라미 8개</span>, <span class="text-blue-500">세모 12개</span>, <span class="text-green-500">네모 20개</span> (비율 2:3:5)가 들어있습니다.
                </p>
            
                <div class="bg-gray-50 p-4 rounded-lg">
                    <div class="grid md:grid-cols-2 gap-6 items-center">
                        <div class="text-center">
                            <h3 class="font-semibold text-lg">현재 상자 상태 (<span id="exp4-total"></span>)</h3>
                             <div id="exp4-shape-container" class="my-2 flex flex-wrap justify-center items-center bg-gray-200 p-2 rounded-md min-h-[12rem] transition-all duration-500"></div>
                            <h4 class="font-semibold mt-4">각 도형을 뽑을 확률</h4>
                            <div id="exp4-probs" class="font-mono"></div>
                        </div>
                        <div class="text-center">
                             <button id="draw-proportional-sample" class="bg-emerald-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-emerald-700 transition text-lg disabled:bg-gray-400">
                                비율에 맞춰<br>2●, 3▲, 5■ 뽑기
                             </button>
                        </div>
                    </div>
                </div>
                
                <p id="exp4-conclusion" class="mt-6 text-center font-semibold h-12 flex items-center justify-center text-lg"></p>
            
                <div class="text-center mt-6">
                    <button id="reset-exp4" class="text-sm text-gray-500 hover:text-gray-700 underline">실험 4 초기화</button>
                </div>
            </section>

            <!-- 보너스: 독립 vs 배반 -->
            <section class="bg-white p-6 rounded-xl shadow-lg">
                <h2 class="text-2xl font-bold mb-4">보너스: 독립 사건 vs. 배반 사건</h2>
                <div class="space-y-4 text-gray-600">
                    <p>독립과 배반은 자주 혼동되지만 전혀 다른 개념입니다.</p>
                    <div class="grid md:grid-cols-2 gap-6">
                        <div class="bg-blue-50 p-4 rounded-lg">
                            <h4 class="font-bold text-lg text-blue-800">독립 사건 (Independent Events)</h4>
                            <p>두 사건 A, B가 서로의 확률에 <strong class="text-blue-800">영향을 주지 않는 관계</strong>입니다. 즉, 한 사건이 일어났다는 사실이 다른 사건의 확률을 바꾸지 않습니다.</p>
                            <div class="mt-2 font-mono bg-blue-100 p-2 rounded text-center text-sm katex-container">$P(A \cap B) = P(A) \times P(B)$</div>
                            <p class="mt-2 text-sm">예: 동전을 던져 앞면이 나오는 사건과 주사위를 던져 짝수가 나오는 사건.</p>
                        </div>
                        <div class="bg-red-50 p-4 rounded-lg">
                            <h4 class="font-bold text-lg text-red-800">배반 사건 (Mutually Exclusive)</h4>
                            <p>두 사건 A, B가 <strong class="text-red-800">절대 동시에 일어날 수 없는 관계</strong>입니다. 교집합이 공집합($\emptyset$)입니다.</p>
                             <div class="mt-2 font-mono bg-red-100 p-2 rounded text-center text-sm katex-container">$P(A \cap B) = 0$</div>
                            <p class="mt-2 text-sm">예: 주사위 한 개를 던져 1이 나오는 사건과 6이 나오는 사건.</p>
                        </div>
                    </div>
                </div>
                
                <div class="mt-8 border-t pt-6">
                    <h3 class="text-xl font-semibold mb-4">독립과 배반에 대한 참/거짓 명제</h3>
                    <div class="space-y-6">
                        <div class="bg-gray-50 p-4 rounded-lg">
                            <p class="font-semibold">명제 1: 두 사건 A, B가 배반 사건이면, 두 사건은 서로 독립이다.</p>
                            <p class="mt-2"><strong class="text-red-600">거짓</strong></p>
                            <p class="text-sm text-gray-700 mt-1">
                                <strong>설명:</strong> (단, $P(A) \neq 0, P(B) \neq 0$) <br>
                                두 사건 A, B가 배반이면 $P(A \cap B) = 0$ 입니다. <br>
                                만약 두 사건이 독립이라면 $P(A \cap B) = P(A) \times P(B)$ 를 만족해야 합니다. <br>
                                하지만 $P(A) > 0, P(B) > 0$ 이므로 $P(A) \times P(B) > 0$ 입니다. <br>
                                따라서 $0 \neq P(A) \times P(B)$ 이므로, 두 사건은 독립이 아니라 <strong class="text-indigo-600">종속</strong>입니다.
                            </p>
                        </div>
                        <div class="bg-gray-50 p-4 rounded-lg">
                            <p class="font-semibold">명제 2: 두 사건 A, B가 서로 독립이면, 두 사건은 배반 사건이다.</p>
                            <p class="mt-2"><strong class="text-red-600">거짓</strong></p>
                             <p class="text-sm text-gray-700 mt-1">
                                <strong>설명:</strong> (단, $P(A) \neq 0, P(B) \neq 0$) <br>
                                두 사건이 독립이면 $P(A \cap B) = P(A) \times P(B)$ 입니다. <br>
                                $P(A)>0, P(B)>0$ 이므로, $P(A \cap B) > 0$ 입니다. <br>
                                배반 사건의 정의는 $P(A \cap B) = 0$ 이므로, 두 사건은 배반 사건이 될 수 없습니다.
                            </p>
                        </div>
                        <div class="bg-gray-50 p-4 rounded-lg">
                            <p class="font-semibold">명제 3: 두 사건 A, B가 서로 독립이면, A와 B의 여사건($B^c$)도 서로 독립이다.</p>
                            <p class="mt-2"><strong class="text-green-600">참</strong></p>
                             <p class="text-sm text-gray-700 mt-1">
                                <strong>증명:</strong> A와 $B^c$가 독립임을 보이려면 $P(A \cap B^c) = P(A) \times P(B^c)$ 임을 보이면 됩니다. <br>
                                $P(A \cap B^c) = P(A) - P(A \cap B)$ 입니다. <br>
                                A와 B가 독립이므로 $P(A \cap B) = P(A) \times P(B)$ 입니다. <br>
                                따라서, $P(A \cap B^c) = P(A) - P(A)P(B) = P(A)(1-P(B)) = P(A)P(B^c)$ 입니다. <br>
                                그러므로 A와 $B^c$는 서로 독립입니다. (마찬가지로 $A^c$와 B, $A^c$와 $B^c$도 서로 독립입니다.)
                            </p>
                        </div>
                    </div>
                </div>

                <div class="mt-8 border-t pt-6">
                    <h3 class="text-xl font-semibold text-center mb-4">개념 확인 퀴즈</h3>
                    <div id="quiz-container" class="bg-gray-50 p-4 rounded-lg">
                        <p id="quiz-question" class="font-semibold mb-4 text-center"></p>
                        <div id="quiz-options" class="grid grid-cols-1 md:grid-cols-2 gap-3"></div>
                        <div id="quiz-feedback" class="mt-4 text-center"></div>
                    </div>
                </div>
            </section>
        </main>
    </div>

<script>
    document.addEventListener("DOMContentLoaded", function() {
        if (window.renderMathInElement) {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false}
                ]
            });
        }
        exp1.init();
        exp2.init();
        exp3.init();
        exp4.init();
        bonusQuiz.init();
    });

    // --- 유틸리티 함수 ---
    const createBall = (color) => {
        const ball = document.createElement('div');
        ball.className = `w-6 h-6 rounded-full m-1 shadow ${color}`;
        return ball;
    };

    const createShape = (type) => {
        const shape = document.createElement('div');
        if (type === 'circle') shape.className = 'shape shape-circle';
        else if (type === 'triangle') shape.className = 'shape shape-triangle';
        else if (type === 'square') shape.className = 'shape shape-square';
        return shape;
    };
    
    const createSmallShape = (type) => {
        const shape = createShape(type);
        shape.style.width = '24px';
        shape.style.height = '24px';
        shape.style.margin = '2px';
        if (type === 'triangle') {
            shape.style.borderLeftWidth = '12px';
            shape.style.borderRightWidth = '12px';
            shape.style.borderBottomWidth = '20px';
        }
        return shape;
    };

    // --- 실험 1: 복원 vs 비복원 ---
    const exp1 = {
        restorationBagEl: document.getElementById('restoration-bag'),
        nonRestorationBagEl: document.getElementById('non-restoration-bag'),
        restorationProbEl: document.getElementById('restoration-prob'),
        nonRestorationProbEl: document.getElementById('non-restoration-prob'),
        drawRestorationBtn: document.getElementById('draw-restoration'),
        drawNonRestorationBtn: document.getElementById('draw-non-restoration'),
        resetBtn: document.getElementById('reset-exp1'),
        
        initialBalls: { 'bg-red-500': 5, 'bg-blue-500': 5, 'bg-green-500': 5 },
        restorationBalls: [],
        nonRestorationBalls: [],
        
        init() {
            this.restorationBalls = Object.entries(this.initialBalls).flatMap(([color, count]) => Array(count).fill(color));
            this.nonRestorationBalls = [...this.restorationBalls];
            this.render();
            this.drawRestorationBtn.onclick = () => this.draw('restoration');
            this.drawNonRestorationBtn.onclick = () => this.draw('non-restoration');
            this.resetBtn.onclick = () => this.init();
        },
        
        render() {
            this.restorationBagEl.innerHTML = '';
            this.restorationBalls.forEach(color => this.restorationBagEl.appendChild(createBall(color)));
            
            this.nonRestorationBagEl.innerHTML = '';
            this.nonRestorationBalls.forEach(color => this.nonRestorationBagEl.appendChild(createBall(color)));
            
            this.updateProbs();
        },
        
        updateProbs() {
            const formatProb = (count, total) => total > 0 ? (count / total * 100).toFixed(1) : 0;
            const updateEl = (el, balls) => {
                const counts = balls.reduce((acc, color) => ({...acc, [color]: (acc[color] || 0) + 1 }), {});
                const total = balls.length;
                el.innerHTML = `
                    <span class="text-red-500">● ${formatProb(counts['bg-red-500'] || 0, total)}%</span>
                    <span class="text-blue-500">● ${formatProb(counts['bg-blue-500'] || 0, total)}%</span>
                    <span class="text-green-500">● ${formatProb(counts['bg-green-500'] || 0, total)}%</span>
                `;
            };
            updateEl(this.restorationProbEl, this.restorationBalls);
            updateEl(this.nonRestorationProbEl, this.nonRestorationBalls);
        },

        draw(type) {
            const bag = type === 'restoration' ? this.restorationBalls : this.nonRestorationBalls;
            if (bag.length === 0) return;

            const index = Math.floor(Math.random() * bag.length);
            const bagEl = type === 'restoration' ? this.restorationBagEl : this.nonRestorationBagEl;
            const drawnBall = bagEl.children[index];

            drawnBall.style.transform = 'scale(1.5) translateY(-50px)';
            drawnBall.style.zIndex = '10';

            setTimeout(() => {
                if (type === 'non-restoration') {
                    this.nonRestorationBalls.splice(index, 1);
                }
                this.render();
            }, 800);
        }
    };
    
    // --- 실험 2: 동전 던지기 ---
    const exp2 = {
        coinEl: document.getElementById('coin'),
        historyEl: document.getElementById('coin-history'),
        resetBtn: document.getElementById('reset-exp2'),
        
        init() {
            this.coinEl.onclick = () => this.flip();
            this.resetBtn.onclick = () => {
                this.historyEl.innerHTML = '';
                this.coinEl.textContent = '?';
            };
        },

        flip() {
            if (this.coinEl.classList.contains('flipping')) return;
            
            this.coinEl.classList.add('flipping');
            this.coinEl.textContent = '';

            setTimeout(() => {
                const result = Math.random() < 0.5 ? '앞' : '뒤';
                this.coinEl.classList.remove('flipping');
                this.coinEl.textContent = result;
                
                const resultEl = document.createElement('span');
                resultEl.textContent = result;
                resultEl.className = result === '앞' ? 'text-blue-600' : 'text-red-600';
                this.historyEl.appendChild(resultEl);
            }, 1000);
        }
    };
    
    // --- 실험 3: 비복원 추출과 모집단의 크기 ---
    const exp3 = {
        setupEl: document.getElementById('exp3-setup'),
        runEl: document.getElementById('exp3-run'),
        smallPopBtn: document.getElementById('setup-small-pop'),
        largePopBtn: document.getElementById('setup-large-pop'),
        boxEl: document.getElementById('shape-box'),
        probEl: document.getElementById('shape-prob'),
        conclusionEl: document.getElementById('shape-conclusion'),
        drawBtn: document.getElementById('draw-shape'),
        resetBtn: document.getElementById('reset-exp3'),

        counts: {},
        total: 0,
        isLargePopulation: false,

        init() {
            this.smallPopBtn.onclick = () => this.setup(false);
            this.largePopBtn.onclick = () => this.setup(true);
            this.drawBtn.onclick = () => this.draw();
            this.resetBtn.onclick = () => this.reset();
            this.reset();
        },
        
        reset() {
            this.runEl.classList.add('hidden');
            this.setupEl.classList.remove('hidden');
            this.boxEl.innerHTML = '<p class="text-gray-400">모집단 크기를 선택해주세요.</p>';
            this.probEl.innerHTML = '';
            this.conclusionEl.innerHTML = '';
        },
        
        setup(isLarge) {
            this.isLargePopulation = isLarge;
            const multiplier = isLarge ? 100 : 1;
            this.counts = { 'circle': 7 * multiplier, 'triangle': 7 * multiplier, 'square': 7 * multiplier };
            this.total = 21 * multiplier;

            this.setupEl.classList.add('hidden');
            this.runEl.classList.remove('hidden');
            this.conclusionEl.innerHTML = '';
            this.render();
        },

        render() {
            this.boxEl.innerHTML = `
                <div class="text-center">
                    <h4 class="font-semibold mb-2">상자 안의 도형 개수</h4>
                    <p class="text-lg"><span class="text-red-500 font-bold">●</span> 동그라미: <span class="font-mono">${this.counts.circle}</span>개</p>
                    <p class="text-lg"><span class="text-blue-500 font-bold">▲</span> 세모: <span class="font-mono">${this.counts.triangle}</span>개</p>
                    <p class="text-lg"><span class="text-green-500 font-bold">■</span> 네모: <span class="font-mono">${this.counts.square}</span>개</p>
                    <p class="mt-2 font-bold">총 ${this.total}개</p>
                </div>
            `;
            this.updateProbs();
        },

        updateProbs() {
            const formatProbDetailed = (count, total) => total > 0 ? (count / total * 100).toFixed(4) : "0.0000";
            this.probEl.innerHTML = `
                <span class="text-red-500">● ${formatProbDetailed(this.counts['circle'] || 0, this.total)}%</span>
                <span class="text-blue-500">▲ ${formatProbDetailed(this.counts['triangle'] || 0, this.total)}%</span>
                <span class="text-green-500">■ ${formatProbDetailed(this.counts['square'] || 0, this.total)}%</span>
            `;
        },

        draw() {
            if (this.total === 0) {
                this.conclusionEl.textContent = '상자가 비었습니다!';
                return;
            }
            
            const rand = Math.random() * this.total;
            let drawnType;
            if (rand < this.counts.circle) {
                drawnType = 'circle';
            } else if (rand < this.counts.circle + this.counts.triangle) {
                drawnType = 'triangle';
            } else {
                drawnType = 'square';
            }

            this.counts[drawnType]--;
            this.total--;

            const animatedShape = createShape(drawnType);
            animatedShape.style.position = 'absolute';
            animatedShape.style.transition = 'transform 1s ease-out, opacity 1s ease-out';
            this.boxEl.appendChild(animatedShape);

            setTimeout(() => {
                 animatedShape.style.transform = `translateY(-150px) scale(1.5) rotate(360deg)`;
                 animatedShape.style.opacity = '0';
            }, 10);
           
            setTimeout(() => {
                animatedShape.remove();
                this.render();
                if (this.isLargePopulation) {
                    this.conclusionEl.innerHTML = '확률이 <strong class="text-violet-600">아주 미세하게</strong> 변했습니다. <br>이처럼 모집단이 매우 크면, 비복원추출도 독립시행에 가깝게 볼 수 있습니다.';
                } else {
                    this.conclusionEl.innerHTML = '확률이 <strong class="text-sky-600">눈에 띄게</strong> 변했습니다. <br>이것이 바로 종속 사건의 특징입니다.';
                }
            }, 1000);
        }
    };
    
    // --- 실험 4: 비례 표본 추출 ---
    const exp4 = {
        containerEl: document.getElementById('exp4-shape-container'),
        totalEl: document.getElementById('exp4-total'),
        probsEl: document.getElementById('exp4-probs'),
        drawBtn: document.getElementById('draw-proportional-sample'),
        resetBtn: document.getElementById('reset-exp4'),
        conclusionEl: document.getElementById('exp4-conclusion'),

        initialCounts: { circle: 8, triangle: 12, square: 20 },
        currentCounts: {},

        init() {
            this.drawBtn.onclick = () => this.draw();
            this.resetBtn.onclick = () => this.reset();
            this.reset();
        },

        reset() {
            this.currentCounts = { ...this.initialCounts };
            this.drawBtn.disabled = false;
            this.conclusionEl.innerHTML = '';
            this.render();
        },

        render() {
            const total = this.currentCounts.circle + this.currentCounts.triangle + this.currentCounts.square;
            this.totalEl.textContent = `총 ${total}개`;
            
            // Render shapes
            this.containerEl.innerHTML = '';
            for (let i = 0; i < this.currentCounts.circle; i++) this.containerEl.appendChild(createSmallShape('circle'));
            for (let i = 0; i < this.currentCounts.triangle; i++) this.containerEl.appendChild(createSmallShape('triangle'));
            for (let i = 0; i < this.currentCounts.square; i++) this.containerEl.appendChild(createSmallShape('square'));

            // Update probabilities display
            const formatProb = (count, total) => total > 0 ? (count / total * 100).toFixed(1) : 0;
            this.probsEl.innerHTML = `
                <span class="text-red-500">● ${formatProb(this.currentCounts.circle, total)}%</span> | 
                <span class="text-blue-500">▲ ${formatProb(this.currentCounts.triangle, total)}%</span> | 
                <span class="text-green-500">■ ${formatProb(this.currentCounts.square, total)}%</span>
            `;
        },

        draw() {
            if (this.currentCounts.circle < 4 || this.currentCounts.triangle < 6 || this.currentCounts.square < 10) {
                this.drawBtn.disabled = true;
                this.conclusionEl.textContent = '더 이상 비례에 맞춰 뽑을 수 없습니다.';
                return;
            }

            this.currentCounts.circle -= 2;
            this.currentCounts.triangle -= 3;
            this.currentCounts.square -= 5;

            // Simple visual feedback
            this.containerEl.classList.add('opacity-50');
            
            setTimeout(() => {
                this.render();
                this.containerEl.classList.remove('opacity-50');
                this.conclusionEl.innerHTML = '<span class="text-emerald-600">확률이 변하지 않았습니다!</span><br><span class="text-sm">이는 다음 시행이 이전 시행과 독립임을 의미합니다.</span>';

                // Check if another draw is possible
                if (this.currentCounts.circle < 4 || this.currentCounts.triangle < 6 || this.currentCounts.square < 10) {
                    this.drawBtn.disabled = true;
                    setTimeout(() => {
                         this.conclusionEl.innerHTML += '<br><span class="text-xs text-gray-500">이제 더 이상 비례에 맞춰 뽑을 수 없습니다.</span>';
                    }, 1000);
                }
            }, 300);
        }
    };


    // --- 보너스: 퀴즈 ---
    const bonusQuiz = {
        questionEl: document.getElementById('quiz-question'),
        optionsEl: document.getElementById('quiz-options'),
        feedbackEl: document.getElementById('quiz-feedback'),
        
        currentQuestionIndex: 0,
        questions: [
            {
                question: "주사위 한 개를 던질 때, '홀수가 나오는 사건'과 '짝수가 나오는 사건'의 관계는?",
                options: ["독립", "배반", "둘 다 해당", "둘 다 아님"],
                answer: 1,
                explanation: "홀수와 짝수는 동시에 나올 수 없으므로 배반 사건입니다. 배반 사건은 서로 종속입니다."
            },
            {
                question: "카드 덱에서 한 장을 뽑을 때, '하트(♥)가 나오는 사건'과 '킹(K)이 나오는 사건'의 관계는?",
                options: ["독립", "배반", "둘 다 해당", "둘 다 아님"],
                answer: 0,
                explanation: "하트 킹(K♥)이 존재하므로 배반이 아닙니다. P(하트)=1/4, P(킹)=1/13, P(하트∩킹)=1/52 이므로 P(하트)×P(킹)=P(하트∩킹)이 성립하여 독립입니다."
            },
             {
                question: "오늘 비가 올 사건과 내일 비가 올 사건의 관계는?",
                options: ["독립", "배반", "종속", "알 수 없음"],
                answer: 2,
                explanation: "일반적으로 오늘의 날씨는 내일의 날씨에 영향을 줍니다. 따라서 두 사건은 서로 종속 관계에 가깝습니다."
            }
        ],

        init() {
            this.loadQuestion();
        },

        loadQuestion() {
            this.feedbackEl.innerHTML = '';
            const q = this.questions[this.currentQuestionIndex];
            this.questionEl.textContent = `Q${this.currentQuestionIndex+1}. ${q.question}`;
            this.optionsEl.innerHTML = '';
            q.options.forEach((option, index) => {
                const button = document.createElement('button');
                button.textContent = option;
                button.className = "quiz-option p-3 bg-white border-2 border-gray-200 rounded-lg hover:bg-gray-100 hover:border-indigo-400";
                button.onclick = () => this.checkAnswer(index);
                this.optionsEl.appendChild(button);
            });
        },

        checkAnswer(selectedIndex) {
            const q = this.questions[this.currentQuestionIndex];
            const buttons = this.optionsEl.children;

            for(let btn of buttons) {
                btn.disabled = true;
                if(btn.textContent === q.options[q.answer]) {
                    btn.classList.add('bg-green-200', 'border-green-400');
                }
            }

            if (selectedIndex === q.answer) {
                this.feedbackEl.innerHTML = `<p class="text-green-600 font-bold">정답입니다!</p><p class="text-sm">${q.explanation}</p>`;
                buttons[selectedIndex].classList.add('bg-green-200', 'border-green-400');

            } else {
                this.feedbackEl.innerHTML = `<p class="text-red-600 font-bold">오답입니다.</p><p class="text-sm">${q.explanation}</p>`;
                buttons[selectedIndex].classList.add('bg-red-200', 'border-red-400');
            }

            const nextButton = document.createElement('button');
            nextButton.textContent = '다음 문제 →';
            nextButton.className = 'mt-3 bg-indigo-500 text-white py-1 px-3 rounded-md text-sm';
            nextButton.onclick = () => {
                this.currentQuestionIndex = (this.currentQuestionIndex + 1) % this.questions.length;
                this.loadQuestion();
            };
            this.feedbackEl.appendChild(nextButton);
        }
    };
</script>

</body>
</html>

