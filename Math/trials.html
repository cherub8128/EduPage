<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>확률의 세계: 독립 사건 탐험하기</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- KaTeX CDN 추가 -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" xintegrity="sha384-n8MVd4RsNIU0KOVEMeaPoAbJNdMYGNpaLCITPbUdaJblrzJNE2agrdMLIHN5EQGk" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" xintegrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzYCEHPNKAqv8i5HuaMusnvENqVd+BovHtCQ" crossorigin="anonymous"></script>
    <script>
        // KaTeX auto-rendering
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false}
                ]
            });
        });
    </script>
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
        }
        .shape {
            width: 40px;
            height: 40px;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            margin: 4px;
            border-radius: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .shape-circle { background-color: #ef4444; border-radius: 50%; } /* red-500 */
        .shape-triangle { 
            width: 0;
            height: 0;
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
            border-bottom: 35px solid #3b82f6; /* blue-500 */
            background-color: transparent;
        }
        .shape-square { background-color: #22c55e; } /* green-500 */
        .coin {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: bold;
            color: #64748b;
            background: linear-gradient(45deg, #f1f5f9, #cbd5e1);
            box-shadow: 4px 4px 8px #94a3b8, -4px -4px 8px #ffffff;
            cursor: pointer;
            transition: transform 0.5s;
            transform-style: preserve-3d;
        }
        .coin.flipping {
            transform: rotateY(900deg);
        }
        .quiz-option {
            transition: background-color 0.2s;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 p-4 md:p-8">

    <div class="max-w-4xl mx-auto">
        <header class="text-center mb-12">
            <h1 class="text-4xl md:text-5xl font-bold text-gray-900">확률의 세계: 독립 사건 탐험하기</h1>
            <p class="mt-4 text-lg text-gray-600">
                어떤 사건이 다른 사건에 영향을 주지 않을 때 '독립'이라고 합니다. <br class="hidden md:block">
                여러 실험을 통해 독립 사건과 종속 사건의 차이를 직접 체험해 보세요.
            </p>
        </header>

        <main class="space-y-12">
            <!-- 실험 1: 복원 추출 vs. 비복원 추출 -->
            <section class="bg-white p-6 rounded-xl shadow-lg">
                <h2 class="text-2xl font-bold mb-4">실험 1: 복원 추출 vs. 비복원 추출</h2>
                <p class="mb-6 text-gray-600">주머니에서 공을 뽑을 때, 뽑은 공을 다시 넣는(복원) 경우와 넣지 않는(비복원) 경우의 확률 변화를 비교해 봅시다.</p>
                <div class="grid md:grid-cols-2 gap-8">
                    <!-- 복원 추출 -->
                    <div>
                        <h3 class="text-xl font-semibold mb-3 text-center text-indigo-600">복원 추출 (독립 사건)</h3>
                        <div id="restoration-bag" class="h-48 bg-gray-100 rounded-lg p-4 flex flex-wrap content-start"></div>
                        <div class="text-center my-4">
                            <button id="draw-restoration" class="bg-indigo-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-indigo-700 transition">공 뽑기</button>
                        </div>
                        <div id="restoration-prob" class="text-center font-mono"></div>
                        <p class="text-sm text-center text-gray-500 mt-2">뽑은 공을 다시 넣기 때문에, 다음 공을 뽑을 확률은 항상 동일합니다.</p>
                    </div>
                    <!-- 비복원 추출 -->
                    <div>
                        <h3 class="text-xl font-semibold mb-3 text-center text-teal-600">비복원 추출 (종속 사건)</h3>
                        <div id="non-restoration-bag" class="h-48 bg-gray-100 rounded-lg p-4 flex flex-wrap content-start"></div>
                        <div class="text-center my-4">
                            <button id="draw-non-restoration" class="bg-teal-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-teal-700 transition">공 뽑기</button>
                        </div>
                        <div id="non-restoration-prob" class="text-center font-mono"></div>
                        <p class="text-sm text-center text-gray-500 mt-2">뽑은 공을 제거하기 때문에, 다음 공을 뽑을 확률이 계속 변합니다.</p>
                    </div>
                </div>
                 <div class="text-center mt-6">
                    <button id="reset-exp1" class="text-sm text-gray-500 hover:text-gray-700 underline">실험 1 초기화</button>
                </div>
            </section>

            <!-- 실험 2: 동전 던지기와 갬블러의 오류 -->
            <section class="bg-white p-6 rounded-xl shadow-lg">
                <h2 class="text-2xl font-bold mb-4">실험 2: 동전 던지기와 갬블러의 오류</h2>
                <p class="mb-6 text-gray-600">동전을 던지는 것은 대표적인 독립 시행입니다. 앞면이 연속으로 나왔다고 해서 다음번에 뒷면이 나올 확률이 높아질까요? 직접 확인해 보세요.</p>
                <div class="flex flex-col items-center">
                    <div id="coin" class="coin">?</div>
                    <p class="my-4 font-semibold">다음 결과 예측: <span class="text-blue-600">앞면 50%</span>, <span class="text-red-600">뒷면 50%</span></p>
                    <div class="mt-4 w-full bg-gray-100 p-3 rounded-lg">
                        <h4 class="font-semibold mb-2">결과 기록:</h4>
                        <div id="coin-history" class="text-lg flex flex-wrap gap-x-2"></div>
                    </div>
                     <div class="text-center mt-6">
                        <button id="reset-exp2" class="text-sm text-gray-500 hover:text-gray-700 underline">실험 2 초기화</button>
                    </div>
                </div>
            </section>

            <!-- 실험 3: 비복원 추출은 독립 시행일까? -->
            <section class="bg-white p-6 rounded-xl shadow-lg">
                <h2 class="text-2xl font-bold mb-4">탐구: 비복원 추출은 정말 독립 시행일까?</h2>
                <p class="mb-6 text-gray-600">상자 안에 여러 모양의 도형이 있습니다. 도형을 하나씩 꺼낼 때(비복원), 다음에 특정 도형을 뽑을 확률이 어떻게 변하는지 관찰해 봅시다.</p>
                <div id="shape-box" class="min-h-48 bg-gray-100 rounded-lg p-4 flex flex-wrap content-start items-center justify-center"></div>
                <div class="text-center my-4">
                    <button id="draw-shape" class="bg-amber-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-amber-700 transition">도형 뽑기</button>
                </div>
                <div>
                    <h4 class="font-semibold text-center mb-2">다음 시행의 확률</h4>
                    <div id="shape-prob" class="text-center font-mono flex justify-around"></div>
                </div>
                <p id="shape-conclusion" class="mt-4 text-center font-semibold text-red-600 h-6"></p>
                 <div class="text-center mt-6">
                    <button id="reset-exp3" class="text-sm text-gray-500 hover:text-gray-700 underline">실험 3 초기화</button>
                </div>
            </section>

            <!-- 보너스: 독립 vs 배반 -->
            <section class="bg-white p-6 rounded-xl shadow-lg">
                <h2 class="text-2xl font-bold mb-4">보너스: 독립 사건 vs. 배반 사건</h2>
                <div class="space-y-4 text-gray-600">
                    <p>독립과 배반은 자주 혼동되지만 전혀 다른 개념입니다.</p>
                    <div class="grid md:grid-cols-2 gap-6">
                        <div class="bg-blue-50 p-4 rounded-lg">
                            <h4 class="font-bold text-lg text-blue-800">독립 사건 (Independent Events)</h4>
                            <p>두 사건 A, B가 서로의 확률에 <strong class="text-blue-800">영향을 주지 않는 관계</strong>입니다. 즉, 한 사건이 일어났다는 사실이 다른 사건의 확률을 바꾸지 않습니다.</p>
                            <div class="mt-2 font-mono bg-blue-100 p-2 rounded text-center text-sm katex-container">$P(A \cap B) = P(A) \times P(B)$</div>
                            <p class="mt-2 text-sm">예: 동전을 던져 앞면이 나오는 사건과 주사위를 던져 짝수가 나오는 사건.</p>
                        </div>
                        <div class="bg-red-50 p-4 rounded-lg">
                            <h4 class="font-bold text-lg text-red-800">배반 사건 (Mutually Exclusive)</h4>
                            <p>두 사건 A, B가 <strong class="text-red-800">절대 동시에 일어날 수 없는 관계</strong>입니다. 교집합이 공집합($\emptyset$)입니다.</p>
                             <div class="mt-2 font-mono bg-red-100 p-2 rounded text-center text-sm katex-container">$P(A \cap B) = 0$</div>
                            <p class="mt-2 text-sm">예: 주사위 한 개를 던져 1이 나오는 사건과 6이 나오는 사건.</p>
                        </div>
                    </div>
                </div>
                
                <div class="mt-8 border-t pt-6">
                    <h3 class="text-xl font-semibold mb-4">독립과 배반에 대한 참/거짓 명제</h3>
                    <div class="space-y-6">
                        <div class="bg-gray-50 p-4 rounded-lg">
                            <p class="font-semibold">명제 1: 두 사건 A, B가 배반 사건이면, 두 사건은 서로 독립이다.</p>
                            <p class="mt-2"><strong class="text-red-600">거짓</strong></p>
                            <p class="text-sm text-gray-700 mt-1">
                                <strong>설명:</strong> (단, $P(A) \neq 0, P(B) \neq 0$) <br>
                                두 사건 A, B가 배반이면 $P(A \cap B) = 0$ 입니다. <br>
                                만약 두 사건이 독립이라면 $P(A \cap B) = P(A) \times P(B)$ 를 만족해야 합니다. <br>
                                하지만 $P(A) > 0, P(B) > 0$ 이므로 $P(A) \times P(B) > 0$ 입니다. <br>
                                따라서 $0 \neq P(A) \times P(B)$ 이므로, 두 사건은 독립이 아니라 <strong class="text-indigo-600">종속</strong>입니다.
                            </p>
                        </div>
                        <div class="bg-gray-50 p-4 rounded-lg">
                            <p class="font-semibold">명제 2: 두 사건 A, B가 서로 독립이면, 두 사건은 배반 사건이다.</p>
                            <p class="mt-2"><strong class="text-red-600">거짓</strong></p>
                             <p class="text-sm text-gray-700 mt-1">
                                <strong>설명:</strong> (단, $P(A) \neq 0, P(B) \neq 0$) <br>
                                두 사건이 독립이면 $P(A \cap B) = P(A) \times P(B)$ 입니다. <br>
                                $P(A)>0, P(B)>0$ 이므로, $P(A \cap B) > 0$ 입니다. <br>
                                배반 사건의 정의는 $P(A \cap B) = 0$ 이므로, 두 사건은 배반 사건이 될 수 없습니다.
                            </p>
                        </div>
                        <div class="bg-gray-50 p-4 rounded-lg">
                            <p class="font-semibold">명제 3: 두 사건 A, B가 서로 독립이면, A와 B의 여사건($B^c$)도 서로 독립이다.</p>
                            <p class="mt-2"><strong class="text-green-600">참</strong></p>
                             <p class="text-sm text-gray-700 mt-1">
                                <strong>증명:</strong> A와 $B^c$가 독립임을 보이려면 $P(A \cap B^c) = P(A) \times P(B^c)$ 임을 보이면 됩니다. <br>
                                $P(A \cap B^c) = P(A) - P(A \cap B)$ 입니다. <br>
                                A와 B가 독립이므로 $P(A \cap B) = P(A) \times P(B)$ 입니다. <br>
                                따라서, $P(A \cap B^c) = P(A) - P(A)P(B) = P(A)(1-P(B)) = P(A)P(B^c)$ 입니다. <br>
                                그러므로 A와 $B^c$는 서로 독립입니다. (마찬가지로 $A^c$와 B, $A^c$와 $B^c$도 서로 독립입니다.)
                            </p>
                        </div>
                    </div>
                </div>

                <div class="mt-8 border-t pt-6">
                    <h3 class="text-xl font-semibold text-center mb-4">개념 확인 퀴즈</h3>
                    <div id="quiz-container" class="bg-gray-50 p-4 rounded-lg">
                        <p id="quiz-question" class="font-semibold mb-4 text-center"></p>
                        <div id="quiz-options" class="grid grid-cols-1 md:grid-cols-2 gap-3"></div>
                        <div id="quiz-feedback" class="mt-4 text-center"></div>
                    </div>
                </div>
            </section>
        </main>
    </div>

<script>
    // KaTeX 렌더링을 위한 함수
    function renderKaTeX() {
        if (window.katex) {
            const containers = document.querySelectorAll('.katex-container');
            containers.forEach(container => {
                const tex = container.textContent || container.innerText;
                try {
                    katex.render(tex, container, {
                        throwOnError: false,
                        displayMode: true
                    });
                } catch (e) {
                    console.error(e);
                }
            });
             const inlineContainers = document.querySelectorAll('p, strong, span');
             inlineContainers.forEach(el => {
                 if (el.innerHTML.includes('$')) {
                    // This is a simple replacement and might not handle all cases.
                    // For a robust solution, a more advanced parser would be needed.
                 }
             });
        }
    }


    // --- 유틸리티 함수 ---
    const createBall = (color) => {
        const ball = document.createElement('div');
        ball.className = `w-6 h-6 rounded-full m-1 shadow ${color}`;
        return ball;
    };

    const createShape = (type) => {
        const shape = document.createElement('div');
        if (type === 'circle') shape.className = 'shape shape-circle';
        else if (type === 'triangle') shape.className = 'shape shape-triangle';
        else if (type === 'square') shape.className = 'shape shape-square';
        return shape;
    };

    const formatProb = (count, total) => total > 0 ? (count / total * 100).toFixed(1) : 0;

    // --- 실험 1: 복원 vs 비복원 ---
    const exp1 = {
        restorationBagEl: document.getElementById('restoration-bag'),
        nonRestorationBagEl: document.getElementById('non-restoration-bag'),
        restorationProbEl: document.getElementById('restoration-prob'),
        nonRestorationProbEl: document.getElementById('non-restoration-prob'),
        drawRestorationBtn: document.getElementById('draw-restoration'),
        drawNonRestorationBtn: document.getElementById('draw-non-restoration'),
        resetBtn: document.getElementById('reset-exp1'),
        
        initialBalls: { 'bg-red-500': 5, 'bg-blue-500': 5, 'bg-green-500': 5 },
        restorationBalls: [],
        nonRestorationBalls: [],
        
        init() {
            this.restorationBalls = Object.entries(this.initialBalls).flatMap(([color, count]) => Array(count).fill(color));
            this.nonRestorationBalls = [...this.restorationBalls];
            this.render();
            this.drawRestorationBtn.onclick = () => this.draw('restoration');
            this.drawNonRestorationBtn.onclick = () => this.draw('non-restoration');
            this.resetBtn.onclick = () => this.init();
        },
        
        render() {
            this.restorationBagEl.innerHTML = '';
            this.restorationBalls.forEach(color => this.restorationBagEl.appendChild(createBall(color)));
            
            this.nonRestorationBagEl.innerHTML = '';
            this.nonRestorationBalls.forEach(color => this.nonRestorationBagEl.appendChild(createBall(color)));
            
            this.updateProbs();
        },
        
        updateProbs() {
            const updateEl = (el, balls) => {
                const counts = balls.reduce((acc, color) => ({...acc, [color]: (acc[color] || 0) + 1 }), {});
                const total = balls.length;
                el.innerHTML = `
                    <span class="text-red-500">● ${formatProb(counts['bg-red-500'] || 0, total)}%</span>
                    <span class="text-blue-500">● ${formatProb(counts['bg-blue-500'] || 0, total)}%</span>
                    <span class="text-green-500">● ${formatProb(counts['bg-green-500'] || 0, total)}%</span>
                `;
            };
            updateEl(this.restorationProbEl, this.restorationBalls);
            updateEl(this.nonRestorationProbEl, this.nonRestorationBalls);
        },

        draw(type) {
            const bag = type === 'restoration' ? this.restorationBalls : this.nonRestorationBalls;
            if (bag.length === 0) return;

            const index = Math.floor(Math.random() * bag.length);
            const drawnColor = bag[index];

            const bagEl = type === 'restoration' ? this.restorationBagEl : this.nonRestorationBagEl;
            const drawnBall = bagEl.children[index];

            drawnBall.style.transform = 'scale(1.5) translateY(-50px)';
            drawnBall.style.zIndex = '10';

            setTimeout(() => {
                if (type === 'non-restoration') {
                    this.nonRestorationBalls.splice(index, 1);
                }
                this.render();
            }, 800);
        }
    };
    exp1.init();
    
    // --- 실험 2: 동전 던지기 ---
    const exp2 = {
        coinEl: document.getElementById('coin'),
        historyEl: document.getElementById('coin-history'),
        resetBtn: document.getElementById('reset-exp2'),
        
        init() {
            this.coinEl.onclick = () => this.flip();
            this.resetBtn.onclick = () => {
                this.historyEl.innerHTML = '';
                this.coinEl.textContent = '?';
            };
        },

        flip() {
            if (this.coinEl.classList.contains('flipping')) return;
            
            this.coinEl.classList.add('flipping');
            this.coinEl.textContent = '';

            setTimeout(() => {
                const result = Math.random() < 0.5 ? '앞' : '뒤';
                this.coinEl.classList.remove('flipping');
                this.coinEl.textContent = result;
                
                const resultEl = document.createElement('span');
                resultEl.textContent = result;
                resultEl.className = result === '앞' ? 'text-blue-600' : 'text-red-600';
                this.historyEl.appendChild(resultEl);
            }, 1000);
        }
    };
    exp2.init();
    
    // --- 실험 3: 비복원 추출 심화 ---
    const exp3 = {
        boxEl: document.getElementById('shape-box'),
        probEl: document.getElementById('shape-prob'),
        conclusionEl: document.getElementById('shape-conclusion'),
        drawBtn: document.getElementById('draw-shape'),
        resetBtn: document.getElementById('reset-exp3'),

        initialShapes: { 'circle': 7, 'triangle': 7, 'square': 7 },
        currentShapes: [],

        init() {
            this.currentShapes = Object.entries(this.initialShapes).flatMap(([type, count]) => Array(count).fill(type));
            this.render();
            this.drawBtn.onclick = () => this.draw();
            this.resetBtn.onclick = () => this.init();
            this.conclusionEl.textContent = '';
        },
        
        render() {
            this.boxEl.innerHTML = '';
            this.currentShapes.forEach(type => this.boxEl.appendChild(createShape(type)));
            this.updateProbs();
        },

        updateProbs() {
            const counts = this.currentShapes.reduce((acc, type) => ({...acc, [type]: (acc[type] || 0) + 1 }), {});
            const total = this.currentShapes.length;
            this.probEl.innerHTML = `
                <span class="text-red-500">● ${formatProb(counts['circle'] || 0, total)}%</span>
                <span class="text-blue-500">▲ ${formatProb(counts['triangle'] || 0, total)}%</span>
                <span class="text-green-500">■ ${formatProb(counts['square'] || 0, total)}%</span>
            `;
        },

        draw() {
            if (this.currentShapes.length === 0) return;
            
            const index = Math.floor(Math.random() * this.currentShapes.length);
            
            const drawnShapeEl = this.boxEl.children[index];
            drawnShapeEl.style.transform = 'scale(1.5) translateY(-60px)';
            drawnShapeEl.style.opacity = '0';
            
            setTimeout(() => {
                this.currentShapes.splice(index, 1);
                this.render();
                this.conclusionEl.textContent = '확률이 변했습니다! 이것은 종속 사건입니다.';
            }, 500);
        }
    };
    exp3.init();

    // --- 보너스: 퀴즈 ---
    const bonusQuiz = {
        questionEl: document.getElementById('quiz-question'),
        optionsEl: document.getElementById('quiz-options'),
        feedbackEl: document.getElementById('quiz-feedback'),
        
        currentQuestionIndex: 0,
        questions: [
            {
                question: "주사위 한 개를 던질 때, '홀수가 나오는 사건'과 '짝수가 나오는 사건'의 관계는?",
                options: ["독립", "배반", "둘 다 해당", "둘 다 아님"],
                answer: 1,
                explanation: "홀수와 짝수는 동시에 나올 수 없으므로 배반 사건입니다. 배반 사건은 서로 종속입니다."
            },
            {
                question: "카드 덱에서 한 장을 뽑을 때, '하트(♥)가 나오는 사건'과 '킹(K)이 나오는 사건'의 관계는?",
                options: ["독립", "배반", "둘 다 해당", "둘 다 아님"],
                answer: 0,
                explanation: "하트 킹(K♥)이 존재하므로 배반이 아닙니다. P(하트)=1/4, P(킹)=1/13, P(하트∩킹)=1/52 이므로 P(하트)×P(킹)=P(하트∩킹)이 성립하여 독립입니다."
            },
             {
                question: "오늘 비가 올 사건과 내일 비가 올 사건의 관계는?",
                options: ["독립", "배반", "종속", "알 수 없음"],
                answer: 2,
                explanation: "일반적으로 오늘의 날씨는 내일의 날씨에 영향을 줍니다. 따라서 두 사건은 서로 종속 관계에 가깝습니다."
            }
        ],

        init() {
            this.loadQuestion();
        },

        loadQuestion() {
            this.feedbackEl.innerHTML = '';
            const q = this.questions[this.currentQuestionIndex];
            this.questionEl.textContent = `Q${this.currentQuestionIndex+1}. ${q.question}`;
            this.optionsEl.innerHTML = '';
            q.options.forEach((option, index) => {
                const button = document.createElement('button');
                button.textContent = option;
                button.className = "quiz-option p-3 bg-white border-2 border-gray-200 rounded-lg hover:bg-gray-100 hover:border-indigo-400";
                button.onclick = () => this.checkAnswer(index);
                this.optionsEl.appendChild(button);
            });
        },

        checkAnswer(selectedIndex) {
            const q = this.questions[this.currentQuestionIndex];
            const buttons = this.optionsEl.children;

            // Disable buttons after selection
            for(let btn of buttons) {
                btn.disabled = true;
                if(btn.textContent === q.options[q.answer]) {
                    btn.classList.add('bg-green-200', 'border-green-400');
                }
            }

            if (selectedIndex === q.answer) {
                this.feedbackEl.innerHTML = `<p class="text-green-600 font-bold">정답입니다!</p><p class="text-sm">${q.explanation}</p>`;
                buttons[selectedIndex].classList.add('bg-green-200', 'border-green-400');

            } else {
                this.feedbackEl.innerHTML = `<p class="text-red-600 font-bold">오답입니다.</p><p class="text-sm">${q.explanation}</p>`;
                buttons[selectedIndex].classList.add('bg-red-200', 'border-red-400');
            }

            const nextButton = document.createElement('button');
            nextButton.textContent = '다음 문제 →';
            nextButton.className = 'mt-3 bg-indigo-500 text-white py-1 px-3 rounded-md text-sm';
            nextButton.onclick = () => {
                this.currentQuestionIndex = (this.currentQuestionIndex + 1) % this.questions.length;
                this.loadQuestion();
            };
            this.feedbackEl.appendChild(nextButton);
        }
    };
    
    document.addEventListener('DOMContentLoaded', function() {
        renderKaTeX();
        bonusQuiz.init();
    });

</script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" xintegrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzYCEHPNKAqv8i5HuaMusnvENqVd+BovHtCQ" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" xintegrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>

</body>
</html>

