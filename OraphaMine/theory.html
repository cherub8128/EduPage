<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì˜¤ë¼íŒŒ ë§ˆì¸: ì—”íŠ¸ë¡œí”¼ì™€ ìµœì ì˜ ì§ˆë¬¸</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
        }
        .gem-board {
            display: grid;
            grid-template-columns: repeat(5, 30px);
            grid-template-rows: repeat(4, 30px);
            gap: 1px;
        }
        .gem-cell {
            width: 30px;
            height: 30px;
            background-color: rgba(255, 255, 255, 0.1);
            position: relative;
        }
        .gem-piece {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        .entry-point {
            transition: all 0.2s ease-in-out;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-12">
            <h1 class="text-4xl md:text-5xl font-bold text-cyan-400 mb-2">ì˜¤ë¼íŒŒ ë§ˆì¸ê³¼ ì •ë³´ ì´ë¡  ğŸ’</h1>
            <p class="text-lg text-gray-400">ì—”íŠ¸ë¡œí”¼ ìµœì†Œí™”ë¡œ ìµœì ì˜ ì§ˆë¬¸ ì°¾ê¸°</p>
        </header>

        <main class="space-y-16">
            <!-- ì„¹ì…˜ 1: ê°œë… ì„¤ëª… -->
            <section class="bg-gray-800 p-6 rounded-lg shadow-lg">
                <h2 class="text-3xl font-bold mb-4 text-cyan-300 border-b-2 border-cyan-500 pb-2">1. 'ì¢‹ì€ ì§ˆë¬¸'ì´ë€ ë¬´ì—‡ì¼ê¹Œìš”?</h2>
                <div class="space-y-4 text-gray-300">
                    <p>ì˜¤ë¼íŒŒ ë§ˆì¸ì—ì„œ ìš°ë¦¬ì˜ ëª©í‘œëŠ” ìµœì†Œí•œì˜ ì§ˆë¬¸ìœ¼ë¡œ ë³´ì„ì˜ ìœ„ì¹˜ë¥¼ ì•Œì•„ë‚´ëŠ” ê²ƒì…ë‹ˆë‹¤. ê·¸ë ‡ë‹¤ë©´ ì–´ë–¤ ì§ˆë¬¸ì´ 'ì¢‹ì€ ì§ˆë¬¸'ì¼ê¹Œìš”? ì •ë‹µì€ <strong class="text-yellow-400">"ê°€ì¥ ë§ì€ ì •ë³´ë¥¼ ì£¼ëŠ” ì§ˆë¬¸"</strong>ì…ë‹ˆë‹¤.</p>
                    <p>ì •ë³´ ì´ë¡ ì—ì„œ 'ì •ë³´ëŸ‰'ì€ 'ë¶ˆí™•ì‹¤ì„±ì˜ ê°ì†ŒëŸ‰'ìœ¼ë¡œ ì •ì˜ë©ë‹ˆë‹¤. ê²Œì„ ì‹œì‘ ì‹œ, ìˆ˜ë§ì€ ì •ë‹µ í›„ë³´ë“¤ ë•Œë¬¸ì— ë¶ˆí™•ì‹¤ì„±ì´ ë§¤ìš° ë†’ìŠµë‹ˆë‹¤. ìš°ë¦¬ëŠ” ì§ˆë¬¸ì„ í†µí•´ ì´ ë¶ˆí™•ì‹¤ì„±ì„ ì¤„ì—¬ë‚˜ê°€ì•¼ í•©ë‹ˆë‹¤. ì´ ë¶ˆí™•ì‹¤ì„±ì˜ ì •ë„ë¥¼ ì¸¡ì •í•˜ëŠ” ì§€í‘œê°€ ë°”ë¡œ <strong class="text-yellow-400">ì—”íŠ¸ë¡œí”¼(Entropy)</strong>ì…ë‹ˆë‹¤.</p>
                    <div class="bg-gray-700 p-4 rounded-md">
                        <p><strong class="text-xl text-cyan-400">ì—”íŠ¸ë¡œí”¼ (H)</strong> = ë¶ˆí™•ì‹¤ì„±ì˜ ì´ëŸ‰. ì •ë‹µ í›„ë³´ê°€ ë§ê³  ê²°ê³¼ ì˜ˆì¸¡ì´ ì–´ë ¤ìš¸ìˆ˜ë¡ ì—”íŠ¸ë¡œí”¼ëŠ” ë†’ìŠµë‹ˆë‹¤.</p>
                        <p><strong class="text-xl text-cyan-400">ì •ë³´ íšë“ëŸ‰ (IG)</strong> = (ì§ˆë¬¸ ì „ ì—”íŠ¸ë¡œí”¼) - (ì§ˆë¬¸ í›„ í‰ê·  ì—”íŠ¸ë¡œí”¼). ì´ ê°’ì´ í´ìˆ˜ë¡ ì¢‹ì€ ì§ˆë¬¸ì…ë‹ˆë‹¤.</p>
                    </div>
                    <p>ë”°ë¼ì„œ, ìµœì ì˜ ì§ˆë¬¸ì€ **ì •ë³´ íšë“ëŸ‰ì´ ê°€ì¥ í° ì§ˆë¬¸**, ì¦‰ ì§ˆë¬¸ í›„ ë‚¨ê²Œ ë  **í‰ê·  ì—”íŠ¸ë¡œí”¼ë¥¼ ìµœì†Œí™”**í•˜ëŠ” ì§ˆë¬¸ì…ë‹ˆë‹¤. ì´ëŠ” ê°€ëŠ¥í•œ ì •ë‹µ í›„ë³´ë“¤ì„ ê°€ì¥ ê· ë“±í•˜ê²Œ ë‚˜ëˆ ì£¼ëŠ” ì§ˆë¬¸ì¼ ê°€ëŠ¥ì„±ì´ ë†’ìŠµë‹ˆë‹¤.</p>
                </div>
            </section>

            <!-- ì„¹ì…˜ 2: ì¸í„°ë™í‹°ë¸Œ ì‹œë®¬ë ˆì´í„° -->
            <section class="bg-gray-800 p-6 rounded-lg shadow-lg">
                <h2 class="text-3xl font-bold mb-4 text-cyan-300 border-b-2 border-cyan-500 pb-2">2. ì¸í„°ë™í‹°ë¸Œ ì‹œë®¬ë ˆì´ì…˜</h2>
                <p class="mb-6 text-gray-300">ì•„ë˜ 4ê°œì˜ ë³´ë“œê°€ í˜„ì¬ ê°€ëŠ¥í•œ ì •ë‹µ í›„ë³´ë¼ê³  ê°€ì •í•´ ë´…ì‹œë‹¤. ì–´ë–¤ ì§ˆë¬¸ì´ ê°€ì¥ íš¨ìœ¨ì ì¼ì§€ ì§ì ‘ ê³„ì‚°í•´ ë³´ì„¸ìš”.</p>
                
                <div id="interactive-area" class="space-y-8">
                    <!-- ì •ë‹µ í›„ë³´ ë³´ë“œ -->
                    <div>
                        <h3 class="text-2xl font-semibold mb-4 text-gray-100">ì •ë‹µ í›„ë³´ (4ê°€ì§€ ê²½ìš°)</h3>
                        <div id="solution-candidates" class="grid grid-cols-2 md:grid-cols-4 gap-4"></div>
                    </div>

                    <!-- ê³„ì‚°ê¸° -->
                    <div class="bg-gray-700 p-6 rounded-lg">
                        <h3 class="text-2xl font-semibold mb-4 text-gray-100">ìµœì  ì§ˆë¬¸ ê³„ì‚°ê¸°</h3>
                        <div class="flex flex-col md:flex-row gap-6">
                            <!-- ì‹œë®¬ë ˆì´ì…˜ ë³´ë“œ -->
                            <div class="flex-shrink-0">
                                <p class="text-center mb-2 font-semibold">í…ŒìŠ¤íŠ¸í•  ì§ˆë¬¸ì„ ì„ íƒí•˜ì„¸ìš”</p>
                                <div id="main-sim-board" class="relative w-max mx-auto">
                                    <!-- Entry points will be generated here -->
                                </div>
                            </div>
                            <!-- ê³„ì‚° ê²°ê³¼ -->
                            <div id="calculation-result" class="flex-grow">
                                <p class="text-gray-400 text-center md:text-left">ë ˆì´ì € ë°œì‚¬ ì§€ì ì„ í´ë¦­í•˜ì—¬ ì •ë³´ íšë“ëŸ‰ì„ ê³„ì‚°í•˜ì„¸ìš”.</p>
                            </div>
                        </div>
                        <div class="mt-6 text-center">
                            <button id="calculate-all-btn" class="bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-2 px-4 rounded-lg transition-transform transform hover:scale-105">
                                ëª¨ë“  ì§ˆë¬¸ì˜ ì •ë³´ëŸ‰ í•œ ë²ˆì— ê³„ì‚°í•˜ê¸°
                            </button>
                        </div>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <script>
        // Simplified game engine for the explainer
        const explainerConfig = {
            BOARD_W: 5,
            BOARD_H: 4,
            GEMS: {
                yellow_triangle: { color: '#f1c40f', shape: [{x:0,y:0},{x:1,y:0},{x:0,y:1}], cellShapes: {'0,0':'â—¤','1,0':'â– ','0,1':'â– '} },
                blue_rhombus: { color: '#3498db', shape: [{x:1,y:0},{x:0,y:1},{x:2,y:1},{x:1,y:2}], cellShapes: {'1,0':'â—¢','0,1':'â—¥','2,1':'â—£','1,2':'â—¤'} }
            }
        };

        const solutionCandidatesData = [
            { gems: [{ id: 'yellow_triangle', x: 0, y: 0, rot: 0, flip: false }] },
            { gems: [{ id: 'yellow_triangle', x: 3, y: 2, rot: 180, flip: false }] },
            { gems: [{ id: 'blue_rhombus', x: 1, y: 0, rot: 0, flip: false }] },
            { gems: [{ id: 'blue_rhombus', x: 0, y: 1, rot: 90, flip: false }] }
        ];

        // --- Core Logic ---
        function getTransformedGem(id, rotation, flipped) {
            const src = explainerConfig.GEMS[id];
            let shape = JSON.parse(JSON.stringify(src.shape));
            let cellShapes = JSON.parse(JSON.stringify(src.cellShapes));
            
            let w = shape.length > 0 ? Math.max(...shape.map(p => p.x)) : -1;
            let h = shape.length > 0 ? Math.max(...shape.map(p => p.y)) : -1;

            if (flipped) {
                shape.forEach(p => p.x = w - p.x);
                cellShapes = xformCellShapes(cellShapes, (x, y) => ({ x: w - x, y }), 'H');
            }

            const k = ((rotation / 90) | 0) % 4;
            for (let i = 0; i < k; i++) {
                shape.forEach(p => { const tx = p.x; p.x = h - p.y; p.y = tx; });
                cellShapes = xformCellShapes(cellShapes, (x, y) => ({ x: h - y, y: x }), 'R');
                [w, h] = [h, w];
            }

            const minX = shape.length > 0 ? Math.min(...shape.map(p => p.x)) : 0;
            const minY = shape.length > 0 ? Math.min(...shape.map(p => p.y)) : 0;
            shape.forEach(p => { p.x -= minX; p.y -= minY; });
            cellShapes = remapCellShapeKeysOffset(cellShapes, -minX, -minY);
            
            return { shape, cellShapes };
        }

        function xformCellShapes(cellShapes, mapXY, transformType) {
            const out = {};
            const transformRule = {
                'H': { 'â– ': 'â– ', 'â—¤': 'â—¥', 'â—¥': 'â—¤', 'â—£': 'â—¢', 'â—¢': 'â—£' },
                'R': { 'â– ': 'â– ', 'â—¤': 'â—¥', 'â—¥': 'â—¢', 'â—¢': 'â—£', 'â—£': 'â—¤' }
            };
            Object.entries(cellShapes).forEach(([k, v]) => {
                const [x, y] = k.split(',').map(Number);
                const { x: nx, y: ny } = mapXY(x, y);
                out[`${nx},${ny}`] = transformRule[v];
            });
            return out;
        }

        function remapCellShapeKeysOffset(cellShapes, dx, dy) {
            const out = {};
            Object.entries(cellShapes).forEach(([k, v]) => {
                const [x, y] = k.split(',').map(Number);
                out[`${x + dx},${y + dy}`] = v;
            });
            return out;
        }

        function buildGrid(gems) {
            const grid = Array(explainerConfig.BOARD_H).fill(0).map(() => Array(explainerConfig.BOARD_W).fill(null));
            gems.forEach(g => {
                const t = getTransformedGem(g.id, g.rot, g.flip);
                t.shape.forEach(p => {
                    const x = g.x + p.x, y = g.y + p.y;
                    if (x < 0 || x >= explainerConfig.BOARD_W || y < 0 || y >= explainerConfig.BOARD_H) return;
                    const key = `${p.x},${p.y}`;
                    grid[y][x] = { color: explainerConfig.GEMS[g.id].color, cellShape: t.cellShapes[key] || null };
                });
            });
            return grid;
        }

        function getReflection(cellShape, entryDir) {
            const reflect180 = (dir) => ({ type: 'STRAIGHT', newDir: { dx: -dir.dx, dy: -dir.dy } });
            const reflectDiag = (newDir) => ({ type: 'DIAGONAL', newDir });

            switch (cellShape) {
                case 'â– ': 
                    if (entryDir === 'N') return reflect180({dx:0, dy:1});
                    if (entryDir === 'S') return reflect180({dx:0, dy:-1});
                    if (entryDir === 'E') return reflect180({dx:-1, dy:0});
                    if (entryDir === 'W') return reflect180({dx:1, dy:0});
                    break;
                case 'â—¤':
                    if (entryDir === 'S') return reflectDiag({ dx: 1, dy: 0 });
                    if (entryDir === 'E') return reflectDiag({ dx: 0, dy: 1 });
                    if (entryDir === 'N') return reflect180({dx:0, dy:1});
                    if (entryDir === 'W') return reflect180({dx:1, dy:0});
                    break;
                case 'â—¥':
                    if (entryDir === 'S') return reflectDiag({ dx: -1, dy: 0 });
                    if (entryDir === 'W') return reflectDiag({ dx: 0, dy: 1 });
                    if (entryDir === 'N') return reflect180({dx:0, dy:1});
                    if (entryDir === 'E') return reflect180({dx:-1, dy:0});
                    break;
                case 'â—£':
                    if (entryDir === 'N') return reflectDiag({ dx: 1, dy: 0 });
                    if (entryDir === 'E') return reflectDiag({ dx: 0, dy: -1 });
                    if (entryDir === 'S') return reflect180({dx:0, dy:-1});
                    if (entryDir === 'W') return reflect180({dx:1, dy:0});
                    break;
                case 'â—¢':
                    if (entryDir === 'N') return reflectDiag({ dx: -1, dy: 0 });
                    if (entryDir === 'W') return reflectDiag({ dx: 0, dy: -1 });
                    if (entryDir === 'S') return reflect180({dx:0, dy:-1});
                    if (entryDir === 'E') return reflect180({dx:-1, dy:0});
                    break;
            }
            return null;
        }

        function simulateLaser(grid, startSide, startIndex) {
            let laser = {};
            switch (startSide) {
                case 'top':    laser = { pos: { x: startIndex + 0.5, y: -0.000001 }, dir: { dx: 0, dy: 1 } }; break;
                case 'bottom': laser = { pos: { x: startIndex + 0.5, y: explainerConfig.BOARD_H + 0.000001 }, dir: { dx: 0, dy: -1 } }; break;
                case 'left':   laser = { pos: { x: -0.000001, y: startIndex + 0.5 }, dir: { dx: 1, dy: 0 } }; break;
                case 'right':  laser = { pos: { x: explainerConfig.BOARD_W + 0.000001, y: startIndex + 0.5 }, dir: { dx: -1, dy: 0 } }; break;
            }

            const hitColors = new Set();
            let safety = 0;

            while (safety++ < 100) {
                let tX = Infinity, tY = Infinity;
                if (laser.dir.dx !== 0) {
                    const nextX = laser.dir.dx > 0 ? Math.floor(laser.pos.x) + 1 : Math.ceil(laser.pos.x) - 1;
                    tX = (nextX - laser.pos.x) / laser.dir.dx;
                }
                if (laser.dir.dy !== 0) {
                    const nextY = laser.dir.dy > 0 ? Math.floor(laser.pos.y) + 1 : Math.ceil(laser.pos.y) - 1;
                    tY = (nextY - laser.pos.y) / laser.dir.dy;
                }

                const t = Math.min(tX, tY) + 0.000001;
                const hitPos = { x: laser.pos.x + laser.dir.dx * t, y: laser.pos.y + laser.dir.dy * t };
                
                let cx, cy, entryDir;
                if (Math.abs(tX - (t - 0.000001)) < 0.000001) {
                    entryDir = laser.dir.dx > 0 ? 'W' : 'E';
                    cx = laser.dir.dx > 0 ? Math.floor(hitPos.x) : Math.ceil(hitPos.x) - 1;
                    cy = Math.floor(hitPos.y);
                } else {
                    entryDir = laser.dir.dy > 0 ? 'N' : 'S';
                    cx = Math.floor(hitPos.x);
                    cy = laser.dir.dy > 0 ? Math.floor(hitPos.y) : Math.ceil(hitPos.y) - 1;
                }

                if (cx < 0 || cx >= explainerConfig.BOARD_W || cy < 0 || cy >= explainerConfig.BOARD_H) {
                    const exitLabel = getExitLabel(hitPos);
                    const colors = Array.from(hitColors).sort().join(',');
                    return `${exitLabel}:${colors}`;
                }

                const cell = grid[cy][cx];
                const reflection = cell ? getReflection(cell.cellShape, entryDir) : null;

                if (cell && cell.color) hitColors.add(cell.color);

                if (reflection) {
                    laser.dir = reflection.newDir;
                    laser.pos = reflection.type === 'DIAGONAL' ? { x: cx + 0.5, y: cy + 0.5 } : hitPos;
                } else {
                    laser.pos = hitPos;
                }
            }
            return 'LOOP';
        }
        
        function getExitLabel(pos) {
            const ix = Math.round(pos.x), iy = Math.round(pos.y);
            if (iy <= 0) return `T${ix}`;
            if (iy >= explainerConfig.BOARD_H) return `B${ix}`;
            if (ix <= 0) return `L${iy}`;
            if (ix >= explainerConfig.BOARD_W) return `R${iy}`;
            return '?';
        }

        // --- UI Generation ---
        function createBoardHTML(id, gems = []) {
            let cells = '';
            for (let i = 0; i < explainerConfig.BOARD_H * explainerConfig.BOARD_W; i++) {
                cells += `<div class="gem-cell"></div>`;
            }
            const board = `<div id="${id}" class="gem-board bg-gray-700 p-1 rounded-md">${cells}</div>`;
            
            // This is a bit of a hack to append gems after the board is in the DOM
            setTimeout(() => {
                const boardEl = document.getElementById(id);
                if (!boardEl) return;
                gems.forEach(gem => {
                    const t = getTransformedGem(gem.id, gem.rot, gem.flip);
                    t.shape.forEach(p => {
                        const x = gem.x + p.x;
                        const y = gem.y + p.y;
                        const cellIndex = y * explainerConfig.BOARD_W + x;
                        const cell = boardEl.children[cellIndex];
                        if (cell) {
                            const piece = document.createElement('div');
                            piece.className = 'gem-piece';
                            piece.style.backgroundColor = explainerConfig.GEMS[gem.id].color;
                            piece.style.opacity = '0.7';
                            const clipPaths = { 'â—¤': 'polygon(0 0, 100% 0, 0 100%)', 'â—¥': 'polygon(0 0, 100% 0, 100% 100%)', 'â—£': 'polygon(0 0, 0 100%, 100% 100%)', 'â—¢': 'polygon(100% 0, 100% 100%, 0 100%)' };
                            if (t.cellShapes[`${p.x},${p.y}`] in clipPaths) {
                                piece.style.clipPath = clipPaths[t.cellShapes[`${p.x},${p.y}`]];
                            }
                            cell.appendChild(piece);
                        }
                    });
                });
            }, 0);

            return board;
        }

        function createEntryPoints(boardContainer) {
            const sides = {
                top: { count: explainerConfig.BOARD_W, class: 'flex -top-8 left-0 absolute' },
                bottom: { count: explainerConfig.BOARD_W, class: 'flex -bottom-8 left-0 absolute' },
                left: { count: explainerConfig.BOARD_H, class: 'flex flex-col -left-8 top-0 absolute' },
                right: { count: explainerConfig.BOARD_H, class: 'flex flex-col -right-8 top-0 absolute' }
            };
            
            Object.entries(sides).forEach(([side, config]) => {
                const container = document.createElement('div');
                container.className = config.class;
                for (let i = 0; i < config.count; i++) {
                    const point = document.createElement('div');
                    point.className = 'entry-point w-[30px] h-[30px] flex items-center justify-center rounded-full bg-gray-600 hover:bg-cyan-500 cursor-pointer text-xs';
                    point.dataset.side = side;
                    point.dataset.index = i;
                    point.textContent = i + 1;
                    container.appendChild(point);
                }
                boardContainer.appendChild(container);
            });
        }

        // --- Calculation & Display ---
        function calculateEntropyForQuestion(side, index) {
            const outcomes = {};
            solutionCandidatesData.forEach((candidate, solIndex) => {
                const grid = buildGrid(candidate.gems);
                const result = simulateLaser(grid, side, index);
                if (!outcomes[result]) {
                    outcomes[result] = [];
                }
                outcomes[result].push(solIndex + 1);
            });

            const N = solutionCandidatesData.length;
            let expectedEntropy = 0;
            Object.values(outcomes).forEach(group => {
                const p = group.length / N;
                if (p > 0) {
                    expectedEntropy -= p * (Math.log2(p));
                }
            });
            
            return { outcomes, expectedEntropy };
        }

        function displayCalculation(side, index) {
            const { outcomes, expectedEntropy } = calculateEntropyForQuestion(side, index);
            const resultDiv = document.getElementById('calculation-result');
            
            let outcomesHTML = Object.entries(outcomes).map(([result, solutions]) => {
                const [exit, colors] = result.split(':');
                const colorSwatches = (colors || '').split(',').filter(c => c).map(color => `<span class="inline-block w-3 h-3 rounded-sm" style="background-color:${color}"></span>`).join('') || 'íˆ¬ëª…';
                return `<div class="p-2 bg-gray-600 rounded">
                    <p class="font-semibold">ê²°ê³¼: <span class="text-cyan-400">${exit}</span> | ìƒ‰ìƒ: ${colorSwatches}</p>
                    <p class="text-sm text-gray-400">ì´ ê²°ê³¼ë¥¼ ë‚´ëŠ” í›„ë³´: ${solutions.join(', ')}</p>
                </div>`;
            }).join('');

            resultDiv.innerHTML = `
                <h4 class="text-xl font-bold mb-2">ì§ˆë¬¸: <span class="text-yellow-400">${side.toUpperCase()} ${index + 1}</span></h4>
                <div class="space-y-2 mb-4">${outcomesHTML}</div>
                <p class="text-lg font-semibold">ê²°ê³¼ ì—”íŠ¸ë¡œí”¼: <span class="text-green-400">${expectedEntropy.toFixed(4)} bits</span></p>
                <p class="text-sm text-gray-400">ê°’ì´ ë‚®ì„ìˆ˜ë¡ ë¶ˆí™•ì‹¤ì„±ì´ ë§ì´ ì œê±°ë˜ì–´ ì¢‹ì€ ì§ˆë¬¸ì…ë‹ˆë‹¤.</p>
            `;
        }
        
        function calculateAndDisplayAll() {
            const entryPoints = document.querySelectorAll('#main-sim-board .entry-point');
            const results = [];
            entryPoints.forEach(point => {
                const { side, index } = point.dataset;
                const { expectedEntropy } = calculateEntropyForQuestion(side, parseInt(index));
                results.push({ point, entropy: expectedEntropy });
            });

            const minEntropy = Math.min(...results.map(r => r.entropy));

            results.forEach(({ point, entropy }) => {
                point.textContent = entropy.toFixed(2);
                if (Math.abs(entropy - minEntropy) < 0.001) {
                    point.classList.remove('bg-gray-600', 'hover:bg-cyan-500');
                    point.classList.add('bg-green-600', 'text-white', 'font-bold', 'scale-110');
                } else {
                    point.classList.remove('bg-green-600', 'scale-110');
                    point.classList.add('bg-gray-600');
                }
            });

            const resultDiv = document.getElementById('calculation-result');
            resultDiv.innerHTML = `<p class="text-lg font-semibold text-center">ëª¨ë“  ì§ˆë¬¸ì˜ ì—”íŠ¸ë¡œí”¼ ê³„ì‚° ì™„ë£Œ!</p><p class="text-center text-gray-400"><span class="inline-block w-4 h-4 rounded-full bg-green-600 align-middle mr-2"></span>ê°€ì¥ ì •ë³´ëŸ‰ì´ ë†’ì€ (ì—”íŠ¸ë¡œí”¼ê°€ ë‚®ì€) ì§ˆë¬¸ì…ë‹ˆë‹¤.</p>`;
        }

        // --- Main Execution ---
        const candidatesContainer = document.getElementById('solution-candidates');
        solutionCandidatesData.forEach((candidate, i) => {
            const container = document.createElement('div');
            container.innerHTML = `<h4 class="text-lg font-semibold mb-2 text-center">í›„ë³´ ${i + 1}</h4>`;
            container.insertAdjacentHTML('beforeend', createBoardHTML(`candidate-${i}`, candidate.gems));
            candidatesContainer.appendChild(container);
        });

        const mainBoardContainer = document.getElementById('main-sim-board');
        mainBoardContainer.innerHTML = createBoardHTML('sim-board');
        createEntryPoints(mainBoardContainer);

        mainBoardContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('entry-point')) {
                const { side, index } = e.target.dataset;
                displayCalculation(side, parseInt(index));
            }
        });
        
        document.getElementById('calculate-all-btn').addEventListener('click', calculateAndDisplayAll);
    </script>
</body>
</html>
