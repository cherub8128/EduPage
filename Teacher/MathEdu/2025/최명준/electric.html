<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ê°€ìš°ìŠ¤ ì†Œê±°ë²•ê³¼ íšŒë¡œ ì´ë¡  ë“±ê°€ì„± ì‹œë®¬ë ˆì´ì…˜</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 20px;
        min-height: 100vh;
      }
      .container {
        max-width: 1400px;
        margin: 0 auto;
        background: white;
        border-radius: 20px;
        padding: 30px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      }
      h1 {
        text-align: center;
        color: #333;
        margin-bottom: 10px;
        font-size: 28px;
      }
      .subtitle {
        text-align: center;
        color: #666;
        margin-bottom: 30px;
        font-size: 14px;
      }
      .main-content {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 30px;
        margin-bottom: 30px;
      }
      .panel {
        background: #f8f9fa;
        border-radius: 15px;
        padding: 20px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      .panel h2 {
        color: #667eea;
        margin-bottom: 15px;
        font-size: 20px;
        border-bottom: 3px solid #667eea;
        padding-bottom: 10px;
      }
      canvas {
        border: 2px solid #ddd;
        border-radius: 10px;
        background: white;
        display: block;
        margin: 0 auto;
        cursor: crosshair;
      }
      .matrix-container {
        overflow-x: auto;
        margin: 15px 0;
      }
      table {
        margin: 0 auto;
        border-collapse: collapse;
        background: white;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      td,
      th {
        padding: 10px 15px;
        text-align: center;
        border: 1px solid #ddd;
        min-width: 60px;
        font-size: 14px;
      }
      th {
        background: #667eea;
        color: white;
        font-weight: bold;
      }
      .eliminated {
        background: #ffebee !important;
        text-decoration: line-through;
        opacity: 0.5;
      }
      .changed {
        background: #fff3cd !important;
        font-weight: bold;
        animation: highlight 0.5s ease;
      }
      @keyframes highlight {
        0%,
        100% {
          background: #fff3cd;
        }
        50% {
          background: #ffc107;
        }
      }
      .controls {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: center;
        margin-top: 20px;
      }
      button {
        padding: 12px 24px;
        font-size: 16px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-weight: bold;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
      }
      button:active {
        transform: translateY(0);
      }
      .btn-next {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
      }
      .btn-reset {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        color: white;
      }
      .btn-auto {
        background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        color: white;
      }
      .btn-preset {
        background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
        color: white;
        font-size: 14px;
        padding: 10px 20px;
      }
      .explanation {
        background: white;
        padding: 20px;
        border-radius: 10px;
        margin-top: 15px;
        border-left: 5px solid #667eea;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .explanation h3 {
        color: #667eea;
        margin-bottom: 10px;
        font-size: 16px;
      }
      .explanation p {
        color: #555;
        line-height: 1.6;
        font-size: 14px;
      }
      .step-info {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 15px;
        border-radius: 10px;
        text-align: center;
        margin-bottom: 20px;
        font-size: 18px;
        font-weight: bold;
      }
      .legend {
        display: flex;
        gap: 20px;
        justify-content: center;
        flex-wrap: wrap;
        margin-top: 15px;
        padding: 15px;
        background: white;
        border-radius: 10px;
      }
      .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
      }
      .legend-color {
        width: 30px;
        height: 20px;
        border-radius: 4px;
        border: 1px solid #ddd;
      }
      .circuit-info {
        background: white;
        padding: 15px;
        border-radius: 10px;
        margin-top: 15px;
      }
      .circuit-info h4 {
        color: #667eea;
        margin-bottom: 10px;
      }
      .circuit-info ul {
        list-style: none;
        padding-left: 0;
      }
      .circuit-info li {
        padding: 5px 0;
        color: #555;
        font-size: 14px;
      }
      .formula {
        background: #f0f0f0;
        padding: 10px;
        border-radius: 5px;
        font-family: "Courier New", monospace;
        margin: 10px 0;
        text-align: center;
        font-size: 14px;
      }
      @media (max-width: 968px) {
        .main-content {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>âš¡ ê°€ìš°ìŠ¤ ì†Œê±°ë²•ê³¼ íšŒë¡œ ì´ë¡  ë“±ê°€ì„± ì‹œë®¬ë ˆì´ì…˜</h1>
      <p class="subtitle">
        Numerical Analysis meets Circuit Theory: Gaussian Elimination as Circuit
        Reduction
      </p>
      <div class="step-info" id="stepInfo">ì´ˆê¸° ìƒíƒœ: 4ê°œ ë…¸ë“œ íšŒë¡œë§</div>
      <div class="main-content">
        <!-- íšŒë¡œ ì‹œê°í™” -->
        <div class="panel">
          <h2>ğŸ”Œ íšŒë¡œ ë„¤íŠ¸ì›Œí¬ (Circuit Network)</h2>
          <canvas id="circuitCanvas" width="600" height="500"></canvas>
          <div class="legend">
            <div class="legend-item">
              <div class="legend-color" style="background: #4caf50"></div>
              <span>í™œì„± ë…¸ë“œ</span>
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background: #f44336"></div>
              <span>ì†Œê±°ëœ ë…¸ë“œ</span>
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background: #ffc107"></div>
              <span>ë“±ê°€ ì—°ê²°</span>
            </div>
          </div>
          <div class="circuit-info" id="circuitInfo">
            <h4>íšŒë¡œ ì •ë³´</h4>
            <ul id="circuitDetails"></ul>
          </div>
        </div>
        <!-- í–‰ë ¬ ì‹œê°í™” -->
        <div class="panel">
          <h2>ğŸ“Š ì»¨ë•í„´ìŠ¤ í–‰ë ¬ (Conductance Matrix G)</h2>
          <div class="matrix-container" id="matrixG"></div>
          <h2 style="margin-top: 20px">ğŸ“ ì „ë¥˜ ë²¡í„° (Current Vector i)</h2>
          <div class="matrix-container" id="vectorI"></div>
          <div class="explanation">
            <h3>ğŸ“Œ í˜„ì¬ ë‹¨ê³„ ì„¤ëª…</h3>
            <p id="explanationText">
              ì´ˆê¸° ìƒíƒœì…ë‹ˆë‹¤. Gv = i ë°©ì •ì‹ì„ ì„¤ì •í–ˆìŠµë‹ˆë‹¤. ê° ë…¸ë“œë¥¼ ì†Œê±°í•˜ë©´
              ê°€ìš°ìŠ¤ ì†Œê±°ë²•ì˜ ì „ë°© ì†Œê±° ê³¼ì •ì´ íšŒë¡œì˜ ë“±ê°€ ë³€í™˜ê³¼ ì¼ì¹˜í•¨ì„ ë³¼ ìˆ˜
              ìˆìŠµë‹ˆë‹¤.
            </p>
          </div>
        </div>
      </div>
      <div class="controls">
        <button class="btn-preset" onclick="sim.loadPreset('simple')">
          ê°„ë‹¨í•œ íšŒë¡œ (4ë…¸ë“œ)
        </button>
        <button class="btn-preset" onclick="sim.loadPreset('complex')">
          ë³µì¡í•œ íšŒë¡œ (5ë…¸ë“œ)
        </button>
        <button class="btn-preset" onclick="sim.loadPreset('chain')">
          ì²´ì¸ íšŒë¡œ (5ë…¸ë“œ)
        </button>
        <button class="btn-next" onclick="sim.nextStep()">â–¶ ë‹¤ìŒ ë‹¨ê³„</button>
        <button class="btn-auto" onclick="sim.autoPlay()">ğŸ”„ ìë™ ì‹¤í–‰</button>
        <button class="btn-reset" onclick="sim.reset()">â†º ì´ˆê¸°í™”</button>
      </div>
      <div class="panel" style="margin-top: 30px">
        <h2>ğŸ“š ì´ë¡ ì  ë°°ê²½</h2>
        <div class="explanation">
          <h3>ê°€ìš°ìŠ¤ ì†Œê±°ë²• â‰¡ íšŒë¡œ ì¶•ì•½</h3>
          <p style="margin-bottom: 15px">
            <strong>í•µì‹¬ ë°œê²¬:</strong> ê°€ìš°ìŠ¤ ì†Œê±°ë²•ì˜ ì „ë°© ì†Œê±°(Forward
            Elimination) ê³¼ì •ì€ íšŒë¡œ ì´ë¡ ì˜ í…Œë¸Œë‚œ/ë…¸í„´ ë“±ê°€ ë³€í™˜ê³¼ ìˆ˜í•™ì ìœ¼ë¡œ
            ë™ì¼í•©ë‹ˆë‹¤.
          </p>
          <div class="formula">Î”G = Diag(G1) - (G1 Â· G1T) / (G11 + Î£G1j)</div>

          <p>
            <strong>ë¬¼ë¦¬ì  ì˜ë¯¸:</strong> ë…¸ë“œë¥¼ ì†Œê±°í•  ë•Œ, ê·¸ ë…¸ë“œì™€ ì—°ê²°ëœ
            ë‹¤ë¥¸ ë…¸ë“œë“¤ ì‚¬ì´ì— ìƒˆë¡œìš´ ë“±ê°€ ì»¨ë•í„´ìŠ¤ê°€ ìƒì„±ë©ë‹ˆë‹¤. ì´ëŠ” ì €í•­ì˜
            ì§ë ¬/ë³‘ë ¬ ì—°ê²° ë²•ì¹™ì˜ ì§ì ‘ì ì¸ ê²°ê³¼ì…ë‹ˆë‹¤.
          </p>
        </div>
      </div>
    </div>
    <script>
      class CircuitSimulator {
        constructor() {
          this.canvas = document.getElementById("circuitCanvas");
          this.ctx = this.canvas.getContext("2d");
          this.step = 0;
          this.autoPlayInterval = null;
          // ê¸°ë³¸ íšŒë¡œ ì„¤ì •
          this.loadPreset("simple");
        }
        loadPreset(type) {
          this.reset();
          if (type === "simple") {
            // 4ë…¸ë“œ ê°„ë‹¨í•œ íšŒë¡œ
            this.nodes = [
              { id: 1, x: 150, y: 150, label: "N1", eliminated: false },
              { id: 2, x: 450, y: 150, label: "N2", eliminated: false },
              { id: 3, x: 450, y: 350, label: "N3", eliminated: false },
              { id: 4, x: 150, y: 350, label: "N4", eliminated: false },
            ];
            this.edges = [
              { from: 1, to: 2, G: 2, original: true },
              { from: 2, to: 3, G: 3, original: true },
              { from: 3, to: 4, G: 2, original: true },
              { from: 4, to: 1, G: 3, original: true },
              { from: 1, to: 3, G: 1, original: true },
            ];
            this.currents = [5, -2, 3, -6]; // ê° ë…¸ë“œì˜ ì „ë¥˜ì›
          } else if (type === "complex") {
            // 5ë…¸ë“œ ë³µì¡í•œ íšŒë¡œ
            this.nodes = [
              { id: 1, x: 300, y: 100, label: "N1", eliminated: false },
              { id: 2, x: 500, y: 200, label: "N2", eliminated: false },
              { id: 3, x: 400, y: 400, label: "N3", eliminated: false },
              { id: 4, x: 200, y: 400, label: "N4", eliminated: false },
              { id: 5, x: 100, y: 200, label: "N5", eliminated: false },
            ];
            this.edges = [
              { from: 1, to: 2, G: 2, original: true },
              { from: 1, to: 5, G: 3, original: true },
              { from: 2, to: 3, G: 2, original: true },
              { from: 3, to: 4, G: 3, original: true },
              { from: 4, to: 5, G: 2, original: true },
              { from: 1, to: 3, G: 1, original: true },
              { from: 2, to: 4, G: 1, original: true },
            ];
            this.currents = [4, -3, 2, -2, -1];
          } else if (type === "chain") {
            // 5ë…¸ë“œ ì²´ì¸ íšŒë¡œ
            this.nodes = [
              { id: 1, x: 100, y: 250, label: "N1", eliminated: false },
              { id: 2, x: 200, y: 250, label: "N2", eliminated: false },
              { id: 3, x: 300, y: 250, label: "N3", eliminated: false },
              { id: 4, x: 400, y: 250, label: "N4", eliminated: false },
              { id: 5, x: 500, y: 250, label: "N5", eliminated: false },
            ];
            this.edges = [
              { from: 1, to: 2, G: 4, original: true },
              { from: 2, to: 3, G: 3, original: true },
              { from: 3, to: 4, G: 3, original: true },
              { from: 4, to: 5, G: 4, original: true },
            ];
            this.currents = [10, 0, 0, 0, -10];
          }
          this.originalEdges = JSON.parse(JSON.stringify(this.edges));
          this.calculateMatrix();
          this.draw();
        }
        calculateMatrix() {
          const n = this.nodes.length;
          this.G = Array(n)
            .fill(0)
            .map(() => Array(n).fill(0));
          // ì»¨ë•í„´ìŠ¤ í–‰ë ¬ êµ¬ì„±
          this.edges.forEach((edge) => {
            const i = edge.from - 1;
            const j = edge.to - 1;
            if (!this.nodes[i].eliminated && !this.nodes[j].eliminated) {
              this.G[i][i] += edge.G;
              this.G[j][j] += edge.G;
              this.G[i][j] -= edge.G;
              this.G[j][i] -= edge.G;
            }
          });
          this.updateDisplay();
        }
        eliminateNode(nodeIndex) {
          const node = this.nodes[nodeIndex];
          if (node.eliminated) return;
          node.eliminated = true;
          // ì†Œê±°ë˜ëŠ” ë…¸ë“œì™€ ì—°ê²°ëœ ë‹¤ë¥¸ ë…¸ë“œë“¤ ì°¾ê¸°
          const connectedNodes = [];
          this.edges.forEach((edge) => {
            if (edge.from === node.id) {
              const targetNode = this.nodes.find((n) => n.id === edge.to);
              if (!targetNode.eliminated) {
                connectedNodes.push({ id: edge.to, G: edge.G });
              }
            } else if (edge.to === node.id) {
              const targetNode = this.nodes.find((n) => n.id === edge.from);
              if (!targetNode.eliminated) {
                connectedNodes.push({ id: edge.from, G: edge.G });
              }
            }
          });
          // ì—°ê²°ëœ ë…¸ë“œë“¤ ì‚¬ì´ì— ë“±ê°€ ì»¨ë•í„´ìŠ¤ ìƒì„± (íšŒë¡œ ì´ë¡ )
          for (let i = 0; i < connectedNodes.length; i++) {
            for (let j = i + 1; j < connectedNodes.length; j++) {
              const n1 = connectedNodes[i];
              const n2 = connectedNodes[j];
              // ë“±ê°€ ì»¨ë•í„´ìŠ¤ ê³„ì‚° (ì§ë ¬ ì—°ê²°ëœ ì €í•­ì˜ ë³‘ë ¬ ì¡°í•©)
              const G_total = connectedNodes.reduce((sum, n) => sum + n.G, 0);
              const G_equiv = (n1.G * n2.G) / G_total;
              // ìƒˆë¡œìš´ ë“±ê°€ ì—£ì§€ ì¶”ê°€
              const existingEdge = this.edges.find(
                (e) =>
                  (e.from === n1.id && e.to === n2.id) ||
                  (e.from === n2.id && e.to === n1.id)
              );
              if (existingEdge) {
                existingEdge.G += G_equiv;
              } else {
                this.edges.push({
                  from: Math.min(n1.id, n2.id),
                  to: Math.max(n1.id, n2.id),
                  G: G_equiv,
                  original: false,
                  equivalent: true,
                });
              }
            }
          }
          // ì†Œê±°ëœ ë…¸ë“œì™€ ì—°ê²°ëœ ì—£ì§€ ì œê±°
          this.edges = this.edges.filter(
            (edge) => edge.from !== node.id && edge.to !== node.id
          );
          this.calculateMatrix();
        }
        nextStep() {
          if (this.step >= this.nodes.length) {
            alert("ëª¨ë“  ë…¸ë“œê°€ ì†Œê±°ë˜ì—ˆìŠµë‹ˆë‹¤!");
            return;
          }
          this.eliminateNode(this.step);
          this.step++;
          this.updateStepInfo();
          this.draw();
        }
        autoPlay() {
          if (this.autoPlayInterval) {
            clearInterval(this.autoPlayInterval);
            this.autoPlayInterval = null;
            return;
          }
          this.autoPlayInterval = setInterval(() => {
            if (this.step >= this.nodes.length) {
              clearInterval(this.autoPlayInterval);
              this.autoPlayInterval = null;
              return;
            }
            this.nextStep();
          }, 2000);
        }
        reset() {
          if (this.autoPlayInterval) {
            clearInterval(this.autoPlayInterval);
            this.autoPlayInterval = null;
          }
          this.step = 0;
          this.nodes = [];
          this.edges = [];
          this.currents = [];
          this.G = [];
          this.updateStepInfo();
        }
        updateStepInfo() {
          const stepInfo = document.getElementById("stepInfo");
          if (this.step === 0) {
            stepInfo.textContent = `ì´ˆê¸° ìƒíƒœ: ${this.nodes.length}ê°œ ë…¸ë“œ íšŒë¡œë§`;
          } else if (this.step < this.nodes.length) {
            stepInfo.textContent = `Step ${this.step}: Node ${
              this.step
            } ì†Œê±° ì™„ë£Œ (${this.nodes.length - this.step}ê°œ ë…¸
ë“œ ë‚¨ìŒ)`;
          } else {
            stepInfo.textContent = `ì™„ë£Œ: ëª¨ë“  ë…¸ë“œ ì†Œê±°ë¨`;
          }
          // ì„¤ëª… ì—…ë°ì´íŠ¸
          const explanationText = document.getElementById("explanationText");
          if (this.step === 0) {
            explanationText.innerHTML = `
<strong>ì´ˆê¸° ìƒíƒœ:</strong> Gv = i ë°©ì •ì‹ì„ ì„¤ì •í–ˆìŠµë‹ˆë‹¤.
ê° ë…¸ë“œë¥¼ ì†Œê±°í•˜ë©´ ê°€ìš°ìŠ¤ ì†Œê±°ë²•ì˜ ì „ë°© ì†Œê±° ê³¼ì •ì´
íšŒë¡œì˜ ë“±ê°€ ë³€í™˜ê³¼ ì¼ì¹˜í•¨ì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
`;
          } else if (this.step <= this.nodes.length) {
            const eliminatedNode = this.nodes[this.step - 1];
            explanationText.innerHTML = `
<strong>Node ${this.step} ì†Œê±°:</strong><br>
â€¢ <strong>ìˆ˜í•™ì :</strong> í–‰ë ¬ Gì˜ ${this.step}í–‰ì„ ì†Œê±°í•˜ì—¬ ë‚˜ë¨¸ì§€ í–‰ë“¤ì„ ì—…ë°ì´íŠ¸<br>
â€¢ <strong>íšŒë¡œì :</strong> Node ${this.step}ì„ ì œê±°í•˜ê³ , ì¸ì ‘ ë…¸ë“œë“¤ ì‚¬ì´ì—
í…Œë¸Œë‚œ/ë…¸í„´ ë“±ê°€ íšŒë¡œ ìƒì„±<br>
â€¢ <strong>ê²°ê³¼:</strong> ë‘ ì ‘ê·¼ë²•ì˜ ìˆ˜ì‹ì´ ì •í™•íˆ ì¼ì¹˜ (Woodbury identity)
`;
          }
        }
        updateDisplay() {
          // í–‰ë ¬ G í‘œì‹œ
          let html = "<table><tr><th></th>";
          for (let i = 0; i < this.nodes.length; i++) {
            html += `<th>N${i + 1}</th>`;
          }
          html += "</tr>";
          for (let i = 0; i < this.nodes.length; i++) {
            html += `<tr><th>N${i + 1}</th>`;
            for (let j = 0; j < this.nodes.length; j++) {
              const value = this.G[i][j].toFixed(2);
              const isEliminated =
                this.nodes[i].eliminated || this.nodes[j].eliminated;
              const className = isEliminated ? "eliminated" : "";
              html += `<td class="${className}">${value}</td>`;
            }
            html += "</tr>";
          }
          html += "</table>";
          document.getElementById("matrixG").innerHTML = html;
          // ì „ë¥˜ ë²¡í„° í‘œì‹œ
          html = "<table><tr><th></th><th>i</th></tr>";
          for (let i = 0; i < this.nodes.length; i++) {
            const className = this.nodes[i].eliminated ? "eliminated" : "";
            html += `<tr><th>N${
              i + 1
            }</th><td class="${className}">${this.currents[i].toFixed(
              1
            )}</td></tr>`;
          }
          html += "</table>";
          document.getElementById("vectorI").innerHTML = html;
          // íšŒë¡œ ì •ë³´ í‘œì‹œ
          const activeNodes = this.nodes.filter((n) => !n.eliminated).length;
          const activeEdges = this.edges.length;
          const equivalentEdges = this.edges.filter((e) => e.equivalent).length;
          document.getElementById("circuitDetails").innerHTML = `
<li>âœ“ í™œì„± ë…¸ë“œ: ${activeNodes}ê°œ</li>
<li>âœ“ ì´ ì—°ê²°: ${activeEdges}ê°œ</li>
<li>âœ“ ë“±ê°€ ì—°ê²°: ${equivalentEdges}ê°œ</li>
<li>âœ“ ì†Œê±°ëœ ë…¸ë“œ: ${this.step}ê°œ</li>
`;
        }
        draw() {
          const ctx = this.ctx;
          ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          // ì—£ì§€ ê·¸ë¦¬ê¸°
          this.edges.forEach((edge) => {
            const fromNode = this.nodes.find((n) => n.id === edge.from);
            const toNode = this.nodes.find((n) => n.id === edge.to);
            if (!fromNode || !toNode) return;
            ctx.beginPath();
            ctx.moveTo(fromNode.x, fromNode.y);
            ctx.lineTo(toNode.x, toNode.y);
            if (edge.equivalent) {
              ctx.strokeStyle = "#FFC107";
              ctx.lineWidth = 3;
              ctx.setLineDash([5, 5]);
            } else {
              ctx.strokeStyle = "#2196F3";
              ctx.lineWidth = 2;
              ctx.setLineDash([]);
            }
            ctx.stroke();
            // ì»¨ë•í„´ìŠ¤ ê°’ í‘œì‹œ
            const midX = (fromNode.x + toNode.x) / 2;
            const midY = (fromNode.y + toNode.y) / 2;
            ctx.fillStyle = edge.equivalent ? "#F57C00" : "#1976D2";
            ctx.font = "bold 12px Arial";
            ctx.fillText(`G=${edge.G.toFixed(2)}`, midX + 5, midY - 5);
          });
          // ë…¸ë“œ ê·¸ë¦¬ê¸°
          this.nodes.forEach((node, index) => {
            ctx.beginPath();
            ctx.arc(node.x, node.y, 25, 0, Math.PI * 2);
            if (node.eliminated) {
              ctx.fillStyle = "#f44336";
            } else {
              ctx.fillStyle = "#4CAF50";
            }
            ctx.fill();
            ctx.strokeStyle = "#333";
            ctx.lineWidth = 3;
            ctx.stroke();
            // ë…¸ë“œ ë ˆì´ë¸”
            ctx.fillStyle = "white";
            ctx.font = "bold 14px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(node.label, node.x, node.y);
            // ì „ë¥˜ì› í‘œì‹œ
            if (this.currents[index] !== 0) {
              ctx.fillStyle = node.eliminated ? "#999" : "#333";
              ctx.font = "12px Arial";
              ctx.fillText(`i=${this.currents[index]}A`, node.x, node.y + 45);
            }
          });
          ctx.setLineDash([]);
        }
      }
      // ì‹œë®¬ë ˆì´í„° ì´ˆê¸°í™”
      const sim = new CircuitSimulator();
    </script>
  </body>
</html>
