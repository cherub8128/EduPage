<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Molniya ê¶¤ë„ ë¶„ì„</title>
  <link rel="canonical" href="https://jinjw27.github.io/Webpage/molniya.html" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #fff;
      padding: 20px;
      min-height: 100vh;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    h1 {
      text-align: center;
      margin-bottom: 10px;
      font-size: 2.5em;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    .subtitle {
      text-align: center;
      margin-bottom: 30px;
      color: #aaa;
      font-size: 1.1em;
    }

    .panels {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
      margin-bottom: 30px;
    }

    .panel {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 15px;
      padding: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .panel h2 {
      margin-bottom: 15px;
      color: #4fc3f7;
      font-size: 1.5em;
    }

    canvas {
      width: 100%;
      border-radius: 10px;
      background: rgba(0, 0, 0, 0.3);
    }

    .info-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 20px;
    }

    .info-card {
      background: rgba(79, 195, 247, 0.1);
      padding: 15px;
      border-radius: 10px;
      border-left: 4px solid #4fc3f7;
    }

    .info-card h3 {
      font-size: 0.9em;
      color: #aaa;
      margin-bottom: 5px;
    }

    .info-card p {
      font-size: 1.5em;
      font-weight: bold;
      color: #4fc3f7;
    }

    .legend {
      display: flex;
      gap: 20px;
      margin-top: 15px;
      flex-wrap: wrap;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .legend-color {
      width: 20px;
      height: 20px;
      border-radius: 3px;
    }

    .controls {
      display: flex;
      gap: 15px;
      margin-top: 15px;
      flex-wrap: wrap;
    }

    button {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      background: #4fc3f7;
      color: #1a1a2e;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
    }

    button:hover {
      background: #29b6f6;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(79, 195, 247, 0.4);
    }

    .speed-control {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    input[type="range"] {
      width: 150px;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>ğŸ›°ï¸ Molniya ê¶¤ë„ ë¶„ì„</h1>
    <p class="subtitle">ê³ íƒ€ì› í†µì‹  ê¶¤ë„ì˜ ì²´ê³µì‹œê°„ ì‹œê°í™”</p>

    <div class="panels">
      <div class="panel">
        <h2>ê¶¤ë„ ì• ë‹ˆë©”ì´ì…˜</h2>
        <canvas id="orbitCanvas" width="600" height="600"></canvas>
        <div class="legend">
          <div class="legend-item">
            <div class="legend-color" style="background: #ff5252"></div>
            <span>ì„œë¹„ìŠ¤ êµ¬ê°„ (ì›ì§€ì )</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: #2196f3"></div>
            <span>ë¹„í™œì„± êµ¬ê°„</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: #4fc3f7"></div>
            <span>ì§€êµ¬</span>
          </div>
        </div>
        <div class="controls">
          <button id="pauseBtn">ì¼ì‹œì •ì§€</button>
          <button id="resetBtn">ì¬ì‹œì‘</button>
          <div class="speed-control">
            <label>ì†ë„:</label>
            <input type="range" id="speedSlider" min="0.1" max="5" step="0.1" value="1" />
            <span id="speedValue">1.0x</span>
          </div>
        </div>
      </div>

      <div class="panel">
        <h2>ê³ ë„-ì‹œê°„ ê·¸ë˜í”„</h2>
        <canvas id="graphCanvas" width="600" height="600"></canvas>
      </div>
    </div>

    <div class="info-grid">
      <div class="info-card">
        <h3>í˜„ì¬ ê³ ë„</h3>
        <p id="altitude">0 km</p>
      </div>
      <div class="info-card">
        <h3>í˜„ì¬ ì†ë„</h3>
        <p id="velocity">0 km/s</p>
      </div>
      <div class="info-card">
        <h3>ê²½ê³¼ ì‹œê°„</h3>
        <p id="time">0.0 h</p>
      </div>
      <div class="info-card">
        <h3>ì„œë¹„ìŠ¤ ì‹œê°„</h3>
        <p id="serviceTime">0.0 h</p>
      </div>
      <div class="info-card">
        <h3>ê¶¤ë„ ì´ì‹¬ë¥ </h3>
        <p>0.74</p>
      </div>
      <div class="info-card">
        <h3>ê¶¤ë„ ì£¼ê¸°</h3>
        <p>12.0 h</p>
      </div>
    </div>
  </div>

  <script>
    // ê¶¤ë„ íŒŒë¼ë¯¸í„°
    const e = 0.74; // ì´ì‹¬ë¥ 
    const a = 26554; // ë°˜ì¥ì¶• (km)
    const period = 12 * 3600; // ì£¼ê¸° (ì´ˆ)
    const perigeeAlt = 500; // ê·¼ì§€ì  ê³ ë„ (km)
    const apogeeAlt = 39000; // ì›ì§€ì  ê³ ë„ (km)
    const earthRadius = 6371; // ì§€êµ¬ ë°˜ì§€ë¦„ (km)
    const serviceAngleStart = 90; // ì„œë¹„ìŠ¤ êµ¬ê°„ ì‹œì‘ ê°ë„
    const serviceAngleEnd = 270; // ì„œë¹„ìŠ¤ êµ¬ê°„ ì¢…ë£Œ ê°ë„

    // Canvas ì„¤ì •
    const orbitCanvas = document.getElementById("orbitCanvas");
    const orbitCtx = orbitCanvas.getContext("2d");
    const graphCanvas = document.getElementById("graphCanvas");
    const graphCtx = graphCanvas.getContext("2d");

    // ì• ë‹ˆë©”ì´ì…˜ ë³€ìˆ˜
    let time = 0;
    let paused = false;
    let speedMultiplier = 1;
    let serviceTimeAccum = 0;
    const graphData = [];

    // ì¼€í”ŒëŸ¬ ë°©ì •ì‹ì„ í’€ì–´ ì§„ê·¼ì ì´ê° ê³„ì‚°
    function solveKepler(M, e, tolerance = 1e-6) {
      let E = M;
      let delta = 1;
      while (Math.abs(delta) > tolerance) {
        delta = E - e * Math.sin(E) - M;
        E = E - delta / (1 - e * Math.cos(E));
      }
      return E;
    }

    // ì§„ê·¼ì ì´ê°ì—ì„œ ìœ„ì¹˜ì™€ ì†ë„ ê³„ì‚°
    function getOrbitalState(t) {
      const n = (2 * Math.PI) / period; // í‰ê·  ê°ì†ë„
      const M = n * t; // í‰ê· ê·¼ì ì´ê°
      const E = solveKepler(M, e); // ì´ì‹¬ê·¼ì ì´ê°

      // ì§„ê·¼ì ì´ê°
      const nu =
        2 *
        Math.atan2(
          Math.sqrt(1 + e) * Math.sin(E / 2),
          Math.sqrt(1 - e) * Math.cos(E / 2)
        );

      // ê¶¤ë„ìƒ ê±°ë¦¬
      const r = (a * (1 - e * e)) / (1 + e * Math.cos(nu));

      // ê³ ë„
      const altitude = r - earthRadius;

      // ì†ë„ (ë¹„ìŠ¤-ë¹„ë°” ë°©ì •ì‹)
      const mu = 398600; // ì§€êµ¬ ì¤‘ë ¥ íŒŒë¼ë¯¸í„° (km^3/s^2)
      const v = Math.sqrt(mu * (2 / r - 1 / a));

      return {
        angle: nu,
        distance: r,
        altitude: altitude,
        velocity: v,
        x: r * Math.cos(nu),
        y: r * Math.sin(nu),
      };
    }

    // ì„œë¹„ìŠ¤ êµ¬ê°„ ì—¬ë¶€ í™•ì¸
    function isInServiceZone(angle) {
      const deg = ((angle * 180) / Math.PI + 360) % 360;
      return deg >= serviceAngleStart && deg <= serviceAngleEnd;
    }

    // ê¶¤ë„ ê·¸ë¦¬ê¸°
    function drawOrbit() {
      const canvas = orbitCanvas;
      const ctx = orbitCtx;
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const scale = 0.008; // ìŠ¤ì¼€ì¼ ì¡°ì •

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // ë°°ê²½ ê²©ì
      ctx.strokeStyle = "rgba(255, 255, 255, 0.05)";
      ctx.lineWidth = 1;
      for (let i = 0; i < 10; i++) {
        const radius = (i + 1) * 50;
        ctx.beginPath();
        ctx.arc(centerX - a * e * scale, centerY, radius, 0, 2 * Math.PI);
        ctx.stroke();
      }

      // ê¶¤ë„ ê·¸ë¦¬ê¸° (ìƒ‰ìƒ êµ¬ë¶„)
      const steps = 360;
      for (let i = 0; i < steps; i++) {
        const angle = (i / steps) * 2 * Math.PI;
        const r = (a * (1 - e * e)) / (1 + e * Math.cos(angle));
        const x1 = centerX - a * e * scale + r * Math.cos(angle) * scale;
        const y1 = centerY + r * Math.sin(angle) * scale;

        const nextAngle = ((i + 1) / steps) * 2 * Math.PI;
        const r2 = (a * (1 - e * e)) / (1 + e * Math.cos(nextAngle));
        const x2 = centerX - a * e * scale + r2 * Math.cos(nextAngle) * scale;
        const y2 = centerY + r2 * Math.sin(nextAngle) * scale;

        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = isInServiceZone(angle) ? "#ff5252" : "#2196f3";
        ctx.lineWidth = 3;
        ctx.stroke();
      }

      // ì§€êµ¬ ê·¸ë¦¬ê¸°
      ctx.beginPath();
      ctx.arc(
        centerX - a * e * scale,
        centerY,
        earthRadius * scale,
        0,
        2 * Math.PI
      );
      ctx.fillStyle = "#4fc3f7";
      ctx.fill();
      ctx.strokeStyle = "#29b6f6";
      ctx.lineWidth = 2;
      ctx.stroke();

      // ì§€êµ¬ ë¼ë²¨
      ctx.fillStyle = "#fff";
      ctx.font = "bold 14px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("ì§€êµ¬", centerX - a * e * scale, centerY + 5);

      // ìœ„ì„± ê·¸ë¦¬ê¸°
      const state = getOrbitalState(time);
      const satX = centerX - a * e * scale + state.x * scale;
      const satY = centerY + state.y * scale;

      // ìœ„ì„± ê¶¤ì 
      ctx.beginPath();
      ctx.arc(satX, satY, 8, 0, 2 * Math.PI);
      ctx.fillStyle = isInServiceZone(state.angle) ? "#ff5252" : "#fff";
      ctx.fill();
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.stroke();

      // ìœ„ì„± ë¼ë²¨
      ctx.fillStyle = "#fff";
      ctx.font = "bold 12px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("ìœ„ì„±", satX, satY - 15);

      // ê·¼ì§€ì /ì›ì§€ì  í‘œì‹œ
      ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
      ctx.font = "12px sans-serif";
      ctx.textAlign = "right";
      ctx.fillText(
        "ê·¼ì§€ì ",
        centerX - a * e * scale + a * (1 - e) * scale - 10,
        centerY + 5
      );
      ctx.textAlign = "left";
      ctx.fillText(
        "ì›ì§€ì ",
        centerX - a * e * scale - a * (1 + e) * scale + 10,
        centerY + 5
      );
    }

    // ê·¸ë˜í”„ ê·¸ë¦¬ê¸°
    function drawGraph() {
      const canvas = graphCanvas;
      const ctx = graphCtx;
      const padding = 60;
      const graphWidth = canvas.width - 2 * padding;
      const graphHeight = canvas.height - 2 * padding;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // ì¶• ê·¸ë¦¬ê¸°
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, canvas.height - padding);
      ctx.lineTo(canvas.width - padding, canvas.height - padding);
      ctx.stroke();

      // ì¶• ë¼ë²¨
      ctx.fillStyle = "#fff";
      ctx.font = "bold 14px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("ì‹œê°„ (hours)", canvas.width / 2, canvas.height - 20);
      ctx.save();
      ctx.translate(20, canvas.height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText("ê³ ë„ (km)", 0, 0);
      ctx.restore();

      // ê²©ìì„ 
      ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
      ctx.lineWidth = 1;
      for (let i = 0; i <= 10; i++) {
        const y = padding + (graphHeight / 10) * i;
        ctx.beginPath();
        ctx.moveTo(padding, y);
        ctx.lineTo(canvas.width - padding, y);
        ctx.stroke();

        const altitude = apogeeAlt - (apogeeAlt - perigeeAlt) * (i / 10);
        ctx.fillStyle = "#aaa";
        ctx.font = "10px sans-serif";
        ctx.textAlign = "right";
        ctx.fillText(altitude.toFixed(0), padding - 10, y + 4);
      }

      for (let i = 0; i <= 12; i++) {
        const x = padding + (graphWidth / 12) * i;
        ctx.beginPath();
        ctx.moveTo(x, padding);
        ctx.lineTo(x, canvas.height - padding);
        ctx.stroke();

        ctx.fillStyle = "#aaa";
        ctx.font = "10px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(i.toString(), x, canvas.height - padding + 20);
      }

      // ë°ì´í„° ê·¸ë¦¬ê¸°
      if (graphData.length > 1) {
        ctx.strokeStyle = "#4fc3f7";
        ctx.lineWidth = 3;
        ctx.beginPath();
        for (let i = 0; i < graphData.length; i++) {
          const point = graphData[i];
          const x = padding + (point.time / period) * graphWidth;
          const y =
            canvas.height -
            padding -
            ((point.altitude - perigeeAlt) / (apogeeAlt - perigeeAlt)) *
            graphHeight;

          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.stroke();

        // ì„œë¹„ìŠ¤ êµ¬ê°„ ê°•ì¡°
        ctx.fillStyle = "rgba(255, 82, 82, 0.1)";
        for (let i = 0; i < graphData.length - 1; i++) {
          const point = graphData[i];
          if (point.inService) {
            const x1 = padding + (point.time / period) * graphWidth;
            const y1 =
              canvas.height -
              padding -
              ((point.altitude - perigeeAlt) / (apogeeAlt - perigeeAlt)) *
              graphHeight;
            const point2 = graphData[i + 1];
            const x2 = padding + (point2.time / period) * graphWidth;
            const y2 =
              canvas.height -
              padding -
              ((point2.altitude - perigeeAlt) / (apogeeAlt - perigeeAlt)) *
              graphHeight;

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.lineTo(x2, canvas.height - padding);
            ctx.lineTo(x1, canvas.height - padding);
            ctx.closePath();
            ctx.fill();
          }
        }
      }
    }

    // ì •ë³´ ì—…ë°ì´íŠ¸
    function updateInfo() {
      const state = getOrbitalState(time);
      document.getElementById("altitude").textContent =
        state.altitude.toFixed(0) + " km";
      document.getElementById("velocity").textContent =
        state.velocity.toFixed(2) + " km/s";
      document.getElementById("time").textContent =
        (time / 3600).toFixed(2) + " h";
      document.getElementById("serviceTime").textContent =
        (serviceTimeAccum / 3600).toFixed(2) + " h";
    }

    // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
    function animate() {
      if (!paused) {
        time += 30 * speedMultiplier; // 30ì´ˆì”© ì¦ê°€

        if (time >= period) {
          time = 0;
          serviceTimeAccum = 0;
          graphData.length = 0;
        }

        const state = getOrbitalState(time);
        const inService = isInServiceZone(state.angle);

        if (inService) {
          serviceTimeAccum += 30 * speedMultiplier;
        }

        graphData.push({
          time: time,
          altitude: state.altitude,
          inService: inService,
        });

        if (graphData.length > 500) {
          graphData.shift();
        }
      }

      drawOrbit();
      drawGraph();
      updateInfo();

      requestAnimationFrame(animate);
    }

    // ì»¨íŠ¸ë¡¤
    document
      .getElementById("pauseBtn")
      .addEventListener("click", function () {
        paused = !paused;
        this.textContent = paused ? "ì¬ìƒ" : "ì¼ì‹œì •ì§€";
      });

    document
      .getElementById("resetBtn")
      .addEventListener("click", function () {
        time = 0;
        serviceTimeAccum = 0;
        graphData.length = 0;
        paused = false;
        document.getElementById("pauseBtn").textContent = "ì¼ì‹œì •ì§€";
      });

    document
      .getElementById("speedSlider")
      .addEventListener("input", function () {
        speedMultiplier = parseFloat(this.value);
        document.getElementById("speedValue").textContent =
          speedMultiplier.toFixed(1) + "x";
      });

    // ì‹œì‘
    animate();
  </script>
</body>

</html>