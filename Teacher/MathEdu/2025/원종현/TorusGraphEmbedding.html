<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÌÜ†Îü¨Ïä§ Í∑∏ÎûòÌîÑ ÏûÑÎ≤†Îî© Ïã¨Ìôî ÏãúÎÆ¨Î†àÏù¥ÏÖò</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;700&family=Fira+Code&display=swap');
        
        :root {
            --primary: #6366f1;
            --secondary: #8b5cf6;
            --accent: #ec4899;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --dark: #1e293b;
            --light: #f1f5f9;
            --border: #e2e8f0;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Noto Sans KR', sans-serif;
            min-height: 100vh;
            padding: 20px;
            color: var(--dark);
            overflow-x: hidden;
            position: relative;
        }
        
        /* Animated Background */
        .animated-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
        }
        
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        /* Particle Canvas */
        #particle-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
        }
        
        /* Geometric Pattern Overlay */
        .geometric-pattern {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.1;
            background-image: 
                repeating-linear-gradient(45deg, transparent, transparent 35px, rgba(255,255,255,.1) 35px, rgba(255,255,255,.1) 70px),
                repeating-linear-gradient(-45deg, transparent, transparent 35px, rgba(255,255,255,.1) 35px, rgba(255,255,255,.1) 70px);
        }
        
        /* Floating Shapes */
        .floating-shapes {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            overflow: hidden;
            pointer-events: none;
        }
        
        .shape {
            position: absolute;
            opacity: 0.15;
            animation: float 20s infinite ease-in-out;
        }
        
        .shape.circle {
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.8), transparent);
        }
        
        .shape.square {
            background: linear-gradient(45deg, rgba(255,255,255,0.6), transparent);
            transform: rotate(45deg);
        }
        
        .shape.triangle {
            width: 0;
            height: 0;
            background: transparent;
            border-left: 50px solid transparent;
            border-right: 50px solid transparent;
            border-bottom: 86px solid rgba(255,255,255,0.5);
        }
        
        .shape:nth-child(1) {
            width: 150px;
            height: 150px;
            top: 10%;
            left: 10%;
            animation-delay: 0s;
            animation-duration: 25s;
        }
        
        .shape:nth-child(2) {
            width: 100px;
            height: 100px;
            top: 60%;
            left: 80%;
            animation-delay: -5s;
            animation-duration: 20s;
        }
        
        .shape:nth-child(3) {
            width: 200px;
            height: 200px;
            top: 30%;
            left: 70%;
            animation-delay: -10s;
            animation-duration: 30s;
        }
        
        .shape:nth-child(4) {
            top: 70%;
            left: 20%;
            animation-delay: -7s;
            animation-duration: 22s;
        }
        
        .shape:nth-child(5) {
            width: 120px;
            height: 120px;
            top: 50%;
            left: 50%;
            animation-delay: -12s;
            animation-duration: 28s;
        }
        
        .shape:nth-child(6) {
            width: 80px;
            height: 80px;
            top: 20%;
            left: 40%;
            animation-delay: -3s;
            animation-duration: 18s;
        }
        
        @keyframes float {
            0%, 100% {
                transform: translateY(0) rotate(0deg) scale(1);
                opacity: 0.15;
            }
            25% {
                transform: translateY(-30px) rotate(90deg) scale(1.1);
                opacity: 0.25;
            }
            50% {
                transform: translateY(-50px) rotate(180deg) scale(0.9);
                opacity: 0.2;
            }
            75% {
                transform: translateY(-30px) rotate(270deg) scale(1.05);
                opacity: 0.18;
            }
        }
        
        /* Glowing Orbs */
        .glowing-orbs {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
        }
        
        .orb {
            position: absolute;
            border-radius: 50%;
            filter: blur(60px);
            animation: orbFloat 15s infinite ease-in-out;
        }
        
        .orb1 {
            width: 400px;
            height: 400px;
            background: radial-gradient(circle, rgba(139, 92, 246, 0.4), transparent);
            top: -100px;
            left: -100px;
            animation-delay: 0s;
        }
        
        .orb2 {
            width: 350px;
            height: 350px;
            background: radial-gradient(circle, rgba(236, 72, 153, 0.3), transparent);
            bottom: -100px;
            right: -100px;
            animation-delay: -5s;
        }
        
        .orb3 {
            width: 300px;
            height: 300px;
            background: radial-gradient(circle, rgba(99, 102, 241, 0.35), transparent);
            top: 50%;
            left: 50%;
            animation-delay: -10s;
        }
        
        @keyframes orbFloat {
            0%, 100% {
                transform: translate(0, 0) scale(1);
            }
            33% {
                transform: translate(50px, -50px) scale(1.1);
            }
            66% {
                transform: translate(-50px, 50px) scale(0.9);
            }
        }
        
        /* Main Container with Glassmorphism */
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 30px;
            box-shadow: 
                0 8px 32px 0 rgba(31, 38, 135, 0.37),
                0 0 0 1px rgba(255, 255, 255, 0.18),
                inset 0 0 100px rgba(255, 255, 255, 0.1);
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.3);
            position: relative;
        }
        
        .container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, 
                transparent,
                rgba(99, 102, 241, 0.8),
                rgba(139, 92, 246, 0.8),
                rgba(236, 72, 153, 0.8),
                transparent
            );
            animation: shimmer 3s infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        /* Header with enhanced gradient */
        header {
            background: linear-gradient(135deg, 
                rgba(99, 102, 241, 0.95) 0%, 
                rgba(139, 92, 246, 0.95) 50%,
                rgba(236, 72, 153, 0.95) 100%
            );
            color: white;
            padding: 50px 40px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 10px,
                rgba(255, 255, 255, 0.03) 10px,
                rgba(255, 255, 255, 0.03) 20px
            );
            animation: headerPattern 20s linear infinite;
        }
        
        @keyframes headerPattern {
            0% { transform: translate(0, 0); }
            100% { transform: translate(40px, 40px); }
        }
        
        header h1 {
            font-size: 2.8em;
            font-weight: 700;
            margin-bottom: 15px;
            text-shadow: 
                2px 2px 4px rgba(0,0,0,0.3),
                0 0 20px rgba(255,255,255,0.3);
            position: relative;
            z-index: 1;
            animation: titleGlow 2s ease-in-out infinite alternate;
        }
        
        @keyframes titleGlow {
            from {
                text-shadow: 
                    2px 2px 4px rgba(0,0,0,0.3),
                    0 0 20px rgba(255,255,255,0.3);
            }
            to {
                text-shadow: 
                    2px 2px 4px rgba(0,0,0,0.3),
                    0 0 30px rgba(255,255,255,0.5),
                    0 0 40px rgba(255,255,255,0.3);
            }
        }
        
        header p {
            font-size: 1.2em;
            opacity: 0.95;
            position: relative;
            z-index: 1;
            font-weight: 300;
            letter-spacing: 1px;
        }
        
        /* Main Content */
        .content {
            padding: 40px;
            position: relative;
        }
        
        /* Control Panel with glassmorphism */
        .control-panel {
            background: rgba(241, 245, 249, 0.6);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 35px;
            margin-bottom: 35px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            box-shadow: 
                0 4px 20px rgba(0, 0, 0, 0.1),
                inset 0 0 50px rgba(255, 255, 255, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        .control-panel::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, 
                rgba(99, 102, 241, 0.2),
                rgba(139, 92, 246, 0.2),
                rgba(236, 72, 153, 0.2)
            );
            border-radius: 20px;
            z-index: -1;
            filter: blur(10px);
        }
        
        .control-section {
            margin-bottom: 30px;
        }
        
        .control-section h3 {
            color: var(--primary);
            margin-bottom: 18px;
            font-size: 1.3em;
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 700;
        }
        
        .control-section h3::before {
            content: '‚ñ∂';
            color: var(--accent);
            font-size: 0.8em;
            animation: pulseArrow 1.5s ease-in-out infinite;
        }
        
        @keyframes pulseArrow {
            0%, 100% { transform: translateX(0); }
            50% { transform: translateX(5px); }
        }
        
        .button-group {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 14px 28px;
            border: none;
            border-radius: 12px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            font-family: 'Noto Sans KR', sans-serif;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.6);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        
        button:hover::before {
            width: 400px;
            height: 400px;
        }
        
        button:active {
            transform: scale(0.95);
        }
        
        button span {
            position: relative;
            z-index: 1;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(99, 102, 241, 0.5);
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, var(--accent), #f472b6);
            color: white;
        }
        
        .btn-secondary:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(236, 72, 153, 0.5);
        }
        
        .btn-success {
            background: linear-gradient(135deg, var(--success), #34d399);
            color: white;
        }
        
        .btn-success:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(16, 185, 129, 0.5);
        }
        
        button.active {
            background: linear-gradient(135deg, var(--dark), #334155);
            color: white;
            box-shadow: 0 0 0 3px var(--accent), 0 8px 20px rgba(0, 0, 0, 0.3);
            transform: translateY(-2px);
        }
        
        /* Canvas Container */
        .canvas-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 35px;
            margin-bottom: 35px;
        }
        
        .canvas-wrapper {
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.1),
                inset 0 0 50px rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
        }
        
        .canvas-wrapper::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.3), 
                transparent
            );
            transition: left 0.5s;
        }
        
        .canvas-wrapper:hover::before {
            left: 100%;
        }
        
        .canvas-wrapper:hover {
            box-shadow: 
                0 12px 40px rgba(99, 102, 241, 0.2),
                inset 0 0 50px rgba(255, 255, 255, 0.4);
            transform: translateY(-8px) scale(1.02);
        }
        
        .canvas-wrapper h3 {
            color: var(--dark);
            margin-bottom: 20px;
            font-size: 1.4em;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            font-weight: 700;
        }
        
        canvas {
            display: block;
            width: 100%;
            border-radius: 15px;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            border: 2px solid rgba(99, 102, 241, 0.1);
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.05);
        }
        
        /* Info Panels */
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 25px;
            margin-bottom: 35px;
        }
        
        .info-panel {
            background: linear-gradient(135deg, 
                rgba(240, 249, 255, 0.8) 0%, 
                rgba(224, 242, 254, 0.8) 100%
            );
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            border: 2px solid rgba(186, 230, 253, 0.5);
            box-shadow: 
                0 8px 32px rgba(14, 165, 233, 0.15),
                inset 0 0 50px rgba(255, 255, 255, 0.3);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
        }
        
        .info-panel::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(99, 102, 241, 0.1) 0%, transparent 70%);
            animation: rotateBg 10s linear infinite;
        }
        
        @keyframes rotateBg {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .info-panel:hover {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 
                0 12px 40px rgba(14, 165, 233, 0.3),
                inset 0 0 50px rgba(255, 255, 255, 0.4);
        }
        
        .info-panel h3 {
            color: #0369a1;
            margin-bottom: 20px;
            font-size: 1.3em;
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 700;
            position: relative;
            z-index: 1;
        }
        
        .info-value {
            font-size: 2.8em;
            font-weight: 700;
            color: var(--primary);
            text-align: center;
            margin: 20px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
            position: relative;
            z-index: 1;
        }
        
        .euler-formula {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(5px);
            border-radius: 15px;
            padding: 25px;
            font-family: 'Fira Code', monospace;
            font-size: 1.4em;
            text-align: center;
            margin-top: 20px;
            border: 2px solid var(--primary);
            box-shadow: 
                0 6px 20px rgba(99, 102, 241, 0.25),
                inset 0 0 20px rgba(99, 102, 241, 0.05);
            position: relative;
            z-index: 1;
        }
        
        .euler-result {
            font-size: 1.6em;
            font-weight: 700;
            margin-top: 15px;
        }
        
        .euler-result.valid {
            color: var(--success);
            animation: successPulse 2s ease-in-out infinite;
        }
        
        @keyframes successPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }
        
        .euler-result.invalid {
            color: var(--danger);
        }
        
        /* Theory Section */
        .theory-section {
            background: linear-gradient(135deg, 
                rgba(254, 243, 199, 0.8) 0%, 
                rgba(253, 230, 138, 0.8) 100%
            );
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 35px;
            margin-bottom: 35px;
            border: 2px solid rgba(251, 191, 36, 0.3);
            box-shadow: 
                0 8px 32px rgba(245, 158, 11, 0.2),
                inset 0 0 50px rgba(255, 255, 255, 0.3);
            position: relative;
        }
        
        .theory-section h3 {
            color: #92400e;
            margin-bottom: 25px;
            font-size: 1.5em;
            font-weight: 700;
        }
        
        .theory-item {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(5px);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 18px;
            border-left: 5px solid var(--warning);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
            transition: all 0.3s ease;
        }
        
        .theory-item:hover {
            transform: translateX(5px);
            box-shadow: 0 6px 20px rgba(245, 158, 11, 0.2);
        }
        
        .theory-item strong {
            color: var(--primary);
        }
        
        .formula-display {
            background: var(--dark);
            color: #fff;
            padding: 18px;
            border-radius: 10px;
            font-family: 'Fira Code', monospace;
            margin: 12px 0;
            overflow-x: auto;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        /* Statistics */
        .stats-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 18px;
            margin-top: 25px;
            position: relative;
            z-index: 1;
        }
        
        .stat-card {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(5px);
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            border: 2px solid rgba(99, 102, 241, 0.1);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .stat-card:hover {
            border-color: var(--primary);
            box-shadow: 0 8px 25px rgba(99, 102, 241, 0.3);
            transform: translateY(-5px) scale(1.05);
        }
        
        .stat-label {
            font-size: 0.95em;
            color: #64748b;
            margin-bottom: 10px;
            font-weight: 500;
        }
        
        .stat-value {
            font-size: 2.2em;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        /* Toggle Switch */
        .toggle-container {
            display: flex;
            align-items: center;
            gap: 18px;
            margin: 18px 0;
        }
        
        .toggle-switch {
            position: relative;
            width: 65px;
            height: 32px;
            background: #cbd5e1;
            border-radius: 16px;
            cursor: pointer;
            transition: background 0.3s;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        .toggle-switch.active {
            background: linear-gradient(135deg, var(--success), #34d399);
        }
        
        .toggle-slider {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 26px;
            height: 26px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        .toggle-switch.active .toggle-slider {
            transform: translateX(33px);
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .canvas-grid {
                grid-template-columns: 1fr;
            }
            
            header h1 {
                font-size: 2em;
            }
            
            .button-group {
                flex-direction: column;
            }
            
            button {
                width: 100%;
            }
            
            .shape {
                display: none;
            }
        }
        
        /* Loading Animation */
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(0.98); }
        }
        
        .animating {
            animation: pulse 1.5s ease-in-out infinite;
        }
    </style>
</head>
<body>
    <!-- Animated Background Layers -->
    <div class="animated-background"></div>
    <canvas id="particle-canvas"></canvas>
    <div class="geometric-pattern"></div>
    
    <!-- Glowing Orbs -->
    <div class="glowing-orbs">
        <div class="orb orb1"></div>
        <div class="orb orb2"></div>
        <div class="orb orb3"></div>
    </div>
    
    <!-- Floating Shapes -->
    <div class="floating-shapes">
        <div class="shape circle"></div>
        <div class="shape square"></div>
        <div class="shape circle"></div>
        <div class="shape triangle"></div>
        <div class="shape square"></div>
        <div class="shape circle"></div>
    </div>
    
    <div class="container">
        <header>
            <h1>üç© ÌÜ†Îü¨Ïä§ ÏúÑ Í∑∏ÎûòÌîÑ ÏûÑÎ≤†Îî© Ïã¨Ìôî ÏãúÎÆ¨Î†àÏù¥ÏÖò</h1>
            <p>Topological Graph Theory & Euler Characteristic Explorer</p>
        </header>
        
        <div class="content">
            <!-- Control Panel -->
            <div class="control-panel">
                <div class="control-section">
                    <h3>Í∑∏ÎûòÌîÑ ÏÑ†ÌÉù</h3>
                    <div class="button-group">
                        <button class="btn-primary active" onclick="selectGraph('K5')" id="btn-K5">
                            <span>K‚ÇÖ (ÏôÑÏ†ÑÍ∑∏ÎûòÌîÑ)</span>
                        </button>
                        <button class="btn-primary" onclick="selectGraph('K33')" id="btn-K33">
                            <span>K‚ÇÉ,‚ÇÉ (ÏôÑÏ†ÑÏù¥Î∂Ñ)</span>
                        </button>
                        <button class="btn-primary" onclick="selectGraph('K7')" id="btn-K7">
                            <span>K‚Çá</span>
                        </button>
                        <button class="btn-primary" onclick="selectGraph('Petersen')" id="btn-Petersen">
                            <span>ÌîºÌÑ∞Ïä® Í∑∏ÎûòÌîÑ</span>
                        </button>
                    </div>
                </div>
                
                <div class="control-section">
                    <h3>ÏãúÍ∞ÅÌôî ÏòµÏÖò</h3>
                    <div class="button-group">
                        <button class="btn-secondary" onclick="toggleFaceHighlight()">
                            <span>Î©¥ ÌïòÏù¥ÎùºÏù¥Ìä∏</span>
                        </button>
                        <button class="btn-secondary" onclick="toggleEdgeLabels()">
                            <span>Í∞ÑÏÑ† Î†àÏù¥Î∏î</span>
                        </button>
                        <button class="btn-secondary" onclick="animateRotation()">
                            <span>3D ÌöåÏ†Ñ ÏãúÏûë/Ï†ïÏßÄ</span>
                        </button>
                        <button class="btn-success" onclick="resetView()">
                            <span>Ï¥àÍ∏∞Ìôî</span>
                        </button>
                    </div>
                </div>
                
                <div class="control-section">
                    <h3>ÍµêÏ∞®Ïàò Î∂ÑÏÑù</h3>
                    <div class="toggle-container">
                        <span>ÌèâÎ©¥ ÍµêÏ∞® ÌëúÏãú:</span>
                        <div class="toggle-switch" onclick="toggleCrossings(this)" id="crossing-toggle">
                            <div class="toggle-slider"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Canvas Grid -->
            <div class="canvas-grid">
                <div class="canvas-wrapper">
                    <h3>üìê ÌÜ†Îü¨Ïä§ Ï†ÑÍ∞úÎèÑ (Planar Development)</h3>
                    <canvas id="planarCanvas" width="600" height="600"></canvas>
                </div>
                <div class="canvas-wrapper">
                    <h3>üåê 3D ÌÜ†Îü¨Ïä§ Î∑∞ (Torus View)</h3>
                    <canvas id="torusCanvas" width="600" height="600"></canvas>
                </div>
            </div>
            
            <!-- Info Grid -->
            <div class="info-grid">
                <div class="info-panel">
                    <h3>üìä Í∑∏ÎûòÌîÑ Ï†ïÎ≥¥</h3>
                    <div class="stats-container">
                        <div class="stat-card">
                            <div class="stat-label">Íº≠ÏßìÏ†ê (V)</div>
                            <div class="stat-value" id="stat-v">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Í∞ÑÏÑ† (E)</div>
                            <div class="stat-value" id="stat-e">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Î©¥ (F)</div>
                            <div class="stat-value" id="stat-f">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Ï¢ÖÏàò (g)</div>
                            <div class="stat-value" id="stat-g">0</div>
                        </div>
                    </div>
                </div>
                
                <div class="info-panel">
                    <h3>üßÆ Ïò§ÏùºÎü¨ ÌäπÏÑ±Ïàò Í≤ÄÏ¶ù</h3>
                    <div class="euler-formula">
                        <div>V - E + F = œá</div>
                        <div id="euler-calc">0 - 0 + 0 = 0</div>
                        <div class="euler-result valid" id="euler-result">‚úì ÌÜ†Îü¨Ïä§ Ï°∞Í±¥ ÎßåÏ°±</div>
                    </div>
                </div>
            </div>
            
            <!-- Theory Section -->
            <div class="theory-section">
                <h3>üìö ÏàòÌïôÏ†Å Î∞∞Í≤Ω Ïù¥Î°†</h3>
                <div class="theory-item">
                    <strong>ÏùºÎ∞òÌôîÎêú Ïò§ÏùºÎü¨ Í≥µÏãù:</strong>
                    <div class="formula-display">œá = V - E + F = 2 - 2g</div>
                    Í∞ÄÌñ• ÌèêÍ≥°Î©¥Ïùò Ï¢ÖÏàò gÏóê Îî∞Î•∏ ÏúÑÏÉÅ Î∂àÎ≥ÄÎüâ
                </div>
                <div class="theory-item">
                    <strong>Ringel-Youngs Ï†ïÎ¶¨ (ÏôÑÏ†ÑÍ∑∏ÎûòÌîÑ Ï¢ÖÏàò):</strong>
                    <div class="formula-display">Œ≥(K‚Çô) = ‚åà(n-3)(n-4)/12‚åâ</div>
                    ÏôÑÏ†ÑÍ∑∏ÎûòÌîÑÍ∞Ä ÏûÑÎ≤†Îî© Í∞ÄÎä•Ìïú ÏµúÏÜå Ï¢ÖÏàò
                </div>
                <div class="theory-item">
                    <strong>ÍµêÏ∞®Ïàò (Crossing Number):</strong>
                    <div class="formula-display" id="crossing-info">cr(K‚ÇÖ) = 1</div>
                    ÌèâÎ©¥Ïóê Í∑∏Î¶¥ Îïå ÌïÑÏöîÌïú ÏµúÏÜå ÍµêÏ∞® Í∞úÏàò
                </div>
            </div>
        </div>
    </div>

    <script>
        // Particle Animation
        const particleCanvas = document.getElementById('particle-canvas');
        const particleCtx = particleCanvas.getContext('2d');
        particleCanvas.width = window.innerWidth;
        particleCanvas.height = window.innerHeight;
        
        const particles = [];
        const particleCount = 80;
        
        class Particle {
            constructor() {
                this.x = Math.random() * particleCanvas.width;
                this.y = Math.random() * particleCanvas.height;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.radius = Math.random() * 2 + 1;
                this.opacity = Math.random() * 0.5 + 0.2;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                
                if (this.x < 0 || this.x > particleCanvas.width) this.vx *= -1;
                if (this.y < 0 || this.y > particleCanvas.height) this.vy *= -1;
            }
            
            draw() {
                particleCtx.beginPath();
                particleCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                particleCtx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
                particleCtx.fill();
            }
        }
        
        for (let i = 0; i < particleCount; i++) {
            particles.push(new Particle());
        }
        
        function animateParticles() {
            particleCtx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);
            
            particles.forEach(particle => {
                particle.update();
                particle.draw();
            });
            
            // Draw connections
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const dx = particles[i].x - particles[j].x;
                    const dy = particles[i].y - particles[j].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 150) {
                        particleCtx.beginPath();
                        particleCtx.strokeStyle = `rgba(255, 255, 255, ${0.15 * (1 - distance / 150)})`;
                        particleCtx.lineWidth = 1;
                        particleCtx.moveTo(particles[i].x, particles[i].y);
                        particleCtx.lineTo(particles[j].x, particles[j].y);
                        particleCtx.stroke();
                    }
                }
            }
            
            requestAnimationFrame(animateParticles);
        }
        
        animateParticles();
        
        window.addEventListener('resize', () => {
            particleCanvas.width = window.innerWidth;
            particleCanvas.height = window.innerHeight;
        });
        
        // Canvas contexts
        const planarCtx = document.getElementById('planarCanvas').getContext('2d');
        const torusCtx = document.getElementById('torusCanvas').getContext('2d');
        
        // State
        let currentGraph = null;
        let currentGraphName = 'K5';
        let showFaceHighlight = false;
        let showEdgeLabels = false;
        let showCrossings = false;
        let isRotating = true;
        let rotationAngle = 0;
        let animationFrame = null;
        
        // Graph definitions
        const graphs = {
            K5: {
                name: 'K‚ÇÖ',
                vertices: [
                    {id: 'v‚ÇÅ', x: 0.5, y: 0.5},
                    {id: 'v‚ÇÇ', x: 0.15, y: 0.15},
                    {id: 'v‚ÇÉ', x: 0.85, y: 0.15},
                    {id: 'v‚ÇÑ', x: 0.85, y: 0.85},
                    {id: 'v‚ÇÖ', x: 0.15, y: 0.85}
                ],
                edges: [
                    [0,1], [0,2], [0,3], [0,4],
                    [1,2], [1,3], [1,4],
                    [2,3], [2,4],
                    [3,4]
                ],
                faces: 5,
                genus: 1,
                crossingNumber: 1,
                faceBoundaries: [
                    [0,1,2], [0,2,3], [0,3,4], [0,4,1], [1,2,3,4]
                ]
            },
            K33: {
                name: 'K‚ÇÉ,‚ÇÉ',
                vertices: [
                    {id: 'u‚ÇÅ', x: 0.15, y: 0.25},
                    {id: 'u‚ÇÇ', x: 0.15, y: 0.5},
                    {id: 'u‚ÇÉ', x: 0.15, y: 0.75},
                    {id: 'v‚ÇÅ', x: 0.85, y: 0.25},
                    {id: 'v‚ÇÇ', x: 0.85, y: 0.5},
                    {id: 'v‚ÇÉ', x: 0.85, y: 0.75}
                ],
                edges: [
                    [0,3], [0,4], [0,5],
                    [1,3], [1,4], [1,5],
                    [2,3], [2,4], [2,5]
                ],
                faces: 3,
                genus: 1,
                crossingNumber: 1,
                faceBoundaries: [
                    [0,3,1,4,2,5], [0,4,1,5,2,3], [0,5,1,3,2,4]
                ]
            },
            K7: {
                name: 'K‚Çá',
                vertices: Array.from({length: 7}, (_, i) => ({
                    id: `v${i+1}`,
                    x: 0.5 + 0.35 * Math.cos(2 * Math.PI * i / 7),
                    y: 0.5 + 0.35 * Math.sin(2 * Math.PI * i / 7)
                })),
                edges: [],
                faces: 14,
                genus: 1,
                crossingNumber: 9,
                faceBoundaries: []
            },
            Petersen: {
                name: 'Petersen',
                vertices: [
                    {id: 'o‚ÇÅ', x: 0.5, y: 0.15},
                    {id: 'o‚ÇÇ', x: 0.8, y: 0.35},
                    {id: 'o‚ÇÉ', x: 0.7, y: 0.75},
                    {id: 'o‚ÇÑ', x: 0.3, y: 0.75},
                    {id: 'o‚ÇÖ', x: 0.2, y: 0.35},
                    {id: 'i‚ÇÅ', x: 0.5, y: 0.4},
                    {id: 'i‚ÇÇ', x: 0.65, y: 0.45},
                    {id: 'i‚ÇÉ', x: 0.6, y: 0.6},
                    {id: 'i‚ÇÑ', x: 0.4, y: 0.6},
                    {id: 'i‚ÇÖ', x: 0.35, y: 0.45}
                ],
                edges: [
                    [0,1], [1,2], [2,3], [3,4], [4,0],
                    [5,7], [7,9], [9,6], [6,8], [8,5],
                    [0,5], [1,6], [2,7], [3,8], [4,9]
                ],
                faces: 6,
                genus: 1,
                crossingNumber: 2,
                faceBoundaries: []
            }
        };
        
        // Generate K7 edges
        for (let i = 0; i < 7; i++) {
            for (let j = i + 1; j < 7; j++) {
                graphs.K7.edges.push([i, j]);
            }
        }
        
        // Utility functions
        function torusDistance(p1, p2) {
            const dx = Math.abs(p1.x - p2.x);
            const dy = Math.abs(p1.y - p2.y);
            return {
                dx: Math.min(dx, 1 - dx),
                dy: Math.min(dy, 1 - dy),
                wrapX: dx > 0.5,
                wrapY: dy > 0.5
            };
        }
        
        function drawArrow(ctx, x1, y1, x2, y2, color = '#666') {
            const headlen = 8;
            const dx = x2 - x1;
            const dy = y2 - y1;
            const angle = Math.atan2(dy, dx);
            
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - headlen * Math.cos(angle - Math.PI / 6), 
                      y2 - headlen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(x2 - headlen * Math.cos(angle + Math.PI / 6), 
                      y2 - headlen * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
        }
        
        // Draw planar torus
        function drawPlanarTorus(graph) {
            const canvas = planarCtx.canvas;
            const w = canvas.width;
            const h = canvas.height;
            const margin = 60;
            const size = Math.min(w, h) - 2 * margin;
            
            planarCtx.clearRect(0, 0, w, h);
            
            // Background
            const gradient = planarCtx.createLinearGradient(margin, margin, margin + size, margin + size);
            gradient.addColorStop(0, '#fafafa');
            gradient.addColorStop(1, '#f0f0f0');
            planarCtx.fillStyle = gradient;
            planarCtx.fillRect(margin, margin, size, size);
            
            // Grid
            planarCtx.strokeStyle = '#e0e0e0';
            planarCtx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const pos = margin + (size * i / 10);
                planarCtx.beginPath();
                planarCtx.moveTo(pos, margin);
                planarCtx.lineTo(pos, margin + size);
                planarCtx.stroke();
                planarCtx.beginPath();
                planarCtx.moveTo(margin, pos);
                planarCtx.lineTo(margin + size, pos);
                planarCtx.stroke();
            }
            
            // Border
            planarCtx.strokeStyle = '#333';
            planarCtx.lineWidth = 4;
            planarCtx.strokeRect(margin, margin, size, size);
            
            // Identification arrows
            drawArrow(planarCtx, margin + 10, margin - 30, margin + size - 10, margin - 30, '#e74c3c');
            drawArrow(planarCtx, margin - 30, margin + 10, margin - 30, margin + size - 10, '#3498db');
            
            planarCtx.fillStyle = '#e74c3c';
            planarCtx.font = 'bold 14px "Noto Sans KR"';
            planarCtx.textAlign = 'center';
            planarCtx.fillText('Ï¢å ‚â° Ïö∞ (ÌÜ†Îü¨Ïä§ ÏãùÎ≥Ñ)', margin + size/2, margin - 35);
            
            planarCtx.fillStyle = '#3498db';
            planarCtx.save();
            planarCtx.translate(margin - 40, margin + size/2);
            planarCtx.rotate(-Math.PI/2);
            planarCtx.fillText('Ìïò ‚â° ÏÉÅ', 0, 0);
            planarCtx.restore();
            
            // Draw faces if highlighted
            if (showFaceHighlight && graph.faceBoundaries.length > 0) {
                const colors = ['rgba(255,99,132,0.15)', 'rgba(54,162,235,0.15)', 
                               'rgba(255,206,86,0.15)', 'rgba(75,192,192,0.15)', 
                               'rgba(153,102,255,0.15)'];
                
                graph.faceBoundaries.forEach((face, idx) => {
                    planarCtx.fillStyle = colors[idx % colors.length];
                    planarCtx.beginPath();
                    face.forEach((vIdx, i) => {
                        const v = graph.vertices[vIdx];
                        const x = margin + v.x * size;
                        const y = margin + v.y * size;
                        if (i === 0) planarCtx.moveTo(x, y);
                        else planarCtx.lineTo(x, y);
                    });
                    planarCtx.closePath();
                    planarCtx.fill();
                });
            }
            
            // Draw edges
            graph.edges.forEach((edge, idx) => {
                const v1 = graph.vertices[edge[0]];
                const v2 = graph.vertices[edge[1]];
                
                const x1 = margin + v1.x * size;
                const y1 = margin + v1.y * size;
                const x2 = margin + v2.x * size;
                const y2 = margin + v2.y * size;
                
                const dist = torusDistance(v1, v2);
                
                planarCtx.strokeStyle = dist.wrapX || dist.wrapY ? '#9333ea' : '#3b82f6';
                planarCtx.lineWidth = 2.5;
                planarCtx.lineCap = 'round';
                
                if (dist.wrapX || dist.wrapY) {
                    planarCtx.setLineDash([8, 4]);
                    planarCtx.globalAlpha = 0.7;
                } else {
                    planarCtx.setLineDash([]);
                    planarCtx.globalAlpha = 0.9;
                }
                
                if (dist.wrapX) {
                    const midY = (y1 + y2) / 2;
                    if (v2.x > v1.x) {
                        planarCtx.beginPath();
                        planarCtx.moveTo(x1, y1);
                        planarCtx.lineTo(margin + size, midY);
                        planarCtx.stroke();
                        planarCtx.beginPath();
                        planarCtx.moveTo(margin, midY);
                        planarCtx.lineTo(x2, y2);
                        planarCtx.stroke();
                    } else {
                        planarCtx.beginPath();
                        planarCtx.moveTo(x1, y1);
                        planarCtx.lineTo(margin, midY);
                        planarCtx.stroke();
                        planarCtx.beginPath();
                        planarCtx.moveTo(margin + size, midY);
                        planarCtx.lineTo(x2, y2);
                        planarCtx.stroke();
                    }
                } else if (dist.wrapY) {
                    const midX = (x1 + x2) / 2;
                    if (v2.y > v1.y) {
                        planarCtx.beginPath();
                        planarCtx.moveTo(x1, y1);
                        planarCtx.lineTo(midX, margin + size);
                        planarCtx.stroke();
                        planarCtx.beginPath();
                        planarCtx.moveTo(midX, margin);
                        planarCtx.lineTo(x2, y2);
                        planarCtx.stroke();
                    } else {
                        planarCtx.beginPath();
                        planarCtx.moveTo(x1, y1);
                        planarCtx.lineTo(midX, margin);
                        planarCtx.stroke();
                        planarCtx.beginPath();
                        planarCtx.moveTo(midX, margin + size);
                        planarCtx.lineTo(x2, y2);
                        planarCtx.stroke();
                    }
                } else {
                    planarCtx.beginPath();
                    planarCtx.moveTo(x1, y1);
                    planarCtx.lineTo(x2, y2);
                    planarCtx.stroke();
                }
                
                if (showEdgeLabels) {
                    const midX = (x1 + x2) / 2;
                    const midY = (y1 + y2) / 2;
                    planarCtx.fillStyle = 'white';
                    planarCtx.fillRect(midX - 10, midY - 8, 20, 16);
                    planarCtx.fillStyle = '#333';
                    planarCtx.font = '10px "Fira Code"';
                    planarCtx.textAlign = 'center';
                    planarCtx.textBaseline = 'middle';
                    planarCtx.fillText(`e${idx+1}`, midX, midY);
                }
            });
            
            planarCtx.setLineDash([]);
            planarCtx.globalAlpha = 1;
            
            // Draw vertices
            graph.vertices.forEach((v, idx) => {
                const x = margin + v.x * size;
                const y = margin + v.y * size;
                
                planarCtx.fillStyle = 'rgba(0,0,0,0.2)';
                planarCtx.beginPath();
                planarCtx.arc(x + 2, y + 2, 11, 0, 2 * Math.PI);
                planarCtx.fill();
                
                const vertexGradient = planarCtx.createRadialGradient(x-3, y-3, 0, x, y, 11);
                vertexGradient.addColorStop(0, '#ff6b9d');
                vertexGradient.addColorStop(1, '#c9184a');
                planarCtx.fillStyle = vertexGradient;
                planarCtx.beginPath();
                planarCtx.arc(x, y, 11, 0, 2 * Math.PI);
                planarCtx.fill();
                
                planarCtx.strokeStyle = 'white';
                planarCtx.lineWidth = 2;
                planarCtx.stroke();
                
                planarCtx.fillStyle = '#333';
                planarCtx.font = 'bold 13px "Noto Sans KR"';
                planarCtx.textAlign = 'center';
                planarCtx.fillText(v.id, x, y - 20);
            });
        }
        
        // 3D Torus rendering
        function draw3DTorus(graph) {
            const canvas = torusCtx.canvas;
            const w = canvas.width;
            const h = canvas.height;
            
            torusCtx.clearRect(0, 0, w, h);
            
            const bgGradient = torusCtx.createRadialGradient(w/2, h/2, 0, w/2, h/2, w/2);
            bgGradient.addColorStop(0, '#f8f9fa');
            bgGradient.addColorStop(1, '#e9ecef');
            torusCtx.fillStyle = bgGradient;
            torusCtx.fillRect(0, 0, w, h);
            
            const R = 140;
            const r = 70;
            const cx = w / 2;
            const cy = h / 2;
            
            if (isRotating) {
                rotationAngle += 0.008;
            }
            
            const surfaces = [];
            for (let u = 0; u < 2 * Math.PI; u += Math.PI / 24) {
                for (let v = 0; v < 2 * Math.PI; v += Math.PI / 24) {
                    const p1 = torusPoint(u, v, R, r, rotationAngle);
                    const p2 = torusPoint(u + Math.PI/24, v, R, r, rotationAngle);
                    const p3 = torusPoint(u + Math.PI/24, v + Math.PI/24, R, r, rotationAngle);
                    const p4 = torusPoint(u, v + Math.PI/24, R, r, rotationAngle);
                    
                    const avgZ = (p1.z + p2.z + p3.z + p4.z) / 4;
                    surfaces.push({points: [p1, p2, p3, p4], z: avgZ});
                }
            }
            
            surfaces.sort((a, b) => a.z - b.z);
            
            surfaces.forEach(surface => {
                const brightness = Math.floor(180 + (surface.z / 300) * 75);
                torusCtx.fillStyle = `rgb(${brightness}, ${brightness-20}, ${brightness+20})`;
                torusCtx.strokeStyle = `rgb(${brightness-30}, ${brightness-50}, ${brightness})`;
                torusCtx.lineWidth = 0.5;
                
                torusCtx.beginPath();
                surface.points.forEach((p, i) => {
                    const x = cx + p.x;
                    const y = cy + p.y;
                    if (i === 0) torusCtx.moveTo(x, y);
                    else torusCtx.lineTo(x, y);
                });
                torusCtx.closePath();
                torusCtx.fill();
                torusCtx.stroke();
            });
            
            const vertices3D = graph.vertices.map(v => {
                const u = v.x * 2 * Math.PI;
                const vAngle = v.y * 2 * Math.PI;
                return torusPoint(u, vAngle, R, r, rotationAngle);
            });
            
            const edges3D = graph.edges.map((edge, idx) => {
                const p1 = vertices3D[edge[0]];
                const p2 = vertices3D[edge[1]];
                return {
                    p1, p2,
                    z: (p1.z + p2.z) / 2,
                    idx
                };
            });
            
            edges3D.sort((a, b) => a.z - b.z);
            
            edges3D.forEach(({p1, p2, z}) => {
                if (z > -150) {
                    const alpha = Math.max(0.3, 0.5 + z / 300);
                    torusCtx.strokeStyle = `rgba(99, 102, 241, ${alpha})`;
                    torusCtx.lineWidth = 3;
                    torusCtx.lineCap = 'round';
                    
                    torusCtx.beginPath();
                    torusCtx.moveTo(cx + p1.x, cy + p1.y);
                    torusCtx.lineTo(cx + p2.x, cy + p2.y);
                    torusCtx.stroke();
                }
            });
            
            const vertices3DWithDepth = vertices3D.map((p, i) => ({
                ...p,
                id: graph.vertices[i].id,
                idx: i
            })).sort((a, b) => a.z - b.z);
            
            vertices3DWithDepth.forEach(p => {
                if (p.z > -150) {
                    const size = 8 + (p.z / 300) * 4;
                    const alpha = Math.max(0.5, 0.7 + p.z / 300);
                    
                    torusCtx.fillStyle = 'rgba(0,0,0,0.2)';
                    torusCtx.beginPath();
                    torusCtx.arc(cx + p.x + 2, cy + p.y + 2, size, 0, 2 * Math.PI);
                    torusCtx.fill();
                    
                    const vertGrad = torusCtx.createRadialGradient(
                        cx + p.x - size/3, cy + p.y - size/3, 0,
                        cx + p.x, cy + p.y, size
                    );
                    vertGrad.addColorStop(0, `rgba(255, 107, 157, ${alpha})`);
                    vertGrad.addColorStop(1, `rgba(201, 24, 74, ${alpha})`);
                    torusCtx.fillStyle = vertGrad;
                    torusCtx.beginPath();
                    torusCtx.arc(cx + p.x, cy + p.y, size, 0, 2 * Math.PI);
                    torusCtx.fill();
                    
                    torusCtx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                    torusCtx.lineWidth = 2;
                    torusCtx.stroke();
                    
                    torusCtx.fillStyle = `rgba(51, 51, 51, ${alpha})`;
                    torusCtx.font = 'bold 12px "Noto Sans KR"';
                    torusCtx.textAlign = 'center';
                    torusCtx.fillText(p.id, cx + p.x, cy + p.y - size - 8);
                }
            });
            
            if (isRotating) {
                animationFrame = requestAnimationFrame(() => draw3DTorus(graph));
            }
        }
        
        function torusPoint(u, v, R, r, rotation) {
            const x = (R + r * Math.cos(v)) * Math.cos(u);
            const y = (R + r * Math.cos(v)) * Math.sin(u);
            const z = r * Math.sin(v);
            
            const cos = Math.cos(rotation);
            const sin = Math.sin(rotation);
            const xRot = x * cos - z * sin;
            const zRot = x * sin + z * cos;
            
            const distance = 400;
            const scale = distance / (distance + zRot);
            
            return {
                x: xRot * scale * 0.8,
                y: y * scale * 0.6,
                z: zRot
            };
        }
        
        function updateStatistics(graph) {
            const V = graph.vertices.length;
            const E = graph.edges.length;
            const F = graph.faces;
            const g = graph.genus;
            const chi = V - E + F;
            const expectedChi = 2 - 2*g;
            
            document.getElementById('stat-v').textContent = V;
            document.getElementById('stat-e').textContent = E;
            document.getElementById('stat-f').textContent = F;
            document.getElementById('stat-g').textContent = g;
            
            document.getElementById('euler-calc').textContent = 
                `${V} - ${E} + ${F} = ${chi}`;
            
            const resultElem = document.getElementById('euler-result');
            if (chi === expectedChi) {
                resultElem.className = 'euler-result valid';
                resultElem.textContent = `‚úì œá = ${expectedChi} (Ï¢ÖÏàò g=${g} Ï°∞Í±¥ ÎßåÏ°±)`;
            } else {
                resultElem.className = 'euler-result invalid';
                resultElem.textContent = `‚úó Î∂àÏùºÏπò (ÏòàÏÉÅ: ${expectedChi})`;
            }
            
            document.getElementById('crossing-info').textContent = 
                `cr(${graph.name}) = ${graph.crossingNumber}`;
        }
        
        function selectGraph(name) {
            currentGraphName = name;
            currentGraph = graphs[name];
            
            ['K5', 'K33', 'K7', 'Petersen'].forEach(g => {
                const btn = document.getElementById(`btn-${g}`);
                if (g === name) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            updateStatistics(currentGraph);
            drawPlanarTorus(currentGraph);
            
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }
            draw3DTorus(currentGraph);
        }
        
        function toggleFaceHighlight() {
            showFaceHighlight = !showFaceHighlight;
            drawPlanarTorus(currentGraph);
        }
        
        function toggleEdgeLabels() {
            showEdgeLabels = !showEdgeLabels;
            drawPlanarTorus(currentGraph);
        }
        
        function animateRotation() {
            isRotating = !isRotating;
            if (isRotating) {
                draw3DTorus(currentGraph);
            }
        }
        
        function toggleCrossings(elem) {
            elem.classList.toggle('active');
            showCrossings = !showCrossings;
        }
        
        function resetView() {
            rotationAngle = 0;
            showFaceHighlight = false;
            showEdgeLabels = false;
            drawPlanarTorus(currentGraph);
            draw3DTorus(currentGraph);
        }
        
        selectGraph('K5');
    </script>
</body>
</html>