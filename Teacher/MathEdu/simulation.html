<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>íšŒì „ í¬ë¬¼ì„  ì‹œë®¬ë ˆì´ì…˜ - ì¸í„°ë™í‹°ë¸Œ 3D</title>
  <link rel="stylesheet" href="shared.css" />
  
  <!-- MathJax -->
  <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  
  <!-- Cannon.js (ë¬¼ë¦¬ì—”ì§„) -->
  <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
</head>

<body>
<header>
  <div>
    <h1>íšŒì „ í¬ë¬¼ì„  ì‹œë®¬ë ˆì´ì…˜</h1>
    <div class="tagline">ì´ë¡  í¬ë¬¼ì„  + ë¬¼ë¦¬ì—”ì§„ ì…ì ìœ ì²´ ë¹„êµ</div>
  </div>
  <nav>
    <a href="overview.html">ğŸ“š ê°œìš”</a>
    <a href="simulation.html">ğŸ® ì‹œë®¬ë ˆì´ì…˜</a>
    <a href="theory.html">ğŸ“ ìˆ˜ì‹Â·ì‹¬í™”</a>
  </nav>
</header>

<main>

  <section id="sim">
    <h2>
      <span class="badge">STEP 3</span>
      ì‹œë®¬ë ˆì´ì…˜: ì´ë¡  í¬ë¬¼ì„  + ë¬¼ë¦¬ì—”ì§„ ì…ì ìœ ì²´
    </h2>
    <p class="sub">
      ì•„ë˜ ìŠ¬ë¼ì´ë”ë¡œ \(\omega, H, L, g\) ì„ ì¡°ì ˆí•˜ë©´
      ì™¼ìª½ì—ëŠ” <strong>ì´ë¡  í¬ë¬¼ì„  ë‹¨ë©´</strong>,
      ì˜¤ë¥¸ìª½ì—ëŠ” <strong>3D ì´ë¡  ìˆ˜ë©´ + Cannon.js ì…ì ìœ ì²´</strong>ê°€ ë™ì‹œì— ê°±ì‹ ë©ë‹ˆë‹¤.
      <br/>
      íŒŒë€ ë©´: ì´ë¡  ìˆ˜ë©´, ì£¼í™© êµ¬ìŠ¬: ë¬¼ë¦¬ì—”ì§„ì´ ê³„ì‚°í•˜ëŠ” ì…ì ìœ ì²´ì…ë‹ˆë‹¤.
    </p>

    <div class="controls">
      <div class="control">
        <label>
          <span>\(\omega\) (rad/s)</span>
          <small>íšŒì „ ê°ì†ë„</small>
        </label>
        <input id="omegaSlider" type="range" min="0" max="10" step="0.1" value="3" />
        <input id="omegaInput" type="number" step="0.1" value="3" />
      </div>

      <div class="control">
        <label>
          <span>H (m)</span>
          <small>ì •ì§€ ìƒíƒœ ë¬¼ë†’ì´</small>
        </label>
        <input id="HSlider" type="range" min="0.02" max="0.15" step="0.005" value="0.08" />
        <input id="HInput" type="number" step="0.005" value="0.08" />
      </div>

      <div class="control">
        <label>
          <span>L (m)</span>
          <small>ë¬¼í†µ ê¸¸ì´ (ë‹¨ë©´ í­)</small>
        </label>
        <input id="LSlider" type="range" min="0.1" max="0.5" step="0.01" value="0.25" />
        <input id="LInput" type="number" step="0.01" value="0.25" />
      </div>

      <div class="control">
        <label>
          <span>g (m/sÂ²)</span>
          <small>ì¤‘ë ¥ ê°€ì†ë„</small>
        </label>
        <input id="gInput" type="number" step="0.1" value="9.8" />
        <div style="font-size:0.8rem; color:#6b7280;">
          (ì‹¤í—˜ ë°ì´í„°ì™€ ë¹„êµí•´ \(g\) ë¥¼ ì—­ì¶”ì •í•˜ëŠ” í”„ë¡œì íŠ¸ ê°€ëŠ¥)
        </div>
      </div>

      <div class="control">
        <label><span>ê³„ì‚° ê²°ê³¼</span></label>
        <div id="calcInfo" style="font-size:0.8rem; color:#111827;"></div>
      </div>

      <div class="control">
        <label><span>ì…ì ìœ ì²´ ì œì–´</span></label>
        <div style="display:flex; gap:0.25rem; align-items:center; flex-wrap:wrap;">
          <button id="resetFluidBtn">ì…ì ì´ˆê¸°í™”</button>
          <span style="font-size:0.78rem; color:#6b7280;">
            ì´ˆê¸° ìƒíƒœë¡œ ë˜ëŒë¦° ë’¤, ë‹¤ë¥¸ \(\omega\) ì—ì„œ ë‹¤ì‹œ ì§„í™” ê´€ì°°
          </span>
        </div>
      </div>
    </div>

    <div class="two-column">
      <div>
        <div class="pill">2D ë‹¨ë©´ ì‹œë®¬ë ˆì´ì…˜ (r-z í‰ë©´)</div>
        <canvas id="profileCanvas" width="600" height="320"></canvas>
        <div class="note">
          ì„¸ë¡œì¶•: ë†’ì´ \(z\) (m), ê°€ë¡œì¶•: ë¬¼í†µ ê¸¸ì´ ë°©í–¥ ì¢Œí‘œ \(r\) (m).<br/>
          ë¹¨ê°„ ì ì„ : ë°”ë‹¥, íŒŒë€ ê³¡ì„ : ì´ë¡  ììœ ìˆ˜ë©´,
          íšŒìƒ‰ ì‚¬ê°í˜•: ë¬¼í†µ ê²½ê³„ì…ë‹ˆë‹¤.
        </div>
      </div>

      <div>
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.25rem;">
          <div>
            <div class="pill">3D ì´ë¡  ìˆ˜ë©´ + Cannon.js ì…ì ìœ ì²´</div>
          </div>
          <div style="font-size:0.75rem; color:#9ca3af;">
            ë“œë˜ê·¸: íšŒì „ Â· íœ : í™•ëŒ€/ì¶•ì†Œ
          </div>
        </div>
        <div id="threeContainer"></div>
        <div class="note">
          íŒŒë€ í¬ë¬¼ë©´ì€ ì´ë¡ ì‹ì—ì„œ ë‚˜ì˜¨ ë†’ì´ì¥,
          ì£¼í™©ìƒ‰ êµ¬ìŠ¬ë“¤ì€ Cannon.js ë¬¼ë¦¬ì—”ì§„ì´ ê³„ì‚°í•˜ëŠ” ì…ìì…ë‹ˆë‹¤.<br/>
          \(\omega\) ë¥¼ ë°”ê¿”ê°€ë©° ë‘ í˜•íƒœê°€ ì–¼ë§ˆë‚˜ ì¼ì¹˜í•˜ëŠ”ì§€ ë¹„êµí•´ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        </div>
      </div>
    </div>
  </section>

</main>

<!-- Three.jsë¥¼ ES Modules ë°©ì‹ìœ¼ë¡œ ë¡œë“œ (r150+ í˜¸í™˜) -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// ==== DOM ìš”ì†Œ ====
const omegaSlider = document.getElementById('omegaSlider');
const omegaInput  = document.getElementById('omegaInput');
const HSlider     = document.getElementById('HSlider');
const HInput      = document.getElementById('HInput');
const LSlider     = document.getElementById('LSlider');
const LInput      = document.getElementById('LInput');
const gInput      = document.getElementById('gInput');
const calcInfo    = document.getElementById('calcInfo');
const profileCanvas = document.getElementById('profileCanvas');
const ctx = profileCanvas.getContext('2d');
const resetFluidBtn = document.getElementById('resetFluidBtn');

// ==== ì „ì—­ ë³€ìˆ˜ ====
let scene, camera, renderer, controls, waterMesh;
let world, fluidBodies = [], fluidMeshes = [];
let currentOmega = 0;

// ==== ìŠ¬ë¼ì´ë”/ì¸í’‹ ë™ê¸°í™” ====
function syncPair(slider, input, formatter = v => v) {
  slider.addEventListener('input', () => {
    input.value = formatter(slider.value);
    updateAll();
  });
  input.addEventListener('change', () => {
    slider.value = formatter(input.value);
    updateAll();
  });
}

syncPair(omegaSlider, omegaInput, v => Number(v));
syncPair(HSlider, HInput, v => Number(v));
syncPair(LSlider, LInput, v => Number(v));
gInput.addEventListener('change', updateAll);

// ==== 2D í¬ë¬¼ì„  ë‹¨ë©´ ê·¸ë¦¬ê¸° ====
function drawProfile(omega, H, L, g) {
  const w = profileCanvas.width;
  const h = profileCanvas.height;
  ctx.clearRect(0, 0, w, h);

  const margin = 40;
  const rMin = -L / 2;
  const rMax = L / 2;

  const extra = (omega * omega * L * L) / (24 * g);
  const zMin = Math.min(0, H - extra * 1.2);
  const zMax = H + extra * 0.2;

  function xPix(r) {
    return margin + (r - rMin) * (w - 2 * margin) / (rMax - rMin);
  }
  function yPix(z) {
    return h - margin - (z - zMin) * (h - 2 * margin) / (zMax - zMin);
  }

  // ë°”ë‹¥ì„  (z=0)
  ctx.strokeStyle = '#ef4444';
  ctx.setLineDash([4, 4]);
  ctx.beginPath();
  ctx.moveTo(xPix(rMin), yPix(0));
  ctx.lineTo(xPix(rMax), yPix(0));
  ctx.stroke();
  ctx.setLineDash([]);

  // ë¬¼í†µ ê²½ê³„
  ctx.strokeStyle = '#9ca3af';
  ctx.setLineDash([6, 4]);
  ctx.beginPath();
  ctx.rect(xPix(rMin), yPix(0), xPix(rMax) - xPix(rMin), yPix(zMax) - yPix(0));
  ctx.stroke();
  ctx.setLineDash([]);

  // ììœ ìˆ˜ë©´ í¬ë¬¼ì„ 
  ctx.strokeStyle = '#2563eb';
  ctx.lineWidth = 2;
  ctx.beginPath();
  const N = 200;
  for (let i = 0; i <= N; i++) {
    const r = rMin + (rMax - rMin) * i / N;
    const z = H - (omega * omega / (2 * g)) * (L * L / 12 - r * r);
    const x = xPix(r);
    const y = yPix(z);
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();

  // ì¶• ë¼ë²¨
  ctx.fillStyle = '#4b5563';
  ctx.font = '10px system-ui';
  ctx.fillText('r (m)', w - margin + 5, yPix(0) + 4);
  ctx.fillText('z (m)', xPix(0) - 10, margin - 10);
}

// ==== Three.js 3D ì„¤ì • ====
function initThree() {
  const container = document.getElementById('threeContainer');
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x020617);

  const width = container.clientWidth;
  const height = container.clientHeight;

  camera = new THREE.PerspectiveCamera(40, width / height, 0.01, 50);
  camera.position.set(0.6, 0.5, 0.9);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(width, height);
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  container.appendChild(renderer.domElement);

  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  const light = new THREE.DirectionalLight(0xffffff, 1.2);
  light.position.set(1, 2, 2);
  scene.add(light);
  scene.add(new THREE.AmbientLight(0xffffff, 0.3));

  // ë¬¼í†µ ë°•ìŠ¤ (ì™€ì´ì–´)
  const boxGeom = new THREE.BoxGeometry(0.5, 0.25, 0.08);
  const edges = new THREE.EdgesGeometry(boxGeom);
  const box = new THREE.LineSegments(
    edges,
    new THREE.LineBasicMaterial({ color: 0x9ca3af })
  );
  scene.add(box);

  // ë¬¼ í‘œë©´ ë©”ì‰¬ (ì´ë¡  í¬ë¬¼ë©´)
  const resX = 60, resY = 8;
  const planeGeom = new THREE.PlaneGeometry(0.5, 0.08, resX, resY);
  const waterMat = new THREE.MeshPhongMaterial({
    color: 0x3b82f6,
    transparent: true,
    opacity: 0.8,
    side: THREE.DoubleSide,
    shininess: 80
  });
  waterMesh = new THREE.Mesh(planeGeom, waterMat);
  waterMesh.rotation.x = -Math.PI / 2;
  scene.add(waterMesh);

  window.addEventListener('resize', onWindowResize);
  animate();
}

function onWindowResize() {
  const container = document.getElementById('threeContainer');
  const width = container.clientWidth;
  const height = container.clientHeight;
  camera.aspect = width / height;
  camera.updateProjectionMatrix();
  renderer.setSize(width, height);
}

function updateWaterSurface(omega, H, L, g) {
  if (!waterMesh) return;
  const geom = waterMesh.geometry;
  geom.computeBoundingBox();
  const pos = geom.attributes.position;
  const bbox = geom.boundingBox;

  const scaleX = L;
  const Lhalf = L / 2;
  const extra = (omega * omega * L * L) / (24 * g);
  const zMin = Math.min(0, H - extra * 1.2);
  const zMax = H + extra * 0.2;
  const scaleZ = 0.22 / (zMax - zMin); // ë°•ìŠ¤ ë†’ì´ ë‚´ë¶€ì— ë§ì¶”ê¸°

  for (let i = 0; i < pos.count; i++) {
    const xLocal = pos.getX(i);
    const zLocal = pos.getY(i); // íšŒì „ ì „ ê¸°ì¤€

    const r = ((xLocal - bbox.min.x) / (bbox.max.x - bbox.min.x) - 0.5) * scaleX;
    const zPhys = H - (omega * omega / (2 * g)) * (L * L / 12 - r * r);

    const yMapped = (zPhys - zMin) * scaleZ - 0.11;
    pos.setY(i, yMapped);
  }

  pos.needsUpdate = true;
  geom.computeVertexNormals();
}

// ==== Cannon.js ë¬¼ë¦¬ì—”ì§„ ì„¤ì • ====
function initPhysics() {
  world = new CANNON.World();
  world.gravity.set(0, -Number(gInput.value), 0);
  world.broadphase = new CANNON.NaiveBroadphase();
  world.solver.iterations = 10;

  const halfW = 0.25;
  const halfH = 0.12;
  const halfD = 0.04;

  function addStaticBox(size, pos) {
    const shape = new CANNON.Box(new CANNON.Vec3(size.x / 2, size.y / 2, size.z / 2));
    const body = new CANNON.Body({ mass: 0 });
    body.addShape(shape);
    body.position.set(pos.x, pos.y, pos.z);
    world.addBody(body);
  }

  // ë°”ë‹¥
  addStaticBox({ x: halfW * 2, y: 0.02, z: halfD * 2 }, { x: 0, y: -halfH, z: 0 });
  // ì¢Œìš° ë²½
  addStaticBox({ x: 0.02, y: halfH * 2, z: halfD * 2 }, { x: -halfW, y: 0, z: 0 });
  addStaticBox({ x: 0.02, y: halfH * 2, z: halfD * 2 }, { x: halfW, y: 0, z: 0 });
  // ì•ë’¤ ë²½
  addStaticBox({ x: halfW * 2, y: halfH * 2, z: 0.02 }, { x: 0, y: 0, z: -halfD });
  addStaticBox({ x: halfW * 2, y: halfH * 2, z: 0.02 }, { x: 0, y: 0, z: halfD });
}

function initFluid() {
  // ê¸°ì¡´ ê²ƒ ì •ë¦¬
  resetFluid(true);

  const N = 150;
  const radius = 0.01;
  const shape = new CANNON.Sphere(radius);

  const sphereGeo = new THREE.SphereGeometry(radius, 12, 12);
  const sphereMat = new THREE.MeshPhongMaterial({
    color: 0xf97316,
    transparent: true,
    opacity: 0.9
  });

  for (let i = 0; i < N; i++) {
    const body = new CANNON.Body({
      mass: 0.02,
      shape: shape,
      linearDamping: 0.05,
      angularDamping: 0.05
    });

    const x = (Math.random() - 0.5) * 0.4;
    const y = -0.11 + Math.random() * 0.02;
    const z = (Math.random() - 0.5) * 0.06;
    body.position.set(x, y, z);
    world.addBody(body);
    fluidBodies.push(body);

    const mesh = new THREE.Mesh(sphereGeo, sphereMat);
    mesh.position.set(x, y, z);
    scene.add(mesh);
    fluidMeshes.push(mesh);
  }
}

function resetFluid(skipInit) {
  // ê¸°ì¡´ ì…ì ì œê±°
  fluidMeshes.forEach(m => scene.remove(m));
  fluidMeshes = [];
  if (world) {
    fluidBodies.forEach(b => world.removeBody(b));
  }
  fluidBodies = [];
  if (!skipInit) {
    initFluid();
  }
}

function applyCentrifugalForces(omega) {
  if (!world) return;
  const w2 = omega * omega;
  for (let i = 0; i < fluidBodies.length; i++) {
    const b = fluidBodies[i];
    const r = b.position.x; // x ë°©í–¥ë§Œ ë°˜ì§€ë¦„ìœ¼ë¡œ ì‚¬ìš© (í­ ë°©í–¥)
    if (Math.abs(r) < 1e-4) continue;
    const dir = r > 0 ? 1 : -1;
    const fmag = b.mass * w2 * Math.abs(r);
    const fx = dir * fmag;
    const force = new CANNON.Vec3(fx, 0, 0);
    b.applyForce(force, b.position);
  }
}

// ==== ê³„ì‚° ì •ë³´ í…ìŠ¤íŠ¸ ====
function updateCalcInfo(omega, H, L, g) {
  const omega_c = Math.sqrt(24 * g * H / (L * L));
  const zv = H - (omega * omega * L * L) / (24 * g);
  const ratio = omega_c > 0 ? (omega / omega_c) : 0;

  calcInfo.innerHTML =
    `<div style="line-height:1.4;">
      <div>ì„ê³„ ê°ì†ë„: <strong>Ï‰_c â‰ˆ ${omega_c.toFixed(2)} rad/s</strong></div>
      <div>í˜„ì¬ ê¼­ì§“ì  ë†’ì´: <strong>z_v â‰ˆ ${zv.toFixed(3)} m</strong></div>
      <div>ìƒëŒ€ íšŒì „ ì„¸ê¸°: <strong>Ï‰ / Ï‰_c â‰ˆ ${ratio.toFixed(2)}</strong></div>
      <div style="font-size:0.78rem; color:#6b7280; margin-top:0.25rem;">
        Ï‰ &lt; Ï‰_c: ì¤‘ì‹¬ì´ ì•„ì§ ë°”ë‹¥ì— ë‹¿ì§€ ì•ŠìŒ (í¬ë¬¼ì„  ì „ì²´ê°€ ë¬¼ ì•ˆì— ìˆìŒ)<br/>
        Ï‰ â‰ˆ Ï‰_c: ê¼­ì§“ì ì´ ë°”ë‹¥ì— ì ‘ì´‰ (ë§ˆë¥¸ ì˜ì—­ì´ ìƒê¸°ê¸° ì‹œì‘)<br/>
        Ï‰ &gt; Ï‰_c: ë‹¨ìˆœ í¬ë¬¼ì„  ëª¨ë¸ë§Œìœ¼ë¡  ë¶€ì¡±í•´ì§€ê³ , ì‹¤ì œ ìœ ì²´ì—ì„œëŠ” í† ëŸ¬ìŠ¤ í˜•íƒœ ë“± ë³µì¡í•œ í˜•ìƒì´ ë“±ì¥.
      </div>
    </div>`;
}

// ==== ì „ì²´ ì—…ë°ì´íŠ¸ ====
function updateAll() {
  const omega = Number(omegaInput.value);
  const H = Number(HInput.value);
  const L = Number(LInput.value);
  const g = Number(gInput.value);

  currentOmega = omega;

  drawProfile(omega, H, L, g);
  updateWaterSurface(omega, H, L, g);
  updateCalcInfo(omega, H, L, g);

  if (world) {
    world.gravity.set(0, -g, 0);
  }
}

// ==== ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ ====
function animate() {
  requestAnimationFrame(animate);
  if (controls) controls.update();

  if (world) {
    const dt = 1 / 60;
    applyCentrifugalForces(currentOmega);
    world.step(dt);

    for (let i = 0; i < fluidBodies.length; i++) {
      const b = fluidBodies[i];
      const m = fluidMeshes[i];
      m.position.copy(b.position);
    }
  }

  if (renderer && scene && camera) {
    renderer.render(scene, camera);
  }
}

// ==== ì´ˆê¸°í™” ====
initThree();
initPhysics();
initFluid();
updateAll();

resetFluidBtn.addEventListener('click', () => {
  resetFluid(false);
});
</script>

</body>
</html>
