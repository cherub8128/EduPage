<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pygame과 Stable Baselines3 연동 실습 (상세 버전)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" xintegrity="sha384-n8MVd4RsNIU07RLA8HuPOhrBIWEidUdaf65IBqz2tVRckQ9/VEOESTP1OF2dvGub" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" xintegrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUbKyIyuh" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" xintegrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Noto Sans KR', sans-serif; background-color: #f1f5f9; }
        .tab-button { transition: all 0.3s; }
        .tab-button.active { border-color: #4f46e5; color: #4f46e5; background-color: white; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .katex { font-size: 1.1em !important; }
        pre { background-color: #1e293b; color: #e2e8f0; padding: 1.5rem; border-radius: 0.5rem; overflow-x: auto; position: relative; margin-top: 1rem; margin-bottom: 1rem; }
        .copy-button { position: absolute; top: 1rem; right: 1rem; background-color: #475569; color: white; padding: 0.25rem 0.5rem; border-radius: 0.25rem; cursor: pointer; transition: background-color 0.2s; }
        .copy-button:hover { background-color: #64748b; }
        .step-heading { font-size: 1.25rem; font-weight: 700; color: #1e3a8a; margin-top: 2rem; margin-bottom: 1rem; border-bottom: 2px solid #e0e7ff; padding-bottom: 0.5rem; }
        code.inline-code { background-color: #eef2ff; color: #4338ca; padding: 2px 6px; border-radius: 4px; font-size: 0.9em; }
    </style>
</head>
<body class="p-4 md:p-8">
    <div class="max-w-7xl mx-auto bg-white rounded-2xl shadow-2xl overflow-hidden">
        <header class="p-8 bg-gray-800 text-white text-center">
            <h1 class="text-3xl md:text-4xl font-bold">인터랙티브 RL 실습: Pygame + Stable Baselines3</h1>
            <p class="mt-2 text-gray-300">이론부터 코드 실행, 시뮬레이션까지 한 페이지에서 경험해보세요.</p>
        </header>

        <div class="p-8">
            <!-- Tabs Navigation -->
            <div class="flex border-b border-gray-200 mb-8 overflow-x-auto">
                <button class="tab-button active text-lg font-semibold py-4 px-6 border-b-2 border-transparent flex-shrink-0" onclick="openTab(event, 'theory')">1. 이론적 배경</button>
                <button class="tab-button text-lg font-semibold py-4 px-6 border-b-2 border-transparent flex-shrink-0" onclick="openTab(event, 'env-code')">2. Pygame 환경 코드</button>
                <button class="tab-button text-lg font-semibold py-4 px-6 border-b-2 border-transparent flex-shrink-0" onclick="openTab(event, 'sb3-code')">3. SB3 학습 코드</button>
                <button class="tab-button text-lg font-semibold py-4 px-6 border-b-2 border-transparent flex-shrink-0" onclick="openTab(event, 'simulation')">4. 학습 결과 시뮬레이션</button>
                <button class="tab-button text-lg font-semibold py-4 px-6 border-b-2 border-transparent flex-shrink-0" onclick="openTab(event, 'env-guide')">5. 환경 코드 변경 가이드</button>
            </div>

            <!-- Tab Content -->
            <div id="theory" class="tab-content active">
                <h2 class="text-2xl font-bold mb-4 text-gray-800">MDP와 Gymnasium API</h2>
                <p class="text-gray-700 mb-4">강화학습은 <strong>마르코프 결정 과정(MDP)</strong>으로 문제를 모델링합니다. MDP는 $(\mathcal{S}, \mathcal{A}, \mathcal{P}, \mathcal{R}, \gamma)$ 튜플로 정의됩니다.</p>
                <ul class="list-disc list-inside space-y-2 text-gray-600 mb-6">
                    <li>$\mathcal{S}$: 모든 가능한 <strong>상태(State)</strong>의 집합 (e.g., 플레이어와 공의 위치)</li>
                    <li>$\mathcal{A}$: 모든 가능한 <strong>행동(Action)</strong>의 집합 (e.g., 좌, 우, 정지)</li>
                    <li>$\mathcal{P}(s'|s,a)$: 상태 $s$에서 행동 $a$를 했을 때 다음 상태 $s'$로 전이할 <strong>확률</strong></li>
                    <li>$\mathcal{R}(s,a,s')$: 행동의 결과로 받는 즉각적인 <strong>보상(Reward)</strong></li>
                    <li>$\gamma$: 미래 보상의 현재 가치를 결정하는 <strong>할인율(Discount Factor)</strong></li>
                </ul>
                <p class="text-gray-700 mb-4">에이전트의 목표는 누적 보상 $G_t = \sum_{k=0}^{T} \gamma^k R_{t+k+1}$를 최대화하는 정책 $\pi(a|s)$를 학습하는 것입니다.</p>
                <p class="text-gray-700"><strong>Gymnasium</strong>은 이러한 상호작용을 표준화된 API로 제공하여 알고리즘 개발을 돕습니다. 핵심 메서드는 다음과 같습니다.</p>
                 <ul class="list-disc list-inside space-y-2 text-gray-600 mt-4">
                    <li><b>env.reset()</b>: 환경을 초기화하고 첫 관측값을 반환합니다.</li>
                    <li><b>env.step(action)</b>: 행동을 실행하고 `(관측값, 보상, 종료여부, 정보)`를 반환합니다.</li>
                    <li><b>env.render()</b>: 환경을 시각화합니다.</li>
                </ul>
            </div>

            <div id="env-code" class="tab-content">
                <h2 class="text-2xl font-bold mb-4 text-gray-800">Pygame 환경 구현 (`my_pygame_env.py`)</h2>
                <p class="text-gray-700 mb-4">Pygame으로 만든 게임을 `gym.Env` 클래스를 상속받아 강화학습 환경으로 만듭니다. 각 단계를 따라 코드를 완성해 보세요.</p>
                <h3 class="step-heading">Step 1: 기본 구조 및 초기화 (`__init__`)</h3>
                <p>먼저, 필요한 라이브러리를 가져오고 `gym.Env`를 상속받는 클래스를 정의합니다. `__init__` 메서드에서는 에이전트가 상호작용할 <strong>행동 공간(Action Space)</strong>과 <strong>관측 공간(Observation Space)</strong>을 정의해야 합니다.</p>
                <ul>
                    <li><code class="inline-code">spaces.Discrete(2)</code>: '왼쪽으로 이동', '오른쪽으로 이동'의 2가지 이산적인 행동을 정의합니다.</li>
                    <li><code class="inline-code">spaces.Box</code>: [플레이어 x, 공 x, 공 y, 공 vx, 공 vy] 5개의 연속적인 값으로 상태를 정의합니다. 각 값의 최솟값(low)과 최댓값(high)을 지정합니다.</li>
                </ul>
                <pre><button class="copy-button" onclick="copyCode(this)">Copy</button><code class="language-python">
import gymnasium as gym
from gymnasium import spaces
import numpy as np
import pygame

class PygameEnv(gym.Env):
    metadata = {"render_modes": ["human", "rgb_array"], "render_fps": 30}

    def __init__(self, render_mode=None):
        super().__init__()
        self.screen_width = 400
        self.screen_height = 600
        self.action_space = spaces.Discrete(2)
        low = np.array([0, 0, 0, -10, -10], dtype=np.float32)
        high = np.array([self.screen_width, self.screen_width, self.screen_height, 10, 10], dtype=np.float32)
        self.observation_space = spaces.Box(low, high, dtype=np.float32)
        assert render_mode is None or render_mode in self.metadata["render_modes"]
        self.render_mode = render_mode
        self.window = None
        self.clock = None
                </code></pre>
                <h3 class="step-heading">Step 2: 환경 초기화 (`reset`)</h3>
                <p>에피소드가 시작되거나 끝날 때마다 환경을 초기 상태로 되돌립니다. 플레이어와 공의 위치, 공의 속도를 무작위로 설정하여 에이전트가 다양한 상황에서 학습하도록 합니다. 마지막으로 초기 <strong>관측값</strong>과 <strong>정보</strong>를 반환해야 합니다.</p>
                <pre><button class="copy-button" onclick="copyCode(this)">Copy</button><code class="language-python">
# (PygameEnv 클래스 내부에 추가)
    def reset(self, seed=None, options=None):
        super().reset(seed=seed)
        self.player = pygame.Rect(self.screen_width / 2 - 30, self.screen_height - 30, 60, 10)
        self.ball = pygame.Rect(self.screen_width / 2 - 5, self.screen_height / 2 - 5, 10, 10)
        self.ball_vx = self.np_random.choice([-4, 4])
        self.ball_vy = -4
        if self.render_mode == "human": self._render_frame()
        return self._get_obs(), self._get_info()

    def _get_obs(self):
        return np.array([self.player.x, self.ball.x, self.ball.y, self.ball_vx, self.ball_vy], dtype=np.float32)

    def _get_info(self):
        return {"distance": np.linalg.norm(np.array([self.player.x, self.player.y]) - np.array([self.ball.x, self.ball.y]))}
                </code></pre>
                <h3 class="step-heading">Step 3: 시간 흐름 구현 (`step`)</h3>
                <p>`step` 메서드는 환경의 핵심 로직입니다. 에이전트로부터 `action`을 받아 다음 상태로 전환하고, 그에 따른 보상을 계산합니다.</p>
                <pre><button class="copy-button" onclick="copyCode(this)">Copy</button><code class="language-python">
# (PygameEnv 클래스 내부에 추가)
    def step(self, action):
        if action == 0: self.player.x -= 8
        elif action == 1: self.player.x += 8
        self.player.x = np.clip(self.player.x, 0, self.screen_width - self.player.width)
        self.ball.x += self.ball_vx
        self.ball.y += self.ball_vy
        if self.ball.left <= 0 or self.ball.right >= self.screen_width: self.ball_vx *= -1
        if self.ball.top <= 0: self.ball_vy *= -1
        terminated = self.ball.bottom >= self.screen_height
        reward = 0
        if self.player.colliderect(self.ball):
            reward = 10.0
            self.ball_vy *= -1
            self.ball.bottom = self.player.top
        elif terminated:
            reward = -10.0
        if self.render_mode == "human": self._render_frame()
        return self._get_obs(), reward, terminated, False, self._get_info()
                </code></pre>
                <h3 class="step-heading">Step 4: 시각화 및 종료 (`render`, `close`)</h3>
                <p>`render` 메서드는 Pygame을 이용해 현재 게임 상태를 화면에 그려줍니다. `close` 메서드는 게임 창을 닫아 리소스를 정리합니다.</p>
                <pre><button class="copy-button" onclick="copyCode(this)">Copy</button><code class="language-python">
# (PygameEnv 클래스 내부에 추가)
    def render(self):
        if self.render_mode == "rgb_array": return self._render_frame()
    def _render_frame(self):
        if self.window is None and self.render_mode == "human":
            pygame.init()
            pygame.display.init()
            self.window = pygame.display.set_mode((self.screen_width, self.screen_height))
        if self.clock is None and self.render_mode == "human": self.clock = pygame.time.Clock()
        canvas = pygame.Surface((self.screen_width, self.screen_height))
        canvas.fill((20, 20, 20))
        pygame.draw.rect(canvas, (200, 200, 200), self.player)
        pygame.draw.circle(canvas, (200, 50, 50), self.ball.center, self.ball.width / 2)
        if self.render_mode == "human":
            self.window.blit(canvas, canvas.get_rect())
            pygame.event.pump()
            pygame.display.update()
            self.clock.tick(self.metadata["render_fps"])
        else: return np.transpose(pygame.surfarray.array3d(canvas), axes=(1, 0, 2))
    def close(self):
        if self.window is not None: pygame.display.quit(); pygame.quit()
                </code></pre>
                <h3 class="step-heading">Step 5: 환경 등록</h3>
                <p>마지막으로, `gymnasium.envs.registration.register`를 사용하여 우리가 만든 환경을 Gymnasium에 등록합니다.</p>
                <pre><button class="copy-button" onclick="copyCode(this)">Copy</button><code class="language-python">
# (파일 최하단에 추가)
from gymnasium.envs.registration import register
register(
    id='PygameBreakout-v0',
    entry_point='my_pygame_env:PygameEnv',
    max_episode_steps=1000,
)
                </code></pre>
            </div>

            <div id="sb3-code" class="tab-content">
                <h2 class="text-2xl font-bold mb-4 text-gray-800">SB3로 에이전트 학습 (`train.py`)</h2>
                <p class="text-gray-700 mb-4">이제 Stable Baselines3를 사용하여 에이전트를 학습시킬 차례입니다. 각 단계별 코드의 의미를 자세히 살펴보세요.</p>
                <h3 class="step-heading">Step 1: 라이브러리 가져오기 및 환경 생성</h3>
                <p>필요한 라이브러리를 `import` 합니다. 특히 `import my_pygame_env`는 우리가 만든 환경을 Gymnasium에 등록하는 역할을 하므로 매우 중요합니다.</p>
                 <pre><button class="copy-button" onclick="copyCode(this)">Copy</button><code class="language-python">
import gymnasium as gym
from stable_baselines3 import PPO
import my_pygame_env # 중요: 이 라인이 환경을 등록합니다!
env = gym.make('PygameBreakout-v0', render_mode='rgb_array')
                </code></pre>
                <h3 class="step-heading">Step 2: 에이전트(모델) 생성</h3>
                <p>SB3가 제공하는 알고리즘 중 하나를 선택하여 모델을 생성합니다. 여기서는 PPO를 사용합니다.</p>
                <pre><button class="copy-button" onclick="copyCode(this)">Copy</button><code class="language-python">
model = PPO('MlpPolicy', env, verbose=1, tensorboard_log="./ppo_breakout_tensorboard/")
                </code></pre>
                <h3 class="step-heading">Step 3: 모델 학습 및 저장</h3>
                <p>`model.learn()` 함수를 호출하여 학습을 시작합니다. `total_timesteps`는 에이전트가 환경과 상호작용할 총 횟수를 의미합니다.</p>
                <pre><button class="copy-button" onclick="copyCode(this)">Copy</button><code class="language-python">
print("Starting training...")
model.learn(total_timesteps=50000)
print("Training finished!")
model.save("ppo_breakout")
print("Model saved.")
                </code></pre>
                <h3 class="step-heading">Step 4: 학습된 모델 평가</h3>
                <p>저장된 모델을 불러와 실제 게임 환경에서 어떻게 작동하는지 평가합니다. 평가 시에는 `render_mode='human'`으로 설정하여 게임 화면을 직접 볼 수 있습니다.</p>
                <pre><button class="copy-button" onclick="copyCode(this)">Copy</button><code class="language-python">
print("Starting evaluation...")
eval_env = gym.make('PygameBreakout-v0', render_mode='human')
obs, info = eval_env.reset()
for _ in range(1000):
    action, _states = model.predict(obs, deterministic=True)
    obs, reward, terminated, truncated, info = eval_env.step(action)
    if terminated or truncated:
        obs, info = eval_env.reset()
eval_env.close()
print("Evaluation finished.")
                </code></pre>
            </div>

            <div id="simulation" class="tab-content">
                <h2 class="text-2xl font-bold mb-4 text-gray-800">학습 결과 시뮬레이션</h2>
                <p class="text-gray-700 mb-4">학습된 에이전트가 어떻게 행동하는지 관찰해 보세요. 아래 시뮬레이션은 실제 학습 결과와 유사하게 제작되었습니다.</p>
                <div class="w-full max-w-sm mx-auto bg-gray-800 rounded-lg relative" style="height: 500px;">
                    <div id="paddle" class="absolute bg-white rounded" style="width: 60px; height: 10px; bottom: 30px; left: 170px;"></div>
                    <div id="ball" class="absolute bg-red-500 rounded-full" style="width: 10px; height: 10px; top: 250px; left: 195px;"></div>
                </div>
                <div class="mt-6 text-center"><button id="start-sim-btn" class="bg-indigo-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-indigo-700 transition" onclick="startSimulation()">시뮬레이션 시작</button></div>
                <div class="mt-4 bg-gray-100 p-4 rounded-lg"><h3 class="font-semibold mb-2">시뮬레이션 로그:</h3><div id="sim-log" class="text-sm text-gray-600 font-mono h-24 overflow-y-auto"></div></div>
            </div>

            <div id="env-guide" class="tab-content">
                <h2 class="text-2xl font-bold mb-4 text-gray-800">환경 코드 변경 시 학습 코드 수정 가이드</h2>
                <p class="text-gray-700 mb-4">Pygame 환경(<code class="inline-code">my_pygame_env.py</code>)을 수정하면, 에이전트를 학습시키는 코드(<code class="inline-code">train.py</code>)도 일부 변경해야 합니다. 주요 변경 사항에 따라 어떤 부분을 수정해야 하는지 알아봅시다.</p>

                <h3 class="step-heading">시나리오 1: 행동 공간 (Action Space) 변경</h3>
                <p>게임에 '정지' 행동을 추가하여 행동의 가짓수를 2개에서 3개로 늘리는 경우입니다.</p>
                <b>`my_pygame_env.py` 변경점:</b>
                <pre><code class="language-python">
# 기존: '좌', '우' 2가지 행동
self.action_space = spaces.Discrete(2)

# 변경: '좌', '우', '정지' 3가지 행동
self.action_space = spaces.Discrete(3)

# step 메서드에도 action == 2 (정지)에 대한 로직 추가 필요
...
def step(self, action):
    if action == 0: self.player.x -= 8
    elif action == 1: self.player.x += 8
    # action == 2 일 때는 아무것도 하지 않음 (정지)
...
                </code></pre>
                <b>`train.py` 변경점:</b>
                <p class="mt-2"><b>없음.</b> Stable Baselines3 모델은 환경을 생성할 때 <code class="inline-code">env.action_space</code>를 자동으로 읽어와 모델의 출력 크기를 결정하므로 코드를 수정할 필요가 없습니다.</p>

                <h3 class="step-heading">시나리오 2: 관측 공간 (Observation Space) 변경</h3>
                <p>상태 정보에 '플레이어와 공의 x좌표 거리'를 추가하여 관측값의 개수를 5개에서 6개로 늘리는 경우입니다.</p>
                <b>`my_pygame_env.py` 변경점:</b>
                <pre><code class="language-python">
# 관측 공간의 차원과 범위를 6개로 늘림
low = np.array([0, 0, 0, -10, -10, -self.screen_width], dtype=np.float32)
high = np.array([self.screen_width, self.screen_width, self.screen_height, 10, 10, self.screen_width], dtype=np.float32)
self.observation_space = spaces.Box(low, high, dtype=np.float32)

# _get_obs() 함수에서 새로운 관측값 추가
def _get_obs(self):
    dist_x = self.player.x - self.ball.x
    return np.array([self.player.x, self.ball.x, self.ball.y, self.ball_vx, self.ball_vy, dist_x], dtype=np.float32)
                </code></pre>
                <b>`train.py` 변경점:</b>
                <p class="mt-2"><b>없음.</b> 행동 공간과 마찬가지로, SB3는 <code class="inline-code">env.observation_space</code>를 자동으로 읽어 <code class="inline-code">MlpPolicy</code>의 입력 크기를 조정합니다.</p>
                <p class="mt-2 text-red-600 bg-red-50 p-3 rounded-lg"><b>※ 중요:</b> 만약 관측 공간을 숫자 벡터가 아닌 <b>이미지(픽셀)</b>로 바꾼다면, 정책 네트워크를 <code class="inline-code">MlpPolicy</code>에서 이미지 처리에 특화된 <code class="inline-code">CnnPolicy</code>로 변경해야 합니다.</p>
                <pre><code class="language-python"># train.py에서 정책 변경 예시
# model = PPO('MlpPolicy', env, ...)
model = PPO('CnnPolicy', env, ...)
                </code></pre>

                <h3 class="step-heading">시나리오 3: 환경 ID 변경</h3>
                <p>환경 등록 시 사용하는 ID를 변경하는 경우입니다. 이는 가장 흔하게 발생하는 실수 중 하나입니다.</p>
                <b>`my_pygame_env.py` 변경점:</b>
                <pre><code class="language-python">
register(
    id='MyAwesomeGame-v1', # ID 변경
    entry_point='my_pygame_env:PygameEnv',
    max_episode_steps=1000,
)
                </code></pre>
                <b>`train.py` 변경점:</b>
                <p class="mt-2">학습 코드의 <code class="inline-code">gym.make()</code> 함수에서 사용하는 ID를 <b>반드시 동일하게</b> 맞춰주어야 합니다. 그렇지 않으면 <code class="inline-code">EnvNotFound</code> 오류가 발생합니다.</p>
                 <pre><code class="language-python">
# 기존
# env = gym.make('PygameBreakout-v0', ...)

# 변경
env = gym.make('MyAwesomeGame-v1', ...)
                </code></pre>
            </div>
        </div>
    </div>

    <script>
        function openTab(evt, tabName) {
            let i, tabcontent, tablinks;
            tabcontent = document.getElementsByClassName("tab-content");
            for (i = 0; i < tabcontent.length; i++) { tabcontent[i].style.display = "none"; }
            tablinks = document.getElementsByClassName("tab-button");
            for (i = 0; i < tablinks.length; i++) { tablinks[i].className = tablinks[i].className.replace(" active", ""); }
            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " active";
        }

        function copyCode(button) {
            const pre = button.parentElement;
            const code = pre.querySelector('code');
            const text = code.innerText;
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                button.innerText = 'Copied!';
            } catch (err) {
                console.error('Failed to copy text: ', err);
                button.innerText = 'Failed!';
            }
            document.body.removeChild(textarea);
            setTimeout(() => { button.innerText = 'Copy'; }, 2000);
        }

        document.addEventListener("DOMContentLoaded", function() {
            try {
                renderMathInElement(document.body, {
                    delimiters: [ {left: "$$", right: "$$", display: true}, {left: "$", right: "$", display: false} ]
                });
            } catch (error) { console.error("KaTeX rendering failed:", error); }
        });
        
        const paddle = document.getElementById('paddle');
        const ball = document.getElementById('ball');
        const log = document.getElementById('sim-log');
        const startBtn = document.getElementById('start-sim-btn');
        let simInterval;
        let ballX = 195, ballY = 250;
        let ballVX = 2, ballVY = 2;
        let paddleX = 170;
        let score = 0;

        function logMessage(msg) {
            if(log) { log.innerHTML += msg + '<br>'; log.scrollTop = log.scrollHeight; }
        }

        function gameLoop() {
            const paddleCenter = paddleX + 30;
            const ballCenter = ballX + 5;
            let action = -1; 
            if (paddleCenter < ballCenter - 5) { paddleX += 3; action = 1; } 
            else if (paddleCenter > ballCenter + 5) { paddleX -= 3; action = 0; }
            paddleX = Math.max(0, Math.min(340, paddleX));
            if(paddle) paddle.style.left = paddleX + 'px';
            ballX += ballVX; ballY += ballVY;
            if (ballX <= 0 || ballX >= 390) ballVX *= -1;
            if (ballY <= 0) ballVY *= -1;
            let reward = 0;
            if (ballY >= 460 && ballY <= 470 && ballX > paddleX && ballX < paddleX + 60) {
                ballVY *= -1; ballY = 459; reward = 10; score += reward;
                logMessage(`[HIT] Action: ${action === 0 ? 'Left' : 'Right'}, Reward: ${reward}, Score: ${score}`);
            } else if (ballY >= 500) {
                reward = -10; score += reward;
                logMessage(`[MISS] Action: ${action === 0 ? 'Left' : 'Right'}, Reward: ${reward}, Score: ${score}. GAME OVER.`);
                clearInterval(simInterval);
                if(startBtn) { startBtn.disabled = false; startBtn.innerText = "다시 시작"; }
            }
            if(ball) { ball.style.left = ballX + 'px'; ball.style.top = ballY + 'px'; }
        }

        function startSimulation() {
            clearInterval(simInterval);
            if(log) log.innerHTML = '';
            score = 0;
            ballX = 195; ballY = 250;
            ballVX = (Math.random() > 0.5 ? 1 : -1) * 2;
            ballVY = 2;
            paddleX = 170;
            logMessage("Simulation Started...");
            if(startBtn) { startBtn.disabled = true; startBtn.innerText = "진행 중..."; }
            simInterval = setInterval(gameLoop, 1000 / 60);
        }
    </script>
</body>
</html>
