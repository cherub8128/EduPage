<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini AI 물리 게임 제작 가이드</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
        }
        .step {
            scroll-margin-top: 80px;
        }
        .prompt-block {
            position: relative;
        }
        .copy-button {
            position: absolute;
            top: 0.8rem;
            right: 0.8rem;
            background-color: #4A5568;
            color: white;
            padding: 0.25rem 0.6rem;
            border-radius: 0.375rem;
            font-size: 0.8rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .copy-button:hover {
            background-color: #2D3748;
        }
        .copy-button.copied {
            background-color: #2F855A;
        }
        .user-input {
            background-color: #FEF3C7; /* A soft yellow */
            border: 1px dashed #FBBF24; /* A dashed amber border */
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
        }
        .highlight-note {
            background-color: #E6FFFA;
            border-left: 4px solid #38B2AC;
            padding: 1rem;
            margin-top: 1rem;
            font-size: 0.9rem;
            color: #234E52;
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800">

    <div class="container mx-auto p-4 sm:p-6 md:p-8 max-w-4xl">
        <!-- Header -->
        <header class="text-center my-8 md:my-12">
            <h1 class="text-3xl sm:text-4xl md:text-5xl font-bold text-slate-900">Gemini AI 물리 게임 제작 가이드</h1>
            <p class="mt-4 text-base sm:text-lg text-slate-600">Pygame부터 JavaScript 배포까지, Gemini와 함께하는 AI 게임 개발 여정</p>
        </header>

        <!-- Step 1: Overview -->
        <section id="step1" class="step bg-white p-6 sm:p-8 rounded-2xl shadow-lg border border-slate-200 mb-10">
            <h2 class="text-2xl font-bold mb-4 border-b pb-3 text-slate-900">단계 1: 전체 프로세스 개요</h2>
            <p class="mb-6 text-slate-700">우리는 다음 7가지 단계를 거쳐 AI 물리 게임을 완성할 것입니다. 각 단계는 아이디어를 현실로 만드는 과정입니다.</p>
            <ol class="list-decimal list-inside space-y-3 text-slate-700">
                <li><strong class="font-semibold text-slate-800">Pygame 물리 게임 제작:</strong> 물리 로직이 적용된 미니멀하고 아름다운 2D 게임 제작</li>
                <li><strong class="font-semibold text-slate-800">Gymnasium 강화학습 환경 설계:</strong> 게임을 AI가 학습할 수 있는 표준 환경으로 변환</li>
                <li><strong class="font-semibold text-slate-800">SB3 모델 학습:</strong> Gymnasium 환경에서 강화학습 에이전트 학습 및 모델 저장</li>
                <li><strong class="font-semibold text-slate-800">ONNX 모델 변환:</strong> 학습된 모델을 웹 환경에 맞는 ONNX 형식으로 변환</li>
                <li><strong class="font-semibold text-slate-800">JavaScript 웹 게임 구현:</strong> ONNX 모델을 불러와 AI 플레이를 시각화하는 웹 게임 제작</li>
                <li><strong class="font-semibold text-slate-800">GitHub Pages 배포:</strong> 완성된 웹 게임을 전 세계에 무료로 배포</li>
            </ol>
        </section>

        <!-- Step 2: Pygame & Pure Python Physics -->
        <section id="step2" class="step bg-white p-6 sm:p-8 rounded-2xl shadow-lg border border-slate-200 mb-10">
            <h2 class="text-2xl font-bold mb-4 border-b pb-3 text-slate-900">단계 2: Pygame 물리 게임 제작 (순수 Python)</h2>
            <p class="mb-6 text-slate-700">먼저 만들고 싶은 게임의 아이디어를 구체화합니다. 아래 가이드를 참고하여 '게임 로직'을 작성한 뒤, 전체 프롬프트를 복사하여 Gemini에게 요청하세요.</p>
            
            <div class="user-input">
                <h3 class="font-semibold text-lg text-slate-800 mb-2">게임 로직 기획</h3>
                <p class="text-sm text-slate-600">아래 항목을 참고하여 만들고 싶은 게임의 핵심 규칙과 조작법을 자유롭게 서술하고, 프롬프트의 `[ ]` 안에 붙여넣으세요.</p>
                <ul class="list-disc list-inside mt-2 text-sm text-slate-700 space-y-1">
                    <li><strong>게임 콘셉트:</strong> (예: 우주선이 중력을 피해 장애물을 피하며 안전하게 착륙 지점에 도달해야 합니다.)</li>
                    <li><strong>플레이어 목표:</strong> (예: 최소한의 연료를 사용하여 가장 부드럽게 착륙하는 것이 목표입니다.)</li>
                    <li><strong>조작 방법:</strong> (예: 좌우 방향키로 좌우 추력기를, 위쪽 방향키로 메인 추력기를 작동시킵니다.)</li>
                    <li><strong>성공/실패 조건:</strong> (예: 착륙 지점에 일정 속도 이하로 접촉 시 성공, 그 외의 충돌이나 화면 이탈 시 실패입니다.)</li>
                </ul>
            </div>

            <div class="prompt-block">
                <button class="copy-button">복사</button>
                <pre class="bg-slate-100 text-slate-800 p-4 rounded-lg overflow-x-auto text-sm"><code class="language-text">You are an expert Python game developer specializing in visually stunning, minimalist games using Pygame.

Your task is to create a complete, single-file Python script for a 2D game with custom physics, based on the following requirements.

### Game Logic Plan
[여기에 위에서 기획한 게임 콘셉트, 목표, 조작 방법, 성공/실패 조건을 상세히 설명하세요.]

### Technical Requirements (Strict)
1.  **Python Version:** 3.12
2.  **Libraries:** `pygame` (latest)
3.  **Physics Implementation (VERY IMPORTANT):** Do NOT use any external physics libraries like Pymunk. You must implement the physics logic from scratch using pure Python. This includes:
    * **Movement:** Handling position, velocity, and acceleration.
    * **Gravity:** A constant downward force affecting relevant objects.
    * **Controls:** Applying forces or changing velocity based on user input (e.g., thrusters).
    * **Collision Detection:** Simple Axis-Aligned Bounding Box (AABB) collision detection between the player and other game elements.

### Visual Design (CRITICAL)
1.  **Aesthetics:** A minimalist, clean, retro-sci-fi aesthetic.
2.  **Color Palette:** Use a dark space-themed background (e.g., `#0a0f1e`) with glowing neon elements for the player and objects (e.g., player in `#00ffdd`, obstacles in `#ff0055`). Implement particle effects for thrusters.
3.  **Rendering:** All shapes must be drawn with anti-aliasing for smooth edges.
4.  **Window:** Create a window of size 800x600 pixels.

### Code Quality
* The code must be in a **single, runnable file**.
* It must be well-commented, especially the custom physics and game logic parts.
* Follow Python best practices (PEP 8) and use the latest library references to minimize bugs.</code></pre>
            </div>
        </section>

        <!-- Step 3: Gymnasium Env -->
        <section id="step3" class="step bg-white p-6 sm:p-8 rounded-2xl shadow-lg border border-slate-200 mb-10">
            <h2 class="text-2xl font-bold mb-4 border-b pb-3 text-slate-900">단계 3: Gymnasium 강화학습 환경 설계</h2>
            <p class="mb-6 text-slate-700">Pygame 코드를 AI가 학습할 수 있는 `Gymnasium` 환경으로 변환합니다. 아래 프롬프트는 Gemini가 게임 코드를 분석하여 최적의 RL 환경을 자동으로 설계하도록 지시합니다.</p>

            <div class="prompt-block">
                <button class="copy-button">복사</button>
                <pre class="bg-slate-100 text-slate-800 p-4 rounded-lg overflow-x-auto text-sm"><code class="language-text">You are an expert Reinforcement Learning Engineer specializing in creating custom Gymnasium environments.

I am attaching the Pygame game script (`game.py`). Your task is to analyze its code and create an optimal `gymnasium.Env` wrapper class for it. The final output must be a single Python file containing both the original game logic and the new environment class.

### Environment Design Requirements:

Based on your analysis of the `game.py` script, you must define and implement the following components. Provide a clear explanation for your design choices in the code comments.

1.  **Observation Space (`observation_space`):**
    * Analyze the game's state variables (e.g., positions, velocities, etc.) and propose a suitable `Box` observation space.
    * The space must contain all information necessary for an agent to make optimal decisions.
    * Normalize the observation values to a standard range (e.g., -1 to 1) for better training stability.

2.  **Action Space (`action_space`):**
    * Analyze the game's control scheme and define an appropriate `Discrete` action space.
    * Clearly map each discrete action to a specific game control (e.g., 0: do nothing, 1: fire main thruster).

3.  **Reward Function (CRITICAL & PRECISE):**
    * Design a sophisticated and precise reward function that encourages the agent to achieve the game's objective.
    * Your design should include:
        * **Shaping Rewards:** Small, continuous rewards for making incremental progress towards the goal.
        * **Terminal Rewards:** A large positive reward for winning and a large negative reward for losing.
        * **Efficiency Penalties:** Small penalties for inefficient actions (e.g., wasting fuel, time).

4.  **Implement Core Methods:**
    * Correctly implement `__init__()`, `reset()`, `step()`, `render()`, and `close()` according to the Gymnasium API, integrating your designed spaces and reward function.</code></pre>
            </div>
        </section>

        <!-- Step 4: SB3 Training -->
        <section id="step4" class="step bg-white p-6 sm:p-8 rounded-2xl shadow-lg border border-slate-200 mb-10">
            <h2 class="text-2xl font-bold mb-4 border-b pb-3 text-slate-900">단계 4: SB3로 모델 학습</h2>
            <p class="mb-6 text-slate-700">`Gymnasium` 환경을 사용하여 강화학습 에이전트를 학습시킵니다. 아래 프롬프트는 학습 과정 모니터링, 모델 저장, 이어서 학습하기 기능을 보장하는 간결한 학습 코드를 생성합니다.</p>
            
            <div class="user-input">
                <h3 class="font-semibold text-lg text-slate-800 mb-2">필요한 파일 정보</h3>
                <p class="text-sm text-slate-600">이 단계에서는 이전 단계에서 생성된 <code>environment.py</code> 파일이 필요합니다. 이 파일을 학습 스크립트를 실행할 위치와 같은 폴더에 저장하세요.</p>
            </div>

            <div class="prompt-block">
                <button class="copy-button">복사</button>
                <pre class="bg-slate-100 text-slate-800 p-4 rounded-lg overflow-x-auto text-sm"><code class="language-text">You are a Machine Learning Engineer with expertise in Stable Baselines3 (SB3).

Your task is to write a concise Python script (`train.py`) that trains a `PPO` agent on a custom Gymnasium environment.

The script will import the custom environment class (e.g., `GameEnv`) from a local file named `environment.py`.

### Training Script Requirements (Mandatory):

1.  **Environment Import:** Import the environment class from `environment.py`.
2.  **TensorBoard Logging:** Configure the `PPO` model to log training metrics (reward, loss, etc.) to a `tensorboard_logs/` directory.
3.  **Periodic Checkpoint Saving:** Use `CheckpointCallback` to save the model every 10,000 steps to a `checkpoints/` directory.
4.  **Resume from Checkpoint:** Implement logic to automatically check for the latest checkpoint in the `checkpoints/` directory. If a checkpoint exists, load it and continue training. Otherwise, start a new training session.
5.  **Training Loop:** Train the agent for 1,000,000 total timesteps.
6.  **Final Model:** Save the final trained model as `final_model.zip`.

The final code should be clean, efficient, and focus only on the training logic.</code></pre>
            </div>
        </section>

        <!-- Step 5: ONNX Conversion -->
        <section id="step5" class="step bg-white p-6 sm:p-8 rounded-2xl shadow-lg border border-slate-200 mb-10">
            <h2 class="text-2xl font-bold mb-4 border-b pb-3 text-slate-900">단계 5: ONNX 모델 변환</h2>
            <p class="mb-6 text-slate-700">학습된 SB3 모델(`.zip`)을 웹 브라우저에서 사용할 수 있는 ONNX 형식으로 변환합니다. 웹 AI 실행을 위한 필수 단계입니다.</p>
            <div class="prompt-block">
                <button class="copy-button">복사</button>
                <pre class="bg-slate-100 text-slate-800 p-4 rounded-lg overflow-x-auto text-sm"><code class="language-text">You are an expert in ML model deployment.

I am attaching the Python script (`environment.py`) which contains the Gymnasium environment definition, and the trained model (`final_model.zip`).

Your task is to write a new Python script that converts the attached `final_model.zip` into the ONNX format.

### Conversion Script Requirements:
1.  **Load SB3 Model:** Load `final_model.zip`.
2.  **Import Environment:** Import the environment class from `environment.py` and create an instance to access the `observation_space`.
3.  **Create Dummy Input:** Create a dummy observation tensor matching the shape and type of the environment's `observation_space`.
4.  **Export to ONNX:** Use `torch.onnx.export()` to convert the model, saving it as `model.onnx`.
    * `input_names`: `['observation']`
    * `output_names`: `['action']`
    * `opset_version`: 12
5.  **Verification:** Add a section to verify the `model.onnx` using `onnxruntime` in Python. Run inference with the dummy input and print the result to confirm it works.</code></pre>
            </div>
        </section>
        
        <!-- Step 6: JavaScript Game -->
        <section id="step6" class="step bg-white p-6 sm:p-8 rounded-2xl shadow-lg border border-slate-200 mb-10">
            <h2 class="text-2xl font-bold mb-4 border-b pb-3 text-slate-900">단계 6: JavaScript 웹 게임 구현</h2>
            <p class="mb-6 text-slate-700">AI의 플레이를 직접 볼 수 있는 웹 페이지를 만듭니다. Python 게임의 시각적 디자인을 재현하고, `onnxruntime-web`을 사용해 AI 모델을 실행합니다.</p>
            
             <div class="user-input">
                <h3 class="font-semibold text-lg text-slate-800 mb-2">필요한 파일 및 정보</h3>
                <p class="text-sm text-slate-600">이 단계에서는 이전 단계에서 생성된 <code>model.onnx</code> 파일과, 3단계에서 Gemini가 정의한 관측 공간의 구조에 대한 정보가 필요합니다.</p>
            </div>

            <div class="prompt-block">
                <button class="copy-button">복사</button>
                <pre class="bg-slate-100 text-slate-800 p-4 rounded-lg overflow-x-auto text-sm"><code class="language-text">You are a senior front-end developer skilled in JavaScript, HTML5 Canvas, and AI model integration.

Your task is to create a **single, self-contained `index.html` file** that loads a local `model.onnx` file to power an AI agent.

### Reference Information
* **Game Visuals:** Replicate the minimalist, retro-sci-fi aesthetic from the Python game (dark background, glowing neon objects, particles).
* **Observation Space Structure:** [여기에 단계 3에서 Gemini가 정의한 관측 공간의 구조와 순서를 정확히 붙여넣으세요. (예: `[pos_x, pos_y, vel_x, vel_y, angle, ang_vel, dist_to_pad]`)]

### Requirements:

1.  **Game Replication:** Recreate the game's core mechanics and visuals using HTML5 Canvas and plain JavaScript. Do not use a physics library.
2.  **Visual Design (CRITICAL):** The design must be exceptionally clean, minimalist, and visually appealing. Center the canvas and use `requestAnimationFrame` for smooth animations. Add a subtle loading indicator for the ONNX model.
3.  **AI Integration with onnxruntime-web:**
    * Include `onnxruntime-web` via CDN.
    * Asynchronously load the local `model.onnx`.
    * In the game loop:
        1.  Get the current game state and create a normalized `Float32Array` observation that **exactly matches the structure and order of the Python environment's observation space.** This is critical.
        2.  Create an `ort.Tensor` and run inference.
        3.  Extract the action with the highest probability from the model's output (using an argmax function).
        4.  Apply the action to the game.
4.  **Self-Critique:** Before finishing, review your own code for potential bugs, especially in the state normalization and model inference steps, to ensure the game runs smoothly.</code></pre>
            </div>
        </section>

        <!-- Step 7: GitHub Pages -->
        <section id="step7" class="step bg-white p-6 sm:p-8 rounded-2xl shadow-lg border border-slate-200 mb-10">
            <h2 class="text-2xl font-bold mb-4 border-b pb-3 text-slate-900">단계 7: GitHub Pages로 웹에 배포하기</h2>
            <p class="mb-6 text-slate-700">완성된 AI 웹 게임(`index.html`, `model.onnx`)을 GitHub Pages를 통해 무료로 배포하는 가장 간단한 방법입니다.</p>
            <div class="space-y-4 text-slate-700">
                <div>
                    <h3 class="font-semibold text-lg text-slate-800">1. GitHub 저장소 생성</h3>
                    <p class="mt-1 ml-2">GitHub에 로그인 후, 'New repository'를 클릭하여 저장소를 'Public'으로 생성합니다.</p>
                </div>
                <div>
                    <h3 class="font-semibold text-lg text-slate-800">2. 파일 업로드</h3>
                    <p class="mt-1 ml-2">생성된 저장소에서 'Add file' &rarr; 'Upload files'를 클릭하여 `index.html`과 `model.onnx` 파일을 업로드합니다.</p>
                </div>
                <div>
                    <h3 class="font-semibold text-lg text-slate-800">3. GitHub Pages 활성화</h3>
                    <p class="mt-1 ml-2">저장소 'Settings' &rarr; 'Pages' 탭으로 이동하여 'Source'를 'Deploy from a branch'로, 브랜치를 'main'으로 선택하고 저장합니다.</p>
                </div>
                <div>
                    <h3 class="font-semibold text-lg text-slate-800">4. 배포 확인 및 공유</h3>
                    <p class="mt-1 ml-2">잠시 후 나타나는 `https://&lt;사용자명&gt;.github.io/&lt;저장소명&gt;/` 주소로 접속하여 게임을 확인하고 공유합니다.</p>
                </div>
            </div>
        </section>

        <!-- Step 8: Conclusion -->
        <section id="step8" class="step bg-white p-6 sm:p-8 rounded-2xl shadow-lg border border-slate-200 mb-10">
            <h2 class="text-2xl font-bold mb-4 border-b pb-3 text-slate-900">마치며</h2>
            <p class="mb-6 text-slate-700">축하합니다! 이 가이드의 프롬프트를 따라 Gemini와 함께 아이디어를 구체화하고, 파이썬으로 게임과 AI를 개발한 뒤, 최종적으로는 전 세계와 공유할 수 있는 인터랙티브 웹 애플리케이션까지 완성하셨습니다.</p>
            <h3 class="font-semibold text-lg text-slate-800 mb-2">이제 여러분의 차례입니다:</h3>
            <ul class="list-disc list-inside space-y-2 text-slate-700">
                <li><strong>게임 아이디어 확장:</strong> 게임에 새로운 규칙, 장애물, 또는 더 어려운 단계를 추가하여 발전시켜 보세요.</li>
                <li><strong>보상 함수 실험:</strong> 다른 보상 체계를 설계하여 AI의 행동 패턴이 어떻게 바뀌는지 관찰해보세요.</li>
                <li><strong>모델 아키텍처 변경:</strong> SB3에서 다른 알고リズム(예: DQN)을 사용하거나 신경망의 크기를 조절해보세요.</li>
            </ul>
            <p class="mt-6 text-center text-slate-600 font-medium">이 프로세스는 다양한 프로젝트에 적용할 수 있는 강력한 파이프라인입니다. 즐겁게 실험하고 창조하세요!</p>
        </section>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const copyButtons = document.querySelectorAll('.copy-button');

            copyButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const codeBlock = button.nextElementSibling.querySelector('code');
                    const codeText = codeBlock.innerText;

                    // Create a temporary textarea element to hold the text
                    const textArea = document.createElement('textarea');
                    textArea.value = codeText;
                    document.body.appendChild(textArea);
                    textArea.select();

                    try {
                        const successful = document.execCommand('copy');
                        if (successful) {
                            button.textContent = '복사 완료!';
                            button.classList.add('copied');

                            setTimeout(() => {
                                button.textContent = '복사';
                                button.classList.remove('copied');
                            }, 2000);
                        } else {
                            console.error('Fallback: Failed to copy text.');
                        }
                    } catch (err) {
                        console.error('Fallback: Error copying text: ', err);
                    }

                    document.body.removeChild(textArea);
                });
            });
        });
    </script>
</body>
</html>

