<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini AI 물리 게임 제작 가이드</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
        }
        .step {
            scroll-margin-top: 80px;
        }
        .prompt-block {
            position: relative;
        }
        .copy-button {
            position: absolute;
            top: 0.8rem;
            right: 0.8rem;
            background-color: #4A5568;
            color: white;
            padding: 0.25rem 0.6rem;
            border-radius: 0.375rem;
            font-size: 0.8rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .copy-button:hover {
            background-color: #2D3748;
        }
        .copy-button.copied {
            background-color: #2F855A;
        }
        .user-input {
            background-color: #FEF3C7; /* A soft yellow */
            border: 1px dashed #FBBF24; /* A dashed amber border */
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
        }
        .highlight-note {
            background-color: #E6FFFA;
            border-left: 4px solid #38B2AC;
            padding: 1rem;
            margin-top: 1rem;
            font-size: 0.9rem;
            color: #234E52;
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800">

    <div class="container mx-auto p-4 sm:p-6 md:p-8 max-w-4xl">
        <!-- Header -->
        <header class="text-center my-8 md:my-12">
            <h1 class="text-3xl sm:text-4xl md:text-5xl font-bold text-slate-900">Gemini AI 물리 게임 제작 가이드</h1>
            <p class="mt-4 text-base sm:text-lg text-slate-600">Pygame부터 JavaScript 배포까지, Gemini와 함께하는 AI 게임 개발 여정</p>
        </header>

        <!-- Step 1: Overview -->
        <section id="step1" class="step bg-white p-6 sm:p-8 rounded-2xl shadow-lg border border-slate-200 mb-10">
            <h2 class="text-2xl font-bold mb-4 border-b pb-3 text-slate-900">단계 1: 전체 프로세스 개요</h2>
            <p class="mb-6 text-slate-700">우리는 다음 8가지 단계를 거쳐 AI 물리 게임을 완성할 것입니다. 각 단계는 아이디어를 현실로 만드는 과정입니다.</p>
            <ol class="list-decimal list-inside space-y-3 text-slate-700">
                <li><strong class="font-semibold text-slate-800">Pygame 물리 게임 제작:</strong> 물리 로직이 적용된 미니멀하고 아름다운 2D 게임 제작</li>
                <li><strong class="font-semibold text-slate-800">Gymnasium 강화학습 환경 설계:</strong> 게임을 AI가 학습할 수 있는 표준 환경으로 변환</li>
                <li><strong class="font-semibold text-slate-800">SB3 모델 학습:</strong> Gymnasium 환경에서 강화학습 에이전트 학습</li>
                <li><strong class="font-semibold text-slate-800">학습된 모델 테스트:</strong> Pygame 환경에서 학습된 에이전트의 성능 시각화</li>
                <li><strong class="font-semibold text-slate-800">ONNX 모델 변환:</strong> 학습된 모델을 웹 환경에 맞는 ONNX 형식으로 변환</li>
                <li><strong class="font-semibold text-slate-800">JavaScript 웹 게임 구현:</strong> ONNX 모델을 불러와 AI 플레이를 시각화하는 웹 게임 제작</li>
                <li><strong class="font-semibold text-slate-800">GitHub Pages 배포:</strong> 완성된 웹 게임을 전 세계에 무료로 배포</li>
            </ol>
        </section>

        <!-- Step 2: Pygame & Pure Python Physics -->
        <section id="step2" class="step bg-white p-6 sm:p-8 rounded-2xl shadow-lg border border-slate-200 mb-10">
            <h2 class="text-2xl font-bold mb-4 border-b pb-3 text-slate-900">단계 2: Pygame 물리 게임 제작 (순수 Python)</h2>
            <p class="mb-6 text-slate-700">먼저 만들고 싶은 게임의 아이디어를 구체화합니다. 아래 가이드를 참고하여 '게임 로직'을 작성한 뒤, 전체 프롬프트를 복사하여 Gemini에게 요청하세요.</p>
            
            <div class="user-input">
                <h3 class="font-semibold text-lg text-slate-800 mb-2">게임 로직 기획</h3>
                <p class="text-sm text-slate-600">아래 항목을 참고하여 만들고 싶은 게임의 핵심 규칙과 조작법을 자유롭게 서술하고, 프롬프트의 `[ ]` 안에 붙여넣으세요.</p>
                <ul class="list-disc list-inside mt-2 text-sm text-slate-700 space-y-1">
                    <li><strong>게임 콘셉트:</strong> (예: 우주선이 중력을 피해 장애물을 피하며 안전하게 착륙 지점에 도달해야 합니다.)</li>
                    <li><strong>플레이어 목표:</strong> (예: 최소한의 연료를 사용하여 가장 부드럽게 착륙하는 것이 목표입니다.)</li>
                    <li><strong>조작 방법:</strong> (예: 좌우 방향키로 좌우 추력기를, 위쪽 방향키로 메인 추력기를 작동시킵니다.)</li>
                    <li><strong>성공/실패 조건:</strong> (예: 착륙 지점에 일정 속도 이하로 접촉 시 성공, 그 외의 충돌이나 화면 이탈 시 실패입니다.)</li>
                </ul>
            </div>

            <div class="prompt-block">
                <button class="copy-button">복사</button>
                <pre class="bg-slate-100 text-slate-800 p-4 rounded-lg overflow-x-auto text-sm"><code class="language-text">You are an expert Python game developer and a digital artist, specializing in creating visually stunning, minimalist games with Pygame.

Your task is to create a complete, single-file Python script for a 2D game. This isn't just a game; it's a piece of interactive art.

### Game Logic Plan
[여기에 위에서 기획한 게임 콘셉트, 목표, 조작 방법, 성공/실패 조건을 상세히 설명하세요.]

### Technical Requirements (Strict)
1.  **Python Version:** 3.12
2.  **Libraries:** `pygame` (latest)
3.  **Physics Implementation (VERY IMPORTANT):** Do NOT use any external physics libraries. Implement all physics from scratch using pure Python, including movement (position, velocity, acceleration), gravity, controls, and simple AABB collision detection.

### Visual Design (CRITICAL - Emulate a Top Digital Artist)
1.  **Aesthetics:** The game must be a piece of interactive art. Aim for a minimalist, elegant, and atmospheric retro-sci-fi aesthetic. Think of games like 'Alto's Adventure' or 'Monument Valley' but in a space context. Every frame should be beautiful enough to be a screenshot.
2.  **Color Palette & Lighting:** Use a deep, nuanced color palette. Instead of a flat black background, use a dark navy or purple gradient (e.g., from `#0a0f1e` to `#1a1f36`) to create depth. Player and interactive elements should have a vibrant, ethereal glow (e.g., a pulsating cyan `#00ffdd` for the player, a menacing magenta `#ff0055` for hazards). The glow should feel like light, not just a colored shape.
3.  **Rendering & Effects:**
    * **Anti-aliasing:** This is mandatory for all shapes to ensure silky-smooth edges.
    * **Particle System:** Implement a sophisticated particle system for the thrusters. The particles should be small, fade out gracefully, and have slight color and velocity variations to look organic.
    * **Subtle Background Animation:** Add a very slow-moving parallax starfield in the background to create a sense of movement without being distracting. A few stars should twinkle subtly.
4.  **Typography & UI:** Any text (like a "Game Over" screen) should use a clean, modern, sans-serif font. Keep UI elements to an absolute minimum.
5.  **Window:** Create a window of size 800x600 pixels.

### Code Quality
* The code must be in a **single, runnable file**, be well-commented, and follow Python best practices.</code></pre>
            </div>
            <div class="user-input mt-6">
                <h3 class="font-semibold text-lg text-slate-800 mb-2">다음 단계 준비</h3>
                <p class="text-sm text-slate-600">Gemini가 생성한 Python 코드를 <code class="bg-amber-200 px-1 rounded">game.py</code> 라는 이름으로 저장하세요. 이 파일은 다음 단계에서 사용됩니다.</p>
            </div>
        </section>

        <!-- Step 3: Gymnasium Env -->
        <section id="step3" class="step bg-white p-6 sm:p-8 rounded-2xl shadow-lg border border-slate-200 mb-10">
            <h2 class="text-2xl font-bold mb-4 border-b pb-3 text-slate-900">단계 3: Gymnasium 강화학습 환경 설계</h2>
            <p class="mb-6 text-slate-700">Pygame 코드를 AI가 학습할 수 있는 `Gymnasium` 환경으로 변환합니다. 아래 프롬프트는 Gemini가 게임 코드를 분석하여 최적의 RL 환경을 자동으로 설계하도록 지시합니다.</p>
            
            <div class="user-input">
                <h3 class="font-semibold text-lg text-slate-800 mb-2">필요한 파일 정보</h3>
                <p class="text-sm text-slate-600">이 단계에서는 이전 단계에서 생성한 <code>game.py</code> 파일이 필요합니다. 이 파일을 첨부하여 아래 프롬프트를 실행하세요.</p>
            </div>

            <div class="prompt-block">
                <button class="copy-button">복사</button>
                <pre class="bg-slate-100 text-slate-800 p-4 rounded-lg overflow-x-auto text-sm"><code class="language-text">You are an expert Reinforcement Learning Engineer specializing in creating custom Gymnasium environments.

I am attaching the Pygame game script (`game.py`). Your task is to analyze its code and create an optimal `gymnasium.Env` wrapper class for it. The final output must be a single Python file containing both the original game logic and the new environment class.

### Environment Design Requirements:

Based on your analysis of the `game.py` script, you must define and implement the following components. Provide a clear explanation for your design choices in the code comments.

1.  **Observation Space (`observation_space`):**
    * Analyze the game's state variables (e.g., positions, velocities, etc.) and propose a suitable `Box` observation space.
    * The space must contain all information necessary for an agent to make optimal decisions.
    * Normalize the observation values to a standard range (e.g., -1 to 1) for better training stability.

2.  **Action Space (`action_space`):**
    * Analyze the game's control scheme and define an appropriate `Discrete` action space.
    * Clearly map each discrete action to a specific game control (e.g., 0: do nothing, 1: fire main thruster).

3.  **Reward Function (CRITICAL & PRECISE):**
    * Design a sophisticated and precise reward function that encourages the agent to achieve the game's objective.
    * Your design should include:
        * **Shaping Rewards:** Small, continuous rewards for making incremental progress towards the goal.
        * **Terminal Rewards:** A large positive reward for winning and a large negative reward for losing.
        * **Efficiency Penalties:** Small penalties for inefficient actions (e.g., wasting fuel, time).

4.  **Implement Core Methods:**
    * Correctly implement `__init__()`, `reset()`, `step()`, `render()`, and `close()` according to the Gymnasium API, integrating your designed spaces and reward function.</code></pre>
            </div>
            <div class="user-input mt-6">
                <h3 class="font-semibold text-lg text-slate-800 mb-2">다음 단계 준비</h3>
                <p class="text-sm text-slate-600">생성된 강화학습 환경 코드를 <code class="bg-amber-200 px-1 rounded">environment.py</code> 라는 이름으로 저장하세요. 이 파일은 모델 학습 및 변환에 사용됩니다.</p>
            </div>
        </section>

        <!-- Step 4: SB3 Training -->
        <section id="step4" class="step bg-white p-6 sm:p-8 rounded-2xl shadow-lg border border-slate-200 mb-10">
            <h2 class="text-2xl font-bold mb-4 border-b pb-3 text-slate-900">단계 4: SB3로 모델 학습</h2>
            <p class="mb-6 text-slate-700">`Gymnasium` 환경을 사용하여 강화학습 에이전트를 학습시킵니다. 아래 프롬프트는 학습 과정 모니터링, 모델 저장, 이어서 학습하기 기능을 보장하는 간결한 학습 코드를 생성합니다.</p>
            
            <div class="user-input">
                <h3 class="font-semibold text-lg text-slate-800 mb-2">파일 준비 및 실행 안내</h3>
                <p class="text-sm text-slate-600">이전 단계에서 생성된 <code>environment.py</code> 파일을 준비하세요.</p>
                <p class="text-sm text-slate-600 mt-2">아래 프롬프트로 생성된 코드를 <code class="bg-amber-200 px-1 rounded">train.py</code>로 저장하고, <code class="bg-amber-200 px-1 rounded">environment.py</code>와 같은 폴더에 넣은 후 터미널에서 <code class="bg-amber-200 px-1 rounded">python train.py</code> 명령어로 실행하여 학습을 시작하세요.</p>
            </div>

            <div class="prompt-block">
                <button class="copy-button">복사</button>
                <pre class="bg-slate-100 text-slate-800 p-4 rounded-lg overflow-x-auto text-sm"><code class="language-text">You are a Machine Learning Engineer with expertise in Stable Baselines3 (SB3).

Your task is to write a concise Python script (`train.py`) that trains a `PPO` agent on a custom Gymnasium environment.

The script will import the custom environment class (e.g., `GameEnv`) from a local file named `environment.py`.

### Training Script Requirements (Mandatory):

1.  **Environment Import:** Import the environment class from `environment.py`.
2.  **TensorBoard Logging:** Configure the `PPO` model to log training metrics (reward, loss, etc.) to a `tensorboard_logs/` directory.
3.  **Periodic Checkpoint Saving:** Use `CheckpointCallback` to save the model every 10,000 steps to a `checkpoints/` directory.
4.  **Resume from Checkpoint:** Implement logic to automatically check for the latest checkpoint in the `checkpoints/` directory. If a checkpoint exists, load it and continue training. Otherwise, start a new training session.
5.  **Training Loop:** Train the agent for 1,000,000 total timesteps.
6.  **Final Model:** Save the final trained model as `final_model.zip`.

The final code should be clean, efficient, and focus only on the training logic.</code></pre>
            </div>
        </section>

        <!-- Step 5: Test Trained Model -->
        <section id="step5" class="step bg-white p-6 sm:p-8 rounded-2xl shadow-lg border border-slate-200 mb-10">
            <h2 class="text-2xl font-bold mb-4 border-b pb-3 text-slate-900">단계 5: 학습된 모델 테스트</h2>
            <p class="mb-6 text-slate-700">TensorBoard의 수치만으로는 모델의 실제 성능을 파악하기 어렵습니다. 학습된 에이전트가 Pygame 환경에서 어떻게 행동하는지 직접 눈으로 확인합니다.</p>
            
            <div class="user-input">
                <h3 class="font-semibold text-lg text-slate-800 mb-2">파일 준비 및 실행 안내</h3>
                <p class="text-sm text-slate-600">이 단계에서는 <code>environment.py</code> (3단계 산출물)와 학습을 통해 생성된 <code>final_model.zip</code> (4단계 산출물) 파일이 필요합니다.</p>
                <p class="text-sm text-slate-600 mt-2">아래 프롬프트로 생성된 코드를 <code class="bg-amber-200 px-1 rounded">test_model.py</code>로 저장하고, 필요한 파일들과 같은 폴더에 넣은 후 터미널에서 <code class="bg-amber-200 px-1 rounded">python test_model.py</code> 명령어로 실행하여 테스트를 시작하세요.</p>
            </div>

            <div class="prompt-block">
                <button class="copy-button">복사</button>
                <pre class="bg-slate-100 text-slate-800 p-4 rounded-lg overflow-x-auto text-sm"><code class="language-text">You are an ML Engineer who needs to visually verify a trained agent's performance.

Your task is to write a Python script (`test_model.py`) to load a trained Stable Baselines3 model and run it in its custom Gymnasium environment for visual inspection.

### Script Requirements:

1.  **Import Environment:** Import the custom environment class (e.g., `GameEnv`) from the local file `environment.py`.
2.  **Load Model:** Load the pre-trained `PPO` agent from `final_model.zip`.
3.  **Evaluation Loop:**
    * Run the agent for 10 separate episodes.
    * For each episode:
        * Reset the environment.
        * Loop until the episode is done (`terminated` or `truncated`).
        * In the loop, use the model to predict the action from the current observation.
        * Pass the action to the environment's `step` method.
        * Call the environment's `render` method to display the game window.
    * Print the total reward for each episode to the console.
4.  **Cleanup:** Close the environment properly after the loop finishes.</code></pre>
            </div>
        </section>

        <!-- Step 6: ONNX Conversion -->
        <section id="step6" class="step bg-white p-6 sm:p-8 rounded-2xl shadow-lg border border-slate-200 mb-10">
            <h2 class="text-2xl font-bold mb-4 border-b pb-3 text-slate-900">단계 6: ONNX 모델 변환</h2>
            <p class="mb-6 text-slate-700">학습된 SB3 모델(`.zip`)을 웹 브라우저에서 사용할 수 있는 ONNX 형식으로 변환합니다. 웹 AI 실행을 위한 필수 단계입니다.</p>
            
            <div class="user-input">
                <h3 class="font-semibold text-lg text-slate-800 mb-2">필요한 파일 정보</h3>
                <p class="text-sm text-slate-600">이 단계에서는 <code>environment.py</code>와 <code>final_model.zip</code> 파일이 필요합니다. 이 두 파일을 첨부하여 아래 프롬프트를 실행하세요.</p>
            </div>

            <div class="prompt-block">
                <button class="copy-button">복사</button>
                <pre class="bg-slate-100 text-slate-800 p-4 rounded-lg overflow-x-auto text-sm"><code class="language-text">You are an expert in ML model deployment.

I am attaching the Python script (`environment.py`) which contains the Gymnasium environment definition, and the trained model (`final_model.zip`).

Your task is to write a new Python script that converts the attached `final_model.zip` into the ONNX format.

### Conversion Script Requirements:
1.  **Load SB3 Model:** Load `final_model.zip`.
2.  **Import Environment:** Import the environment class from `environment.py` and create an instance to access the `observation_space`.
3.  **Create Dummy Input:** Create a dummy observation tensor matching the shape and type of the environment's `observation_space`.
4.  **Export to ONNX:** Use `torch.onnx.export()` to convert the model, saving it as `model.onnx`.
    * `input_names`: `['observation']`
    * `output_names`: `['action']`
    * `opset_version`: 12
5.  **Verification:** Add a section to verify the `model.onnx` using `onnxruntime` in Python. Run inference with the dummy input and print the result to confirm it works.</code></pre>
            </div>

            <div class="user-input mt-6">
                <h3 class="font-semibold text-lg text-slate-800 mb-2">실행 및 다음 단계 준비</h3>
                <p class="text-sm text-slate-600">생성된 변환 코드를 <code class="bg-amber-200 px-1 rounded">convert_onnx.py</code>로 저장하세요. 이 파일을 <code>environment.py</code> 및 <code>final_model.zip</code>과 같은 폴더에 위치시킨 후, 터미널에서 <code class="bg-amber-200 px-1 rounded">python convert_onnx.py</code>를 실행하면 최종 산출물인 <code class="bg-amber-200 px-1 rounded">model.onnx</code> 파일이 생성됩니다.</p>
            </div>
        </section>
        
        <!-- Step 7: JavaScript Game -->
        <section id="step7" class="step bg-white p-6 sm:p-8 rounded-2xl shadow-lg border border-slate-200 mb-10">
            <h2 class="text-2xl font-bold mb-4 border-b pb-3 text-slate-900">단계 7: JavaScript 웹 게임 구현</h2>
            <p class="mb-6 text-slate-700">AI의 플레이를 직접 볼 수 있는 웹 페이지를 만듭니다. Python 게임의 시각적 디자인을 재현하고, `onnxruntime-web`을 사용해 AI 모델을 실행합니다.</p>
            
             <div class="user-input">
                <h3 class="font-semibold text-lg text-slate-800 mb-2">파일 준비 및 실행 안내</h3>
                <p class="text-sm text-slate-600">이전 단계에서 생성된 <code>model.onnx</code> 파일을 준비하세요.</p>
                <p class="text-sm text-slate-600 mt-2">아래 프롬프트로 생성된 코드를 <code class="bg-amber-200 px-1 rounded">index.html</code> 파일로 저장하고, <code class="bg-amber-200 px-1 rounded">model.onnx</code> 파일과 같은 폴더에 위치시키세요. 그 후 <code class="bg-amber-200 px-1 rounded">index.html</code> 파일을 웹 브라우저에서 열면 AI 게임을 확인할 수 있습니다.</p>
            </div>

            <div class="prompt-block">
                <button class="copy-button">복사</button>
                <pre class="bg-slate-100 text-slate-800 p-4 rounded-lg overflow-x-auto text-sm"><code class="language-text">You are a senior front-end developer and digital artist, skilled in JavaScript, HTML5 Canvas, and AI model integration.

Your task is to create a **single, self-contained `index.html` file** that is a visually stunning, minimalist web game powered by a local `model.onnx` file.

### Reference Information
* **Artistic Vision:** Your primary goal is to replicate the artistic vision of the Python game: an elegant, minimalist, and atmospheric retro-sci-fi aesthetic. It must feel like interactive art.
* **Observation Space Structure:** [여기에 단계 3에서 Gemini가 정의한 관측 공간의 구조와 순서를 정확히 붙여넣으세요. (예: `[pos_x, pos_y, vel_x, vel_y, angle, ang_vel, dist_to_pad]`)]

### Requirements:

1.  **Game Replication:** Recreate the game's core mechanics and visuals using HTML5 Canvas and plain JavaScript. Do not use a physics library.
2.  **Visual Design (CRITICAL - Emulate a Top Digital Artist):**
    * The final product must be visually stunning, clean, and minimalist. Center the canvas perfectly.
    * Replicate the sophisticated visual effects from the Python version: the deep gradient background, the ethereal glow of objects, the organic particle system for thrusters, and the subtle parallax starfield.
    * Animations must be fluid and smooth, powered by `requestAnimationFrame`.
    * Implement a clean, non-intrusive loading indicator (e.g., a pulsating dot) while the ONNX model loads.
3.  **AI Integration with onnxruntime-web:**
    * Include `onnxruntime-web` via CDN.
    * Asynchronously load the local `model.onnx`.
    * In the game loop:
        1.  Get the current game state and create a normalized `Float32Array` observation that **exactly matches the structure and order of the Python environment's observation space.** This is critical.
        2.  Create an `ort.Tensor` and run inference.
        3.  Extract the action with the highest probability from the model's output (using an argmax function).
        4.  Apply the action to the game.
4.  **Self-Critique:** Before finishing, review your own code for potential bugs, especially in state normalization and model inference steps, to ensure the game runs smoothly.</code></pre>
            </div>
        </section>

        <!-- Step 8: GitHub Pages -->
        <section id="step8" class="step bg-white p-6 sm:p-8 rounded-2xl shadow-lg border border-slate-200 mb-10">
            <h2 class="text-2xl font-bold mb-4 border-b pb-3 text-slate-900">단계 8: GitHub Pages로 웹에 배포하기</h2>
            <p class="mb-6 text-slate-700">완성된 AI 웹 게임(`index.html`, `model.onnx`)을 GitHub Pages를 통해 무료로 배포하는 가장 간단한 방법입니다.</p>
            <div class="space-y-4 text-slate-700">
                <div>
                    <h3 class="font-semibold text-lg text-slate-800">1. GitHub 저장소 생성</h3>
                    <p class="mt-1 ml-2">GitHub에 로그인 후, 'New repository'를 클릭하여 저장소를 'Public'으로 생성합니다.</p>
                </div>
                <div>
                    <h3 class="font-semibold text-lg text-slate-800">2. 파일 업로드</h3>
                    <p class="mt-1 ml-2">생성된 저장소에서 'Add file' &rarr; 'Upload files'를 클릭하여 `index.html`과 `model.onnx` 파일을 업로드합니다.</p>
                </div>
                <div>
                    <h3 class="font-semibold text-lg text-slate-800">3. GitHub Pages 활성화</h3>
                    <p class="mt-1 ml-2">저장소 'Settings' &rarr; 'Pages' 탭으로 이동하여 'Source'를 'Deploy from a branch'로, 브랜치를 'main'으로 선택하고 저장합니다.</p>
                </div>
                <div>
                    <h3 class="font-semibold text-lg text-slate-800">4. 배포 확인 및 공유</h3>
                    <p class="mt-1 ml-2">잠시 후 나타나는 `https://&lt;사용자명&gt;.github.io/&lt;저장소명&gt;/` 주소로 접속하여 게임을 확인하고 공유합니다.</p>
                </div>
            </div>
        </section>

        <!-- Step 9: Conclusion -->
        <section id="step9" class="step bg-white p-6 sm:p-8 rounded-2xl shadow-lg border border-slate-200 mb-10">
            <h2 class="text-2xl font-bold mb-4 border-b pb-3 text-slate-900">마치며</h2>
            <p class="mb-6 text-slate-700">축하합니다! 이 가이드의 프롬프트를 따라 Gemini와 함께 아이디어를 구체화하고, 파이썬으로 게임과 AI를 개발한 뒤, 최종적으로는 전 세계와 공유할 수 있는 인터랙티브 웹 애플리케이션까지 완성하셨습니다.</p>
            <h3 class="font-semibold text-lg text-slate-800 mb-2">이제 여러분의 차례입니다:</h3>
            <ul class="list-disc list-inside space-y-2 text-slate-700">
                <li><strong>게임 아이디어 확장:</strong> 게임에 새로운 규칙, 장애물, 또는 더 어려운 단계를 추가하여 발전시켜 보세요.</li>
                <li><strong>보상 함수 실험:</strong> 다른 보상 체계를 설계하여 AI의 행동 패턴이 어떻게 바뀌는지 관찰해보세요.</li>
                <li><strong>모델 아키텍처 변경:</strong> SB3에서 다른 알고リズム(예: DQN)을 사용하거나 신경망의 크기를 조절해보세요.</li>
            </ul>
            <p class="mt-6 text-center text-slate-600 font-medium">이 프로세스는 다양한 프로젝트에 적용할 수 있는 강력한 파이프라인입니다. 즐겁게 실험하고 창조하세요!</p>
        </section>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const copyButtons = document.querySelectorAll('.copy-button');

            copyButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const codeBlock = button.nextElementSibling.querySelector('code');
                    const codeText = codeBlock.innerText;

                    // Create a temporary textarea element to hold the text
                    const textArea = document.createElement('textarea');
                    textArea.value = codeText;
                    document.body.appendChild(textArea);
                    textArea.select();

                    try {
                        const successful = document.execCommand('copy');
                        if (successful) {
                            button.textContent = '복사 완료!';
                            button.classList.add('copied');

                            setTimeout(() => {
                                button.textContent = '복사';
                                button.classList.remove('copied');
                            }, 2000);
                        } else {
                            console.error('Fallback: Failed to copy text.');
                        }
                    } catch (err)
 {
                        console.error('Fallback: Error copying text: ', err);
                    }

                    document.body.removeChild(textArea);
                });
            });
        });
    </script>
</body>
</html>

