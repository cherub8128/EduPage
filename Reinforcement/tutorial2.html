<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>기존 Pygame 게임으로 RL 환경 만들기 (소코반 ver.)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #282c34;
            color: #abb2bf;
        }
        .slide {
            display: none;
        }
        .slide.active {
            display: block;
        }
        .code-highlight {
            background-color: rgba(255, 255, 0, 0.15);
            display: block;
            margin: -0.25rem -0.5rem;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
        }
        pre[class*="language-"] {
            font-size: 0.9rem;
            line-height: 1.6;
        }
        .explanation-box {
            background-color: #21252b;
            border-left: 4px solid #61afef;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-7xl mx-auto bg-[#21252b] rounded-xl shadow-2xl overflow-hidden">
        <div class="p-8">
            <h1 class="text-3xl md:text-4xl font-bold text-white text-center">기존 Pygame 게임으로 RL 환경 만들기 (소코반편)</h1>
            <p class="text-center text-gray-400 mt-2">주어진 `sokoban.py` 파일을 AI의 놀이터로 개조해봅시다!</p>
        </div>

        <div id="slider-container" class="p-4 md:p-8 border-t border-gray-700 min-h-[500px]">
            <!-- Slides will be injected here by JS -->
        </div>

        <div class="bg-[#282c34] p-4 flex justify-between items-center">
            <button id="prevBtn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed">이전</button>
            <div id="slide-counter" class="text-white text-lg font-semibold"></div>
            <button id="nextBtn" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg transition duration-300">다음</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        const slides = [
            {
                title: "1. 우리의 목표: 게임과 환경의 분리",
                explanation: `
                    <p>먼저, 튜토리얼의 기반이 되는 원본 Pygame 소코반 파일을 다운로드하세요. 이 파일을 세 개의 파일로 분리하여 역할을 명확하게 나눌 것입니다.</p>
                    <div class="my-4">
                        <a id="download-link" href="#" download="sokoban.py" class="inline-block bg-teal-500 hover:bg-teal-400 text-white font-bold py-2 px-4 rounded-lg transition duration-300">
                            sokoban.py 원본 파일 다운로드
                        </a>
                    </div>
                    <div class="grid grid-cols-3 gap-4 mt-4 text-center">
                        <div class="bg-gray-800 p-4 rounded-lg">
                            <p class="text-2xl">🕹️</p>
                            <p class="font-bold text-white">sokoban_game.py</p>
                            <p class="text-sm text-gray-400">순수 게임 로직</p>
                        </div>
                        <div class="bg-gray-800 p-4 rounded-lg">
                            <p class="text-2xl">🔌</p>
                            <p class="font-bold text-white">sokoban_env.py</p>
                            <p class="text-sm text-gray-400">AI와의 통역사</p>
                        </div>
                        <div class="bg-gray-800 p-4 rounded-lg">
                            <p class="text-2xl">🧠</p>
                            <p class="font-bold text-white">train.py</p>
                            <p class="text-sm text-gray-400">AI 학습 실행</p>
                        </div>
                    </div>
                    <p class="mt-4">이 슬라이드에서는 먼저 다운로드한 <code class="bg-gray-700 p-1 rounded">sokoban.py</code>를 AI가 제어할 수 있는 <code class="bg-gray-700 p-1 rounded">sokoban_game.py</code>로 수정하는 과정에 집중합니다.</p>
                `,
                code: ``
            },
            {
                title: "2. `sokoban.py` 수정 (1): 클래스 이름 변경",
                explanation: `
                    <p>먼저, 기존 <code class="bg-gray-700 p-1 rounded">Game</code> 클래스의 이름을 <code class="bg-gray-700 p-1 rounded">SokobanGame</code>으로 변경하여 역할을 더 명확하게 만듭니다.</p>
                    <p class="mt-2">그리고 AI가 게임을 제어할 것이므로, 사람의 플레이를 위한 메인 루프(<code class="bg-gray-700 p-1 rounded">run</code> 함수)는 나중에 따로 분리할 것입니다.</p>
                `,
                code: `
# 기존 sokoban.py 파일의 일부...

# --- 메인 게임 클래스 ---
<span class="code-highlight">class SokobanGame: # 'Game' -> 'SokobanGame'</span>
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Minimalist Sokoban (5x5)")
        self.clock = pygame.time.Clock()
        self.font_big = pygame.font.Font(None, 72)
        self.font_small = pygame.font.Font(None, 36)
        self.game_state = "playing"
        self.new_game()

    # ... (이하 생략) ...
                `
            },
            {
                title: "3. `sokoban.py` 수정 (2): AI용 step 함수 추가",
                explanation: `
                    <p>AI는 '위로 가' 같은 명령을 내립니다. 이 명령을 받아 게임을 한 프레임 진행시키고, 그 결과를(다음 화면, 보상, 종료 여부) 알려주는 함수가 필요합니다. 이 함수를 <code class="bg-gray-700 p-1 rounded">step(action)</code>이라고 부릅니다.</p>
                    <p class="mt-2">이 함수는 AI와의 핵심 소통 창구입니다.</p>
                `,
                code: `
class SokobanGame:
    # ... (이전 코드) ...

<span class="code-highlight">    def step(self, action):</span>
<span class="code-highlight">        """AI의 행동(action)을 받아 게임을 한 단계 진행시키고 결과를 반환합니다."""</span>
<span class="code-highlight">        move_map = {0: (0, -1), 1: (0, 1), 2: (-1, 0), 3: (1, 0)} # 상, 하, 좌, 우</span>
<span class="code-highlight">        dx, dy = move_map[action]</span>
<span class="code-highlight"></span>
<span class="code-highlight">        boxes_on_target_before = len(self.box_positions.intersection(self.target_positions))</span>
<span class="code-highlight">        self._move_player(dx, dy) # 기존 이동 함수 재사용</span>
<span class="code-highlight">        boxes_on_target_after = len(self.box_positions.intersection(self.target_positions))</span>
<span class="code-highlight"></span>
<span class="code-highlight">        # 보상 계산 (다음 슬라이드에서 상세 설명)</span>
<span class="code-highlight">        reward = self._calculate_reward(boxes_on_target_before, boxes_on_target_after)</span>
<span class="code-highlight">        done = self._check_win_condition()</span>
<span class="code-highlight"></span>
<span class="code-highlight">        return self.get_observation(), reward, done</span>
                `
            },
            {
                title: "4. `sokoban.py` 수정 (3): 보상 로직 설계",
                explanation: `
                    <p>AI를 똑똑하게 만드는 가장 중요한 부분, 바로 '보상'입니다. 어떤 행동에 점수를 줄지 정하는 규칙을 만듭니다.</p>
                    <div class="explanation-box">
                        <p><strong>보상 규칙:</strong><br>
                        - 박스를 목표에 올리면: <strong>+10점</strong><br>
                        - 박스를 목표에서 빼면: <strong>-10점</strong><br>
                        - 게임을 클리어하면: <strong>+100점</strong><br>
                        - 그냥 움직이면: <strong>-0.01점</strong> (최단 경로를 찾도록 유도)
                        </p>
                    </div>
                `,
                code: `
class SokobanGame:
    # ... (이전 코드) ...
<span class="code-highlight">    def _calculate_reward(self, before, after):</span>
<span class="code-highlight">        reward = -0.01 # 움직임 페널티</span>
<span class="code-highlight">        if after > before:</span>
<span class="code-highlight">            reward += 10</span>
<span class="code-highlight">        elif after < before:</span>
<span class="code-highlight">            reward -= 10</span>
<span class="code-highlight">        </span>
<span class="code-highlight">        if self._check_win_condition():</span>
<span class="code-highlight">            reward += 100</span>
<span class="code-highlight">        return reward</span>
                `
            },
            {
                title: "5. `sokoban.py` 수정 (4): 관찰(Observation) 생성",
                explanation: `
                    <p>AI는 사람처럼 화면 픽셀을 보고 이해하기 어렵습니다. 대신, 게임 상황을 숫자로 된 지도(그리드)로 변환해서 보여주는 것이 훨씬 효율적입니다.</p>
                    <div class="explanation-box">
                     <p><strong>숫자 지도 규칙:</strong><br>
                        - 1: 플레이어, 2: 박스, 3: 목표, 4: 목표 위의 박스
                     </p>
                    </div>
                `,
                code: `
class SokobanGame:
    # ... (이전 코드) ...
<span class="code-highlight">    def get_observation(self):</span>
<span class="code-highlight">        """AI를 위한 숫자 그리드 관찰(observation)을 생성합니다."""</span>
<span class="code-highlight">        grid = np.zeros((self.map_height, self.map_width), dtype=np.uint8)</span>
<span class="code-highlight">        for r in range(self.map_height):</span>
<span class="code-highlight">            for c in range(self.map_width):</span>
<span class="code-highlight">                pos = (c, r)</span>
<span class="code-highlight">                if pos in self.target_positions: grid[r, c] = 3</span>
<span class="code-highlight">                if pos in self.box_positions: grid[r, c] = 2</span>
<span class="code-highlight">                if pos in self.target_positions and pos in self.box_positions: grid[r, c] = 4</span>
<span class="code-highlight">        </span>
<span class="code-highlight">        player_r, player_c = self.player_pos[1], self.player_pos[0]</span>
<span class="code-highlight">        grid[player_r, player_c] = 1</span>
<span class="code-highlight">        return grid</span>
                `
            },
            {
                title: "6. `sokoban.py` 수정 (5): 사람 플레이용 코드 분리",
                explanation: `
                    <p>기존의 <code class="bg-gray-700 p-1 rounded">run</code>, <code class="bg-gray-700 p-1 rounded">events</code>, <code class="bg-gray-700 p-1 rounded">draw</code> 함수 등은 사람이 직접 플레이할 때만 필요합니다. 이들을 <code class="bg-gray-700 p-1 rounded">run_for_human()</code>이라는 함수로 묶어줍니다.</p>
                    <p class="mt-2">이렇게 하면 <code class="bg-gray-700 p-1 rounded">sokoban_game.py</code> 파일을 직접 실행하면 사람이 게임을 할 수 있고, 다른 파일에서 import하면 순수 게임 로직만 가져다 쓸 수 있습니다.</p>
                `,
                code: `
class SokobanGame:
    # ... (이전 코드) ...

<span class="code-highlight">def run_for_human(self):</span>
<span class="code-highlight">    # 기존의 run(), events(), draw() 로직을 이곳으로 옮깁니다.</span>
<span class="code-highlight">    # ...</span>

<span class="code-highlight"># 이 파일을 직접 실행하면 사람이 플레이할 수 있습니다.</span>
<span class="code-highlight">if __name__ == '__main__':</span>
<span class="code-highlight">    game = SokobanGame()</span>
<span class="code-highlight">    game.run_for_human()</span>
                `
            },
            {
                title: "7. `sokoban_env.py` 만들기",
                explanation: `
                    <p>이제 AI와의 통역사, <code class="bg-gray-700 p-1 rounded">sokoban_env.py</code> 파일을 만들 차례입니다. 이 파일은 우리가 수정한 <code class="bg-gray-700 p-1 rounded">SokobanGame</code>을 불러와 Gymnasium 규칙에 맞게 포장합니다.</p>
                    <p class="mt-2">이전 튜토리얼에서 배운 내용과 거의 동일합니다. 내부적으로 <code class="bg-gray-700 p-1 rounded">SokobanGame</code> 객체를 가지고, AI의 요청을 게임 객체에 전달하는 역할만 합니다.</p>
                `,
                code: `
# sokoban_env.py
import gymnasium as gym
from gymnasium import spaces
<span class="code-highlight">from sokoban_game import SokobanGame # 수정한 게임 클래스 import</span>

class SokobanEnv(gym.Env):
    def __init__(self, render_mode=None):
        super().__init__()
<span class="code-highlight">        self.game = SokobanGame() # 게임 객체를 내부에 생성</span>
        
        self.action_space = spaces.Discrete(4)
        self.observation_space = spaces.Box(low=0, high=4, 
            shape=(self.game.map_height, self.game.map_width), dtype=np.uint8)
        # ...

    def step(self, action):
<span class="code-highlight">        obs, reward, terminated = self.game.step(action) # 게임 객체에 명령 전달</span>
        truncated = self.steps_taken >= 200 # 타임스텝 제한
        # ...
        return obs, reward, terminated, truncated, self._get_info()

    # ... (reset, render, close 함수는 게임 객체의 함수를 호출) ...
                `
            },
            {
                title: "8. `train.py`로 학습 실행하기",
                explanation: `
                    <p>마지막으로, AI 학습을 시작하는 <code class="bg-gray-700 p-1 rounded">train.py</code> 파일을 만듭니다.</p>
                    <p class="mt-2">이 파일은 우리가 만든 <code class="bg-gray-700 p-1 rounded">SokobanEnv</code>를 불러와 Stable-Baselines3 라이브러리의 PPO 알고리즘으로 학습을 진행합니다.</p>
                `,
                code: `
# train.py
<span class="code-highlight">from sokoban_env import SokobanEnv # 우리가 만든 환경 import</span>
from stable_baselines3 import PPO
from stable_baselines3.common.env_checker import check_env

# 1. 환경 유효성 검사
env = SokobanEnv()
check_env(env)

# 2. 모델 생성 및 학습
env = SokobanEnv()
<span class="code-highlight">model = PPO("MlpPolicy", env, verbose=1)</span>
<span class="code-highlight">model.learn(total_timesteps=100000)</span>
model.save("ppo_sokoban")

# 3. 학습된 모델 테스트
model = PPO.load("ppo_sokoban")
obs, info = env.reset()
for _ in range(500):
    action, _ = model.predict(obs, deterministic=True)
    obs, reward, terminated, truncated, info = env.step(action)
    env.render()
    if terminated or truncated:
        obs, info = env.reset()
                `
            },
            {
                title: "9. 최종 정리",
                explanation: `
                    <p>축하합니다! 이제 여러분은 기존 Pygame 게임을 수정하여 AI를 학습시킬 수 있는 완전한 RL 프로젝트 구조를 갖게 되었습니다.</p>
                     <div class="explanation-box">
                        <p><strong>핵심 요약:</strong><br>
                        1. <strong>게임 로직 수정:</strong> 기존 게임 코드에 AI가 제어할 수 있는 <code class="bg-gray-700 p-1 rounded">step</code>, <code class="bg-gray-700 p-1 rounded">reset</code>, <code class="bg-gray-700 p-1 rounded">get_observation</code> 함수를 추가했습니다.<br>
                        2. <strong>환경 래퍼 생성:</strong> 수정된 게임을 Gymnasium 규칙에 맞게 감싸는 <code class="bg-gray-700 p-1 rounded">SokobanEnv</code>를 만들었습니다.<br>
                        3. <strong>학습 스크립트 작성:</strong> 만들어진 환경을 이용해 실제 AI 모델을 학습시키는 코드를 작성했습니다.
                        </p>
                    </div>
                `,
                code: ``
            }
        ];

        const sokobanFileContent = `
import pygame
import sys
import random

# --- 상수 정의 ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
TILE_SIZE = 60
WALL_THICKNESS = 10 # 벽 굵기를 상수로 정의

# 색상 팔레트
COLOR_BACKGROUND = (240, 235, 220)
COLOR_GRID = (220, 210, 190)
COLOR_WALL = (60, 70, 80)
COLOR_PLAYER = (230, 80, 80)
COLOR_BOX = (20, 140, 200)
COLOR_TARGET = (220, 170, 20)
COLOR_BOX_ON_TARGET = (60, 200, 100)
COLOR_TEXT = (50, 50, 50)

# --- 게임 객체 클래스 (변경 없음) ---
class GameObject(pygame.sprite.Sprite):
    def __init__(self, x, y, color):
        super().__init__()
        self.image = pygame.Surface([TILE_SIZE, TILE_SIZE])
        self.rect = self.image.get_rect(topleft=(x, y))
        self.draw_shape(color)

    def draw_shape(self, color):
        self.image.fill(COLOR_BACKGROUND)
        pygame.draw.rect(self.image, color, self.image.get_rect().inflate(-8, -8), border_radius=8)

class Player(GameObject):
    def __init__(self, x, y):
        super().__init__(x, y, COLOR_PLAYER)
    def draw_shape(self, color):
        self.image.fill(COLOR_BACKGROUND)
        pygame.draw.circle(self.image, color, (TILE_SIZE // 2, TILE_SIZE // 2), TILE_SIZE // 2 - 5)

class Box(GameObject):
    def __init__(self, x, y):
        super().__init__(x, y, COLOR_BOX)
        self.on_target = False
    def update(self, on_target):
        if self.on_target != on_target:
            self.on_target = on_target
            color = COLOR_BOX_ON_TARGET if self.on_target else COLOR_BOX
            self.draw_shape(color)

class Target(GameObject):
    def __init__(self, x, y):
        super().__init__(x, y, COLOR_TARGET)
    def draw_shape(self, color):
        self.image.fill(COLOR_BACKGROUND)
        pygame.draw.rect(self.image, color, self.image.get_rect().inflate(-18, -18))


# --- 메인 게임 클래스 ---
class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Minimalist Sokoban (5x5)")
        self.clock = pygame.time.Clock()
        self.font_big = pygame.font.Font(None, 72)
        self.font_small = pygame.font.Font(None, 36)
        self.game_state = "playing"
        self.new_game()

    def new_game(self):
        self.map_width = 5
        self.map_height = 5
        self.num_boxes = 2
        
        level_data = self.generate_random_level_data()
        self.load_level_from_data(level_data)
        self.game_state = "playing"

    def generate_random_level_data(self):
        all_coords = [(c, r) for c in range(self.map_width) for r in range(self.map_height)]
        random.shuffle(all_coords)

        player_pos = all_coords.pop()
        target_positions = {all_coords.pop() for _ in range(self.num_boxes)}
        box_positions = {all_coords.pop() for _ in range(self.num_boxes)}

        return {
            "player": player_pos,
            "boxes": box_positions,
            "targets": target_positions
        }

    def load_level_from_data(self, level_data):
        self.all_sprites = pygame.sprite.Group()
        self.boxes = pygame.sprite.Group()
        self.targets = pygame.sprite.Group()

        map_w_px = self.map_width * TILE_SIZE
        map_h_px = self.map_height * TILE_SIZE
        self.offset_x = (SCREEN_WIDTH - map_w_px) // 2
        self.offset_y = (SCREEN_HEIGHT - map_h_px) // 2
        
        self.playable_area = pygame.Rect(self.offset_x, self.offset_y, map_w_px, map_h_px)

        self.wall_frame_rect = self.playable_area.inflate(WALL_THICKNESS+10, WALL_THICKNESS+10)

        def to_pixel_coords(grid_pos):
            return (self.offset_x + grid_pos[0] * TILE_SIZE, 
                    self.offset_y + grid_pos[1] * TILE_SIZE)

        px, py = to_pixel_coords(level_data["player"])
        self.player = Player(px, py)

        for pos in level_data["boxes"]:
            bx, by = to_pixel_coords(pos)
            self.boxes.add(Box(bx, by))

        for pos in level_data["targets"]:
            tx, ty = to_pixel_coords(pos)
            self.targets.add(Target(tx, ty))
        
        self.all_sprites.add(self.targets, self.boxes, self.player)
        self.current_level_data = level_data

    def run(self):
        while True:
            self.events()
            if self.game_state == "playing":
                self.update()
            self.draw()
            self.clock.tick(60)

    def events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.KEYDOWN:
                if self.game_state == "playing":
                    dx, dy = 0, 0
                    if event.key == pygame.K_LEFT: dx = -TILE_SIZE
                    elif event.key == pygame.K_RIGHT: dx = TILE_SIZE
                    elif event.key == pygame.K_UP: dy = -TILE_SIZE
                    elif event.key == pygame.K_DOWN: dy = TILE_SIZE
                    
                    if dx != 0 or dy != 0:
                        self.move_player(dx, dy)
                
                if event.key == pygame.K_r:
                    self.load_level_from_data(self.current_level_data)
                    self.game_state = "playing"
                if event.key == pygame.K_n:
                    self.new_game()

    def move_player(self, dx, dy):
        player_target_rect = self.player.rect.move(dx, dy)

        if not self.playable_area.contains(player_target_rect):
            return

        box_to_move = next((box for box in self.boxes if box.rect.colliderect(player_target_rect)), None)

        if box_to_move:
            box_target_rect = box_to_move.rect.move(dx, dy)
            if not self.playable_area.contains(box_target_rect):
                return
            if any(b != box_to_move and b.rect.colliderect(box_target_rect) for b in self.boxes):
                return
            
            box_to_move.rect.move_ip(dx, dy)

        self.player.rect.move_ip(dx, dy)

    def update(self):
        if self.check_win_condition():
            self.game_state = "level_clear"

    def check_win_condition(self):
        if not self.boxes: return False
        target_coords = {t.rect.topleft for t in self.targets}
        box_coords = {b.rect.topleft for b in self.boxes}
        return target_coords == box_coords

    def draw(self):
        self.screen.fill(COLOR_BACKGROUND)
        self.draw_grid_and_wall()
        self.all_sprites.draw(self.screen)
        self.draw_ui()
        pygame.display.flip()

    def draw_grid_and_wall(self):
        for x in range(self.playable_area.left, self.playable_area.right, TILE_SIZE):
            pygame.draw.line(self.screen, COLOR_GRID, (x, self.playable_area.top), (x, self.playable_area.bottom))
        for y in range(self.playable_area.top, self.playable_area.bottom, TILE_SIZE):
            pygame.draw.line(self.screen, COLOR_GRID, (self.playable_area.left, y), (self.playable_area.right, y))

        pygame.draw.rect(
            self.screen,
            COLOR_WALL,
            self.wall_frame_rect,
            width=WALL_THICKNESS,
            border_radius=15
        )
            
    def draw_ui(self):
        instructions = "'R' Restart | 'N' New Level"
        inst_text = self.font_small.render(instructions, True, COLOR_TEXT)
        text_rect = inst_text.get_rect(centerx=SCREEN_WIDTH / 2, y=20)
        self.screen.blit(inst_text, text_rect)
        
        target_coords = {t.rect.topleft for t in self.targets}
        for box in self.boxes:
            is_on_target = box.rect.topleft in target_coords
            box.update(is_on_target)

        if self.game_state == "level_clear":
            self.draw_overlay("LEVEL CLEAR!", "Press 'N' for a New Level")

    def draw_overlay(self, title, subtitle):
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((255, 255, 255, 180))
        self.screen.blit(overlay, (0, 0))
        
        title_surf = self.font_big.render(title, True, COLOR_TEXT)
        title_rect = title_surf.get_rect(center=(SCREEN_WIDTH/2, SCREEN_HEIGHT/2 - 30))
        self.screen.blit(title_surf, title_rect)
        
        sub_surf = self.font_small.render(subtitle, True, COLOR_TEXT)
        sub_rect = sub_surf.get_rect(center=(SCREEN_WIDTH/2, SCREEN_HEIGHT/2 + 30))
        self.screen.blit(sub_surf, sub_rect)


if __name__ == '__main__':
    game = Game()
    game.run()
`;

        let currentSlide = 0;
        const sliderContainer = document.getElementById('slider-container');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const slideCounter = document.getElementById('slide-counter');

        function createSlide(slideData, index) {
            const slideElement = document.createElement('div');
            slideElement.className = 'slide p-4';
            slideElement.dataset.index = index;

            let codeHtml = '';
            if (slideData.code) {
                const tempDiv = document.createElement('div');
                const codeWithPlaceholders = slideData.code.trim()
                    .replace(/<span class="code-highlight">/g, '[[HIGHLIGHT_START]]')
                    .replace(/<\/span>/g, '[[HIGHLIGHT_END]]');

                tempDiv.textContent = codeWithPlaceholders;
                
                const finalCode = tempDiv.innerHTML
                    .replace(/\[\[HIGHLIGHT_START\]\]/g, '<span class="code-highlight">')
                    .replace(/\[\[HIGHLIGHT_END\]\]/g, '</span>');

                codeHtml = `
                    <div class="mt-6 bg-[#282c34] rounded-lg overflow-hidden border border-gray-700">
                        <pre class="language-python !text-sm !leading-relaxed"><code>${finalCode}</code></pre>
                    </div>
                `;
            }

            slideElement.innerHTML = `
                <div class="grid grid-cols-1 ${slideData.code ? 'md:grid-cols-2' : ''} gap-8 items-start">
                    <div class="prose prose-invert max-w-none">
                        <h2 class="text-2xl font-bold text-indigo-400 mb-4">${slideData.title}</h2>
                        <div class="text-gray-300 leading-relaxed space-y-2">${slideData.explanation}</div>
                    </div>
                    ${slideData.code ? `<div>${codeHtml}</div>` : ''}
                </div>
            `;
            return slideElement;
        }
        
        function setupDownloadLink() {
            const link = document.getElementById('download-link');
            if (link) {
                const encodedContent = encodeURIComponent(sokobanFileContent.trim());
                link.href = 'data:text/plain;charset=utf-8,' + encodedContent;
            }
        }

        function updateSlider() {
            document.querySelectorAll('.slide').forEach((slide, index) => {
                slide.classList.toggle('active', index === currentSlide);
            });
            slideCounter.textContent = `${currentSlide + 1} / ${slides.length}`;
            prevBtn.disabled = currentSlide === 0;
            nextBtn.disabled = currentSlide === slides.length - 1;
            
            if (currentSlide === 0) {
                setupDownloadLink();
            }
            
            Prism.highlightAll();
        }

        prevBtn.addEventListener('click', () => {
            if (currentSlide > 0) {
                currentSlide--;
                updateSlider();
            }
        });

        nextBtn.addEventListener('click', () => {
            if (currentSlide < slides.length - 1) {
                currentSlide++;
                updateSlider();
            }
        });
        
        // Initialize slider
        slides.forEach((slideData, index) => {
            sliderContainer.appendChild(createSlide(slideData, index));
        });
        updateSlider();
    </script>
</body>
</html>
