<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pygame 게임으로 강화학습 시작하기 (슬라이드 ver.)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #282c34;
            color: #abb2bf;
        }
        .slide {
            display: none;
        }
        .slide.active {
            display: block;
        }
        .code-highlight {
            background-color: rgba(255, 255, 0, 0.15);
            display: block;
            margin: -0.25rem -0.5rem;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
        }
        pre[class*="language-"] {
            font-size: 0.9rem;
            line-height: 1.6;
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-6xl mx-auto bg-[#21252b] rounded-xl shadow-2xl overflow-hidden">
        <div class="p-8">
            <h1 class="text-3xl md:text-4xl font-bold text-white text-center">Pygame 게임으로 나만의 강화학습 환경 만들기</h1>
            <p class="text-center text-gray-400 mt-2">슬라이드를 넘기며 한 단계씩 따라 해보세요!</p>
        </div>

        <div id="slider-container" class="p-4 md:p-8 border-t border-gray-700">
            <!-- Slides will be injected here by JS -->
        </div>

        <div class="bg-[#282c34] p-4 flex justify-between items-center">
            <button id="prevBtn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed">이전</button>
            <div id="slide-counter" class="text-white text-lg font-semibold"></div>
            <button id="nextBtn" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg transition duration-300">다음</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        const slides = [
            {
                title: "1. 우리의 목표는 무엇일까요?",
                explanation: `
                    <p>이미 만들어진 Pygame 게임이 있습니다. 이 게임을 '강화학습 AI'가 플레이할 수 있도록 '게임팩'처럼 만들어주는 것이 목표입니다.</p>
                    <div class="mt-4 p-4 bg-gray-800 rounded-lg flex items-center space-x-4">
                        <span class="text-4xl">🕹️</span>
                        <div><p class="font-bold text-white">Pygame 게임</p><p class="text-sm">우리가 가진 것</p></div>
                        <span class="text-2xl text-gray-400">+</span>
                        <span class="text-4xl">🔌</span>
                        <div><p class="font-bold text-white">Gymnasium 래퍼 (어댑터)</p><p class="text-sm">우리가 만들 것</p></div>
                        <span class="text-2xl text-gray-400">=</span>
                        <span class="text-4xl">팩맨</span>
                        <div><p class="font-bold text-white">강화학습 환경</p><p class="text-sm">최종 결과물</p></div>
                    </div>
                    <p class="mt-4">AI는 'Gymnasium'이라는 표준 규격으로 만들어진 게임팩만 인식할 수 있습니다. 그래서 우리 게임을 이 규격에 맞게 포장(Wrapping)해야 합니다.</p>
                `,
                code: ``
            },
            {
                title: "2. 기본 뼈대 만들기",
                explanation: `
                    <p>먼저, Gymnasium 라이브러리의 기본 환경 틀인 <code class="bg-gray-700 p-1 rounded">gym.Env</code>를 상속받는 우리만의 클래스를 만듭니다. 이것이 우리 게임팩의 기본 케이스가 됩니다.</p>
                    <p class="mt-2">모든 강화학습 환경은 이 <code class="bg-gray-700 p-1 rounded">gym.Env</code> 라는 약속된 틀을 따라야 합니다.</p>
                `,
                code: `
<span class="code-highlight">import gymnasium as gym</span>
import pygame
import numpy as np
from gymnasium import spaces

<span class="code-highlight">class PygameEnv(gym.Env):</span>
    # 앞으로 이 안에 모든 코드를 작성할 거예요.
    pass
                `
            },
            {
                title: "3. `__init__` : 환경 설계도 (1)",
                explanation: `
                    <p><code class="bg-gray-700 p-1 rounded">__init__</code> 함수는 우리 환경이 처음 만들어질 때 딱 한 번 실행되는 '설계도'입니다. 여기서 게임의 기본 설정을 정합니다.</p>
                    <p class="mt-2">게임 창의 크기 같은 기본적인 것들을 설정해줍니다.</p>
                `,
                code: `
import gymnasium as gym
import pygame
import numpy as np
from gymnasium import spaces

class PygameEnv(gym.Env):
<span class="code-highlight">    def __init__(self):</span>
<span class="code-highlight">        super().__init__() # gym.Env의 초기 설정도 가져옵니다.</span>
<span class="code-highlight">        </span>
<span class="code-highlight">        # Pygame 창 크기 설정</span>
<span class="code-highlight">        self.width = 600</span>
<span class="code-highlight">        self.height = 400</span>
                `
            },
            {
                title: "4. `__init__` : 행동 공간 정의",
                explanation: `
                    <p>설계도에 이어서, AI가 할 수 있는 <strong>행동의 종류</strong>를 알려줘야 합니다. 이것을 '행동 공간(Action Space)'이라고 합니다.</p>
                    <p class="mt-2">TV 리모컨의 버튼을 정해주는 것과 같아요. 우리 게임에서는 '왼쪽', '가만히 있기', '오른쪽' 세 가지 버튼만 만들겠습니다.</p>
                    <p class="mt-2"><code class="bg-gray-700 p-1 rounded">spaces.Discrete(3)</code>는 0, 1, 2 세 개의 정수 중 하나를 행동으로 선택할 수 있다는 의미입니다.</p>
                `,
                code: `
class PygameEnv(gym.Env):
    def __init__(self):
        super().__init__()
        
        self.width = 600
        self.height = 400

<span class="code-highlight">        # 0: 왼쪽, 1: 가만히 있기, 2: 오른쪽</span>
<span class="code-highlight">        self.action_space = spaces.Discrete(3)</span>
                `
            },
            {
                title: "5. `__init__` : 관찰 공간 정의",
                explanation: `
                    <p>AI가 '보는' 것, 즉 <strong>상태 정보</strong>의 형태도 알려줘야 합니다. 이것을 '관찰 공간(Observation Space)'이라고 합니다.</p>
                    <p class="mt-2">AI에게 어떤 TV 화면을 보여줄지 정하는 것과 같아요. 우리는 게임 화면 전체를 컬러(RGB) 이미지로 보여줄 겁니다.</p>
                    <p class="mt-2"><code class="bg-gray-700 p-1 rounded">spaces.Box(...)</code>는 숫자들의 네모난 배열(이미지 픽셀)을 의미합니다. 각 픽셀은 0~255 사이의 RGB 값을 가집니다.</p>
                `,
                code: `
class PygameEnv(gym.Env):
    def __init__(self):
        # ... 이전 코드 생략 ...
        self.action_space = spaces.Discrete(3)

<span class="code-highlight">        # 게임 화면 픽셀을 관찰 공간으로 사용</span>
<span class="code-highlight">        self.observation_space = spaces.Box(</span>
<span class="code-highlight">            low=0, high=255, </span>
<span class="code-highlight">            shape=(self.width, self.height, 3), </span>
<span class="code-highlight">            dtype=np.uint8</span>
<span class="code-highlight">        )</span>
                `
            },
            {
                title: "6. `reset` : 새 게임 시작하기",
                explanation: `
                    <p><code class="bg-gray-700 p-1 rounded">reset</code> 함수는 게임 한 판이 끝나거나 처음 시작할 때 호출됩니다. 모든 것을 초기 상태로 되돌리는 역할을 합니다.</p>
                    <p class="mt-2">마치 게임기의 '리셋 버튼'과 같아요. 플레이어와 장애물을 처음 위치로 돌려놓고, AI에게 초기 화면(<code class="bg-gray-700 p-1 rounded">observation</code>)을 보여줍니다.</p>
                `,
                code: `
class PygameEnv(gym.Env):
    # ... __init__ 생략 ...

<span class="code-highlight">    def reset(self, seed=None, options=None):</span>
<span class="code-highlight">        super().reset(seed=seed)</span>
<span class="code-highlight">        </span>
<span class="code-highlight">        # 플레이어와 장애물 위치를 처음으로 되돌림</span>
<span class="code-highlight">        self.player_pos = [self.width // 2, self.height - 50]</span>
<span class="code-highlight">        self.obstacle_pos = [np.random.randint(0, self.width), 0]</span>
<span class="code-highlight">        </span>
<span class="code-highlight">        # _get_obs()는 현재 화면을 Numpy 배열로 바꿔주는 함수 (나중에 구현)</span>
<span class="code-highlight">        observation = self._get_obs() </span>
<span class="code-highlight">        info = {} # 추가 정보 (지금은 비워둠)</span>
<span class="code-highlight">        </span>
<span class="code-highlight">        return observation, info</span>
                `
            },
            {
                title: "7. `step` : 한 걸음 나아가기",
                explanation: `
                    <p><code class="bg-gray-700 p-1 rounded">step</code> 함수는 AI가 행동을 하나 결정했을 때 호출됩니다. 이 함수 안에서 게임 세상의 시간이 한 프레임 흐릅니다.</p>
                    <p class="mt-2">가장 중요한 함수로, AI의 행동을 게임에 반영하고 그 결과를 AI에게 알려줍니다.</p>
                `,
                code: `
class PygameEnv(gym.Env):
    # ... 이전 코드 생략 ...

<span class="code-highlight">    def step(self, action):</span>
<span class="code-highlight">        # 1. AI가 선택한 행동(action)을 게임에 반영</span>
<span class="code-highlight">        if action == 0: self.player_pos[0] -= 10 # 왼쪽</span>
<span class="code-highlight">        elif action == 2: self.player_pos[0] += 10 # 오른쪽</span>
<span class="code-highlight">        </span>
<span class="code-highlight">        # 2. 게임 환경의 변화 (장애물 이동 등)</span>
<span class="code-highlight">        self.obstacle_pos[1] += 7</span>
<span class="code-highlight">        </span>
<span class="code-highlight">        # 3. 행동의 결과 계산 (보상, 게임 종료 여부)</span>
<span class="code-highlight">        # ... 다음 슬라이드에서 계속 ...</span>
                `
            },
            {
                title: "8. `step` : 결과 계산 (보상과 종료)",
                explanation: `
                    <p>AI의 행동이 어떤 결과를 낳았는지 계산합니다.</p>
                    <ul class="list-disc list-inside space-y-2 mt-2">
                        <li><strong>보상(reward)</strong>: 행동이 얼마나 좋았는지 알려주는 점수입니다. (피하면 +, 부딪히면 -)</li>
                        <li><strong>종료(terminated)</strong>: 게임이 끝났는지 알려주는 신호입니다. (부딪히면 True)</li>
                    </ul>
                    <p class="mt-2">이 보상과 종료 신호가 AI를 똑똑하게 만드는 핵심 재료입니다.</p>
                `,
                code: `
    def step(self, action):
        # ... 이전 코드 생략 ...

<span class="code-highlight">        terminated = False</span>
<span class="code-highlight">        reward = 0.1  # 살아있으면 기본 점수</span>

<span class="code-highlight">        # 플레이어와 장애물이 부딪혔나?</span>
<span class="code-highlight">        player_rect = pygame.Rect(self.player_pos[0], self.player_pos[1], 30, 30)</span>
<span class="code-highlight">        obstacle_rect = pygame.Rect(self.obstacle_pos[0], self.obstacle_pos[1], 30, 30)</span>
<span class="code-highlight">        if player_rect.colliderect(obstacle_rect):</span>
<span class="code-highlight">            terminated = True # 게임 종료!</span>
<span class="code-highlight">            reward = -10.0 # 큰 벌점</span>
<span class="code-highlight">        </span>
<span class="code-highlight">        # 장애물을 성공적으로 피했나?</span>
<span class="code-highlight">        if self.obstacle_pos[1] > self.height:</span>
<span class="code-highlight">            self.obstacle_pos = [np.random.randint(0, self.width), 0] # 새 장애물</span>
<span class="code-highlight">            reward = 1.0 # 상점</span>
                `
            },
            {
                title: "9. `step` : 결과 보고하기",
                explanation: `
                    <p>마지막으로, <code class="bg-gray-700 p-1 rounded">step</code> 함수는 계산된 모든 결과를 AI에게 '보고'해야 합니다. 이 보고서에는 정해진 5가지 항목이 포함되어야 합니다.</p>
                    <ol class="list-decimal list-inside space-y-1 mt-2">
                        <li><strong>observation</strong>: 행동 후의 게임 화면</li>
                        <li><strong>reward</strong>: 행동에 대한 점수</li>
                        <li><strong>terminated</strong>: 게임이 끝났는지 여부</li>
                        <li><strong>truncated</strong>: (시간 초과 등) 게임이 중단되었는지 여부 (지금은 False)</li>
                        <li><strong>info</strong>: 추가 정보 (지금은 빈 딕셔너리)</li>
                    </ol>
                `,
                code: `
    def step(self, action):
        # ... 이전 코드 생략 ...

<span class="code-highlight">        observation = self._get_obs()</span>
<span class="code-highlight">        info = {}</span>
<span class="code-highlight">        </span>
<span class="code-highlight">        return observation, reward, terminated, False, info</span>
                `
            },
            {
                title: "10. `render` 와 `close` : 뒷정리",
                explanation: `
                    <p>마지막으로 두 개의 보조 함수를 만듭니다.</p>
                    <ul class="list-disc list-inside space-y-2 mt-2">
                        <li><strong>render()</strong>: 우리가 직접 게임 화면을 보고 싶을 때 호출하는 함수입니다.</li>
                        <li><strong>close()</strong>: 학습이 모두 끝났을 때 Pygame 창을 안전하게 닫는 함수입니다.</li>
                    </ul>
                    <p class="mt-2">이것으로 모든 필수 함수 구현이 끝났습니다!</p>
                `,
                code: `
class PygameEnv(gym.Env):
    # ... 이전 코드 생략 ...

<span class="code-highlight">    def render(self):</span>
<span class="code-highlight">        # Pygame 화면을 그리는 로직</span>
<span class="code-highlight">        # (전체 코드에서 확인)</span>
<span class="code-highlight">        pass</span>

<span class="code-highlight">    def close(self):</span>
<span class="code-highlight">        pygame.quit()</span>
                `
            },
            {
                title: "11. 완성된 코드",
                explanation: `
                    <p>지금까지 우리가 만든 조각들을 모두 합치면 완전한 Gymnasium 환경 코드가 됩니다.</p>
                    <p class="mt-2">이제 이 <code class="bg-gray-700 p-1 rounded">PygameEnv</code> 클래스는 어떤 강화학습 라이브러리(예: Stable-Baselines3)와도 호환되는 완벽한 '게임팩'이 되었습니다.</p>
                `,
                code: `
import pygame
import numpy as np
import gymnasium as gym
from gymnasium import spaces

class PygameEnv(gym.Env):
    metadata = {"render_modes": ["human"], "render_fps": 30}

    def __init__(self, render_mode=None):
        super().__init__()
        self.width, self.height = 600, 400
        self.action_space = spaces.Discrete(3)
        self.observation_space = spaces.Box(low=0, high=255, shape=(self.width, self.height, 3), dtype=np.uint8)
        self.render_mode = render_mode
        self.screen = None
        self.clock = None

    def _get_obs(self):
        return pygame.surfarray.array3d(self.screen).transpose([1, 0, 2])

    def reset(self, seed=None, options=None):
        super().reset(seed=seed)
        self.player_pos = [self.width // 2, self.height - 50]
        self.obstacle_pos = [np.random.randint(0, self.width), 0]
        if self.render_mode == "human": self._render_frame()
        return self._get_obs(), {}

    def step(self, action):
        if action == 0: self.player_pos[0] -= 10
        elif action == 2: self.player_pos[0] += 10
        self.player_pos[0] = np.clip(self.player_pos[0], 0, self.width - 30)
        self.obstacle_pos[1] += 7
        
        terminated = False
        reward = 0.1
        player_rect = pygame.Rect(self.player_pos[0], self.player_pos[1], 30, 30)
        obstacle_rect = pygame.Rect(self.obstacle_pos[0], self.obstacle_pos[1], 30, 30)
        
        if player_rect.colliderect(obstacle_rect):
            terminated = True
            reward = -10.0
        
        if self.obstacle_pos[1] > self.height:
            self.obstacle_pos = [np.random.randint(0, self.width), 0]
            reward = 1.0

        if self.render_mode == "human": self._render_frame()
        return self._get_obs(), reward, terminated, False, {}

    def render(self):
        self._render_frame()

    def _render_frame(self):
        if self.screen is None:
            pygame.init()
            self.screen = pygame.display.set_mode((self.width, self.height))
        if self.clock is None: self.clock = pygame.time.Clock()
        self.screen.fill((255, 255, 255))
        pygame.draw.rect(self.screen, (0, 0, 255), (*self.player_pos, 30, 30))
        pygame.draw.rect(self.screen, (255, 0, 0), (*self.obstacle_pos, 30, 30))
        pygame.event.pump()
        pygame.display.update()
        self.clock.tick(self.metadata["render_fps"])

    def close(self):
        if self.screen is not None: pygame.quit()
                `
            }
        ];

        let currentSlide = 0;
        const sliderContainer = document.getElementById('slider-container');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const slideCounter = document.getElementById('slide-counter');

        function createSlide(slideData, index) {
            const slideElement = document.createElement('div');
            slideElement.className = 'slide p-4';
            slideElement.dataset.index = index;

            let codeHtml = '';
            if (slideData.code) {
                codeHtml = `
                    <div class="mt-6 bg-[#282c34] rounded-lg overflow-hidden border border-gray-700">
                        <pre class="language-python"><code>${slideData.code.trim()}</code></pre>
                    </div>
                `;
            }

            slideElement.innerHTML = `
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8 items-start">
                    <div>
                        <h2 class="text-2xl font-bold text-indigo-400 mb-4">${slideData.title}</h2>
                        <div class="text-gray-300 leading-relaxed space-y-2">${slideData.explanation}</div>
                    </div>
                    <div>
                        ${codeHtml}
                    </div>
                </div>
            `;
            return slideElement;
        }

        function updateSlider() {
            document.querySelectorAll('.slide').forEach((slide, index) => {
                slide.classList.toggle('active', index === currentSlide);
            });
            slideCounter.textContent = `${currentSlide + 1} / ${slides.length}`;
            prevBtn.disabled = currentSlide === 0;
            nextBtn.disabled = currentSlide === slides.length - 1;
            Prism.highlightAll();
        }

        prevBtn.addEventListener('click', () => {
            if (currentSlide > 0) {
                currentSlide--;
                updateSlider();
            }
        });

        nextBtn.addEventListener('click', () => {
            if (currentSlide < slides.length - 1) {
                currentSlide++;
                updateSlider();
            }
        });

        // Initialize slider
        slides.forEach((slideData, index) => {
            sliderContainer.appendChild(createSlide(slideData, index));
        });
        updateSlider();
    </script>
</body>
</html>
