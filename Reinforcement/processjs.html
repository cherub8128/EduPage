<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>범용 JS/AI 게임 제작 가이드 (v3.3)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Noto Sans KR', sans-serif; }
        .step { scroll-margin-top: 80px; }
        .prompt-block, .code-block-provided { position: relative; }
        .copy-button { position: absolute; top: 0.8rem; right: 0.8rem; background-color: #4A5568; color: white; padding: 0.25rem 0.6rem; border-radius: 0.375rem; font-size: 0.8rem; cursor: pointer; transition: background-color 0.2s; }
        .copy-button:hover { background-color: #2D3748; }
        .copy-button.copied { background-color: #2F855A; }
        .user-input { background-color: #FEF3C7; border: 1px dashed #FBBF24; padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem; }
        .workflow-guide { background-color: #E6FFFA; border: 1px solid #38B2AC; padding: 1.5rem; border-radius: 0.5rem; margin-top: 1.5rem; }
        .config-guide { background-color: #FFFBEB; border: 1px solid #F6E05E; padding: 1.5rem; border-radius: 0.5rem; margin-top: 1.5rem; }
        .modal-card { transition: transform 0.2s, box-shadow 0.2s; }
        .modal-card:hover { transform: translateY(-4px); box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1); }
        .tab-button { padding: 0.5rem 1rem; cursor: pointer; border-bottom: 2px solid transparent; transition: all 0.2s; color: #4A5568; }
        .tab-button.active { border-color: #F59E0B; color: #1E293B; font-weight: 600; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
    </style>
</head>
<body class="bg-slate-50 text-slate-800">

    <div id="theme-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-2xl shadow-2xl w-full max-w-4xl max-h-[90vh] flex flex-col">
            <div class="p-5 border-b flex justify-between items-center sticky top-0 bg-white rounded-t-2xl">
                <h2 class="text-xl font-bold text-slate-800">추천 게임 주제</h2>
                <button id="close-modal-btn" class="text-3xl font-light text-slate-500 hover:text-slate-800">&times;</button>
            </div>
            <div id="theme-grid" class="p-6 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-5 overflow-y-auto"></div>
        </div>
    </div>

    <div class="container mx-auto p-4 sm:p-6 md:p-8 max-w-4xl">
        <header class="text-center my-8 md:my-12">
            <h1 class="text-3xl sm:text-4xl md:text-5xl font-bold text-slate-900">범용 JS/AI 게임 제작 가이드 (v3.3)</h1>
            <p class="mt-4 text-base sm:text-lg text-slate-600">초보자부터 전문가까지, 자신만의 AI 게임을 만들 수 있는 최종 워크플로우</p>
        </header>
        
        <section id="step1" class="step bg-white p-6 sm:p-8 rounded-2xl shadow-lg border border-slate-200 mb-10">
            <h2 class="text-2xl font-bold mb-4 border-b pb-3 text-slate-900">단계 1: 게임 아이디어 구체화하기</h2>
            <p class="mb-4 text-slate-700">'추천 주제 보기' 버튼을 눌러 영감을 얻고, 상세 기획안을 요청하는 프롬프트를 복사하세요.</p>
            <button id="open-modal-btn" class="mb-6 bg-amber-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-amber-600 transition-colors">🎮 추천 주제 보기 & 영감 얻기</button>
            <div class="prompt-block">
                <button class="copy-button">복사</button>
                <pre class="bg-slate-100 text-slate-800 p-4 rounded-lg overflow-x-auto text-sm"><code id="step1-prompt-code" class="language-text">You are a creative game designer. Based on the theme "[여기에 선택한 게임 주제를 입력하세요]", please develop a detailed game plan with these four sections: Game Concept, Player Objective, Controls, Win/Loss Conditions. Write in Korean.</code></pre>
            </div>
        </section>

        <section id="step2" class="step bg-white p-6 sm:p-8 rounded-2xl shadow-lg border border-slate-200 mb-10">
            <h2 class="text-2xl font-bold mb-4 border-b pb-3 text-slate-900">단계 2: 통합 AI 웹 게임 제작</h2>
            <div class="user-input">
                <h3 class="font-semibold text-lg text-slate-800 mb-2">게임 기획안 입력</h3>
                <textarea id="game-logic-textarea" rows="8" class="w-full p-2 border border-amber-300 rounded-md bg-white text-sm" placeholder="이곳에 1단계에서 생성된 게임 기획안을 붙여넣으세요."></textarea>
            </div>
            <div class="prompt-block mt-6">
                <button class="copy-button">복사</button>
                <pre class="bg-slate-100 text-slate-800 p-4 rounded-lg overflow-x-auto text-sm"><code id="step2-prompt-code" class="language-text">You are an elite game developer, a master of Matter.js, and an expert in creating robust, AI-ready web games. Your task is to write the complete code for a single, self-contained index.html file based on the provided game plan.

**Game Logic Plan:**

[여기에 1단계에서 생성된 게임 기획안을 붙여넣으세요.]

**CRITICAL JavaScript Implementation Requirements:**

1.  **Game Modes & State:** Must support `USER`, `AI`, `TRAINING` modes. Use `sessionStorage` to remember the current mode after a refresh, automatically re-entering `TRAINING` mode if it was active.
2.  **WebSocket Interface:** Implement `connectWebSocket()` to connect to `ws://localhost:8765`. It must handle `reset` and `action` commands and send back `{observation, reward, done}` packets.
3.  **Robust Physics & Resets:** Use Matter.js collision categories to prevent bugs. Game resets (after scoring, dying, etc.) must be stable. Use a state flag (e.g., `isRoundOver`) and a short `setTimeout` to prevent multiple resets.
4.  **Core RL Functions:** Implement `getObservation()`, `resetForTraining()`, and `stepGameForTraining(action)`.
5.  **Visual Excellence:** The design must be minimalist and polished.

// --- For 2-Player / Self-Play Games ONLY ---
// If you are making a 2-player game, also implement the following:
/*
6.  **Dual ONNX Model Support:**
    * The game must load `model.onnx` and `opponent.onnx`. Use a cache-busting query (`?v=` + Date.now()) when loading `opponent.onnx`.
    * In `TRAINING` mode, the opponent character must be controlled by the `opponent.onnx` model. Decouple the AI's async decision-making from the synchronous physics loop (e.g., using `setInterval` for decisions and applying the latest decision in the main loop).
*/
</code></pre>
            </div>
        </section>

        <section id="step3" class="step bg-white p-6 sm:p-8 rounded-2xl shadow-lg border border-slate-200 mb-10">
            <h2 class="text-2xl font-bold mb-4 border-b pb-3 text-slate-900">단계 3: Python WebSocket 강화학습 환경 설정</h2>
            <p class="mb-4 text-slate-700">`websocket_env.py` 파일은 AI의 조작 방식에 따라 코드 내의 주석을 수정하여 **행동 공간**을 선택할 수 있습니다.</p>
             <div class="code-block-provided">
                <button class="copy-button">복사</button>
                <pre class="bg-slate-100 text-slate-800 p-4 rounded-lg overflow-x-auto text-sm"><code class="language-python"># websocket_env.py
import gymnasium as gym
from gymnasium import spaces
import numpy as np
import asyncio
import websockets
import json
import logging

logging.basicConfig(level=logging.INFO)

class WebSocketEnv(gym.Env):
    def __init__(self, observation_shape, action_space_config):
        super(WebSocketEnv, self).__init__()
        self.websocket = None
        self.loop = asyncio.get_event_loop()
        self.observation_space = spaces.Box(low=-np.inf, high=np.inf, shape=observation_shape, dtype=np.float32)

        if action_space_config['type'] == 'discrete':
            self.action_space = spaces.Discrete(action_space_config['n'])
        elif action_space_config['type'] == 'continuous':
            self.action_space = spaces.Box(
                low=np.array(action_space_config['low']),
                high=np.array(action_space_config['high']),
                dtype=np.float32
            )

        print("자바스크립트 클라이언트의 연결을 기다립니다...")
        self.server = self.loop.run_until_complete(websockets.serve(self._handler, "localhost", 8765))
        self.connection_future = self.loop.create_future()
        self.loop.run_until_complete(self._wait_for_connection())
        print("클라이언트가 연결되었습니다!")

    async def _handler(self, websocket, path):
        self.websocket = websocket
        if not self.connection_future.done():
            self.connection_future.set_result(True)
        try:
            await websocket.wait_closed()
        finally:
            self.websocket = None
            if not self.loop.is_closed():
                self.connection_future = self.loop.create_future()

    async def _wait_for_connection(self):
        await self.connection_future

    async def _ensure_connection(self):
        if self.websocket is None or not self.websocket.open:
            print("클라이언트 연결 끊김. 재연결을 기다립니다...")
            await self._wait_for_connection()
            print("클라이언트 재연결됨.")

    async def _send_command(self, command):
        await self._ensure_connection()
        try:
            await self.websocket.send(json.dumps(command))
        except websockets.exceptions.ConnectionClosed:
            print("송신 중 연결 끊김 감지, 재연결 대기...")
            await self._wait_for_connection()
            await self.websocket.send(json.dumps(command))

    async def _receive_observation(self):
        await self._ensure_connection()
        try:
            message = await self.websocket.recv()
        except websockets.exceptions.ConnectionClosed:
            print("수신 중 연결 끊김 감지, 재연결 대기...")
            await self._wait_for_connection()
            message = await self.websocket.recv()
        
        data = json.loads(message)
        if data.get("type") == "observation":
            return np.array(data["observation"], dtype=np.float32), data["reward"], data["done"]
        return None, None, None

    def reset(self, seed=None, options=None):
        super().reset(seed=seed)
        self.loop.run_until_complete(self._send_command({"command": "reset"}))
        obs, _, _ = self.loop.run_until_complete(self._receive_observation())
        return obs, {}

    def step(self, action):
        action_to_send = action.tolist() if isinstance(action, np.ndarray) else int(action)
        self.loop.run_until_complete(self._send_command({"command": "action", "action": action_to_send}))
        obs, reward, done = self.loop.run_until_complete(self._receive_observation())
        return obs, reward, done, False, {}

    def render(self, mode='human'): pass
    def close(self):
        if self.server: self.server.close()
        print("웹소켓 서버가 종료되었습니다.")
</code></pre>
            </div>
        </section>

        <section id="step4" class="step bg-white p-6 sm:p-8 rounded-2xl shadow-lg border border-slate-200 mb-10">
            <h2 class="text-2xl font-bold mb-4 border-b pb-3 text-slate-900">단계 4: AI 모델 학습</h2>
            <div class="border-b border-slate-200"><nav class="flex -mb-px" aria-label="Tabs">
                <button class="tab-button active" data-tab="simple">기본 학습 (1인용 게임)</button>
                <button class="tab-button" data-tab="selfplay">셀프 플레이 학습 (2인용 게임)</button>
            </nav></div>

            <div id="tab-simple" class="tab-content active mt-6">
                <div class="code-block-provided">
                    <button class="copy-button">복사</button>
                    <pre class="bg-slate-100 text-slate-800 p-4 rounded-lg overflow-x-auto text-sm"><code class="language-python"># train_simple.py
import os, time, webbrowser, threading
import http.server, socketserver
from stable_baselines3 import PPO
from stable_baselines3.common.callbacks import CheckpointCallback
from stable_baselines3.common.logger import configure
from websocket_env import WebSocketEnv

# --- 중요 설정 ---
OBSERVATION_SHAPE = (8,)
ACTION_SPACE_CONFIG = {'type': 'discrete', 'n': 5}
# ACTION_SPACE_CONFIG = {'type': 'continuous', 'low': [-1.0], 'high': [1.0]}
# -----------------
LOG_DIR, TOTAL_TIMESTEPS, PORT = "training_logs", 1_000_000, 8000

class WebServerThread(threading.Thread):
    def __init__(self, port):
        super().__init__()
        self.port, self.server, self.daemon = port, None, True
    def run(self):
        self.server = socketserver.TCPServer(("", self.port), http.server.SimpleHTTPRequestHandler)
        self.server.serve_forever()
    def stop(self):
        if self.server: self.server.shutdown()

def find_latest_run_and_checkpoint():
    if not os.path.isdir(LOG_DIR): return None, None
    runs = sorted([d for d in os.listdir(LOG_DIR) if os.path.isdir(os.path.join(LOG_DIR, d))], reverse=True)
    for run in runs:
        run_path = os.path.join(LOG_DIR, run)
        checkpoints_path = os.path.join(run_path, "checkpoints")
        if not os.path.isdir(checkpoints_path): continue
        checkpoints = [f for f in os.listdir(checkpoints_path) if f.startswith("rl_model_") and f.endswith(".zip")]
        if checkpoints:
            latest_checkpoint = max(checkpoints, key=lambda f: int(f.split("_")[2].replace(".zip", "")))
            return run, os.path.join(checkpoints_path, latest_checkpoint)
    return None, None

def main():
    web_server = WebServerThread(PORT)
    web_server.start()
    time.sleep(1)
    webbrowser.open(f'http://localhost:{PORT}')

    latest_run, latest_checkpoint = find_latest_run_and_checkpoint()
    run_path = os.path.join(LOG_DIR, latest_run) if latest_run else os.path.join(LOG_DIR, f"PPO_{int(time.time())}")
    checkpoint_path = os.path.join(run_path, "checkpoints")
    os.makedirs(checkpoint_path, exist_ok=True)
    
    env = WebSocketEnv(observation_shape=OBSERVATION_SHAPE, action_space_config=ACTION_SPACE_CONFIG)
    custom_logger = configure(run_path, ["stdout", "tensorboard"])
    checkpoint_callback = CheckpointCallback(save_freq=20000, save_path=checkpoint_path, name_prefix="rl_model")

    policy_type = "CnnPolicy" if len(OBSERVATION_SHAPE) == 3 else "MlpPolicy"
    
    if latest_checkpoint:
        print(f"체크포인트에서 학습을 재개합니다: {latest_checkpoint}")
        model = PPO.load(latest_checkpoint, env=env, device='auto')
    else:
        print(f"{policy_type} 정책으로 새로운 학습 세션을 시작합니다.")
        model = PPO(policy_type, env, verbose=1, device='auto')
    
    model.set_logger(custom_logger)
    try:
        model.learn(total_timesteps=TOTAL_TIMESTEPS, callback=checkpoint_callback, reset_num_timesteps=not bool(latest_checkpoint))
        model.save(os.path.join(run_path, "final_model.zip"))
    finally:
        env.close()
        web_server.stop()

if __name__ == '__main__':
    main()
</code></pre>
                </div>
            </div>

            <div id="tab-selfplay" class="tab-content mt-6">
                 <div class="code-block-provided">
                    <button class="copy-button">복사</button>
                    <pre class="bg-slate-100 text-slate-800 p-4 rounded-lg overflow-x-auto text-sm"><code class="language-python"># train_selfplay.py
import os, time, torch, webbrowser, threading
import http.server, socketserver
from stable_baselines3 import PPO
from stable_baselines3.common.logger import configure
from websocket_env import WebSocketEnv

# --- 중요 설정 ---
OBSERVATION_SHAPE = (8,)
ACTION_SPACE_CONFIG = {'type': 'discrete', 'n': 5}
# -----------------
TOTAL_TRAINING_STEPS, STEPS_PER_ITERATION = 1_000_000, 50_000
MODEL_DIR, LOG_DIR, PORT = "models", "training_logs", 8000
os.makedirs(MODEL_DIR, exist_ok=True)
os.makedirs(LOG_DIR, exist_ok=True)

class WebServerThread(threading.Thread):
    def __init__(self, port):
        super().__init__()
        self.port, self.server, self.daemon = port, None, True
    def run(self):
        self.server = socketserver.TCPServer(("", self.port), http.server.SimpleHTTPRequestHandler)
        self.server.serve_forever()
    def stop(self):
        if self.server: self.server.shutdown()

class OnnxablePolicy(torch.nn.Module):
    def __init__(self, policy):
        super().__init__()
        self.policy = policy
    def forward(self, observation):
        action, _ = self.policy.predict(observation.cpu().numpy(), deterministic=True)
        return torch.from_numpy(action).to(observation.device)

def export_to_onnx(model_path, onnx_path):
    print(f"\n모델 {model_path}를 ONNX 형식({onnx_path})으로 변환합니다...")
    model = PPO.load(model_path, device='cpu')
    onnxable_model = OnnxablePolicy(model.policy)
    dummy_input = torch.randn(1, *OBSERVATION_SHAPE)
    torch.onnx.export(onnxable_model, dummy_input, onnx_path, opset_version=12,
                      input_names=["observation"], output_names=["action"])
    print("ONNX 변환 완료.")

def main():
    web_server = WebServerThread(PORT)
    web_server.start()
    time.sleep(1)
    webbrowser.open(f'http://localhost:{PORT}')
    
    env = WebSocketEnv(observation_shape=OBSERVATION_SHAPE, action_space_config=ACTION_SPACE_CONFIG)
    
    run_path = os.path.join(LOG_DIR, f"PPO_SelfPlay_{int(time.time())}")
    custom_logger = configure(run_path, ["stdout", "tensorboard"])
    latest_model_path = os.path.join(MODEL_DIR, "latest_model.zip")
    
    policy_type = "CnnPolicy" if len(OBSERVATION_SHAPE) == 3 else "MlpPolicy"

    if os.path.exists(latest_model_path):
        print(f"저장된 모델 {latest_model_path}에서 학습을 재개합니다.")
        model = PPO.load(latest_model_path, env=env, device='auto')
    else:
        print(f"{policy_type} 정책으로 새로운 학습을 시작합니다.")
        model = PPO(policy_type, env, verbose=1, device='auto')
        
    model.set_logger(custom_logger)
    
    if not os.path.exists("opponent.onnx"):
        print("'opponent.onnx' 파일이 없어 현재 에이전트로 초기 상대를 생성합니다.")
        model.save(os.path.join(MODEL_DIR, "initial_model.zip"))
        export_to_onnx(os.path.join(MODEL_DIR, "initial_model.zip"), "opponent.onnx")
    else:
        print("기존 'opponent.onnx' 파일을 초기 상대로 사용합니다.")
    
    try:
        total_steps_done = model.num_timesteps
        while total_steps_done < TOTAL_TRAINING_STEPS:
            model.learn(total_timesteps=total_steps_done + STEPS_PER_ITERATION, reset_num_timesteps=False)
            total_steps_done = model.num_timesteps
            model.save(latest_model_path)
            export_to_onnx(latest_model_path, "opponent.onnx")
            if total_steps_done < TOTAL_TRAINING_STEPS:
                input(f"--- CHECKPOINT ({total_steps_done}/{TOTAL_TRAINING_STEPS} steps) ---\n"
                      f">>> 상대방 모델이 업데이트되었습니다. 브라우저를 새로고침(F5)한 뒤, 여기서 Enter를 누르세요...")
    finally:
        env.close()
        web_server.stop()

if __name__ == '__main__':
    main()
</code></pre>
                </div>
            </div>
            <div class="config-guide">
                <h4 class="text-lg font-bold">AI 설정 가이드</h4>
                <div class="mt-4">
                    <h5 class="font-semibold">관찰 공간(Observation Space) - AI의 '눈'</h5>
                    <p class="text-sm text-slate-700">AI가 게임 세상을 보는 방식을 결정합니다. SB3는 이 형태를 보고 AI의 뇌(정책)를 자동으로 결정합니다.</p>
                    <ul class="list-disc pl-5 mt-2 space-y-2 text-sm">
                        <li><strong>벡터 관찰:</strong> `(숫자,)` 형태 (예: `(8,)`). AI는 `[좌표, 속도, 거리]` 등 숫자 리스트로 상태를 인식합니다. 이때 SB3는 자동으로 **MlpPolicy** (표준 신경망)를 사용합니다.</li>
                        <li><strong>이미지 관찰:</strong> `(채널, 높이, 너비)` 형태 (예: `(1, 84, 84)`). AI는 게임 화면 픽셀 자체를 보고 학습합니다. JS에서 `canvas`의 픽셀 데이터를 추출해 Python으로 보내야 합니다. 이때 SB3는 자동으로 **CnnPolicy** (이미지 처리용 신경망)를 사용합니다.</li>
                    </ul>
                </div>
                <div class="mt-4">
                    <h5 class="font-semibold">행동 공간(Action Space) - AI의 '손'</h5>
                    <p class="text-sm text-slate-700">AI의 조작 방식을 결정합니다.</p>
                    <ul class="list-disc pl-5 mt-2 space-y-2 text-sm">
                        <li><strong>이산(Discrete) 행동:</strong> "점프", "왼쪽" 같이 버튼처럼 딱딱 끊어지는 행동입니다. JS의 `applyAction` 함수는 `0, 1, 2...` 같은 정수 하나를 받습니다.</li>
                        <li><strong>연속(Continuous) 행동:</strong> 로켓 추진력(-1.0 ~ 1.0)처럼 세밀하고 연속적인 값으로 조작합니다. JS의 `applyAction` 함수는 `[-0.5, 0.88]` 과 같은 숫자 배열을 받습니다.</li>
                    </ul>
                </div>
            </div>
        </section>

        <section id="step5" class="step bg-white p-6 sm:p-8 rounded-2xl shadow-lg border border-slate-200 mb-10">
            <h2 class="text-2xl font-bold mb-4 border-b pb-3 text-slate-900">단계 5: 최종 모델 변환</h2>
             <div class="code-block-provided">
                <button class="copy-button">복사</button>
                <pre class="bg-slate-100 text-slate-800 p-4 rounded-lg overflow-x-auto text-sm"><code class="language-python"># convert_onnx.py
import torch
from stable_baselines3 import PPO
import os, sys

# --- 중요 설정 ---
OBSERVATION_SHAPE = (8,) # 학습 스크립트와 동일해야 함
# -----------------

class OnnxablePolicy(torch.nn.Module):
    def __init__(self, policy):
        super().__init__()
        self.policy = policy
    def forward(self, observation):
        action, _ = self.policy.predict(observation.cpu().numpy(), deterministic=True)
        return torch.from_numpy(action).to(observation.device)

def main(source_path, output_path):
    if not os.path.exists(source_path):
        print(f"오류: {source_path}에서 원본 모델을 찾을 수 없습니다.")
        return
    print(f"{source_path}에서 최종 모델을 불러옵니다...")
    model = PPO.load(source_path, device='cpu')
    onnxable_model = OnnxablePolicy(model.policy)
    dummy_input = torch.randn(1, *OBSERVATION_SHAPE)
    print(f"{output_path} 파일로 내보내는 중...")
    torch.onnx.export(onnxable_model, dummy_input, output_path, opset_version=12,
                      input_names=["observation"], output_names=["action"])
    print(f"최종 모델 변환 완료! 이제 'AI 모드'에서 플레이할 수 있습니다.")

if __name__ == '__main__':
    if len(sys.argv) != 3:
        print("사용법: python convert_onnx.py <입력_zip_경로> <출력_onnx_경로>")
        print("예시: python convert_onnx.py models/latest_model.zip model.onnx")
    else:
        main(sys.argv[1], sys.argv[2])
</code></pre>
            </div>
        </section>

        <section id="step6" class="step bg-white p-6 sm:p-8 rounded-2xl shadow-lg border border-slate-200 mb-10">
            <h2 class="text-2xl font-bold mb-4 border-b pb-3 text-slate-900">단계 6: 최종 AI 게임 테스트</h2>
             <p class="mb-4 text-slate-700">웹 서버(`python -m http.server`)를 실행한 상태에서 `http://localhost:8000`에 접속하여 **'AI 모드'**를 클릭하고 최종 테스트합니다.</p>
        </section>

        <section id="step7" class="step bg-white p-6 sm:p-8 rounded-2xl shadow-lg border border-slate-200 mb-10">
            <h2 class="text-2xl font-bold mb-4 border-b pb-3 text-slate-900">단계 7: GitHub Pages 배포</h2>
            <p class="mb-6 text-slate-700">`index.html`, `model.onnx` 파일 (+셀프플레이의 경우 `opponent.onnx`)이 모두 있는지 확인하고 GitHub에 업로드하여 전 세계에 공유하세요.</p>
        </section>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.copy-button').forEach(button => {
                button.addEventListener('click', () => {
                    const code = button.parentElement.querySelector('code').innerText;
                    navigator.clipboard.writeText(code).then(() => {
                        button.textContent = '복사 완료!';
                        button.classList.add('copied');
                        setTimeout(() => {
                            button.textContent = '복사';
                            button.classList.remove('copied');
                        }, 2000);
                    });
                });
            });

            const gameLogicTextarea = document.getElementById('game-logic-textarea');
            const step2PromptCodeElement = document.getElementById('step2-prompt-code');
            if (gameLogicTextarea && step2PromptCodeElement) {
                const baseStep2Prompt = step2PromptCodeElement.innerText;
                gameLogicTextarea.addEventListener('input', () => {
                    const userInput = gameLogicTextarea.value;
                    if (userInput.trim() !== '') {
                        step2PromptCodeElement.innerText = baseStep2Prompt.replace("[여기에 1단계에서 생성된 게임 기획안을 붙여넣으세요.]", userInput);
                    } else {
                        step2PromptCodeElement.innerText = baseStep2Prompt;
                    }
                });
            }

            const tabButtons = document.querySelectorAll('.tab-button');
            const tabContents = document.querySelectorAll('.tab-content');
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    const tabId = button.getAttribute('data-tab');
                    tabContents.forEach(content => {
                        content.classList.remove('active');
                        if (content.id === `tab-${tabId}`) {
                            content.classList.add('active');
                        }
                    });
                });
            });
            
            const modal = document.getElementById('theme-modal');
            const openModalBtn = document.getElementById('open-modal-btn');
            const closeModalBtn = document.getElementById('close-modal-btn');
            const themeGrid = document.getElementById('theme-grid');
            const step1PromptCodeElement = document.getElementById('step1-prompt-code');

            async function loadThemes() {
                try {
                    const themesData = [
                        {"emoji":"🚀","title":"로켓 착륙","description":"추력을 조절해 로켓을 착륙 패드에 안착시키세요.","rl_concept":"A game about landing a rocket safely on a platform using thrusters."},
                        {"emoji":"🚗","title":"자율 주차","description":"AI가 장애물을 피해 주차 공간에 차를 넣도록 학습시키세요.","rl_concept":"A top-down car parking game where the AI must navigate obstacles."},
                        {"emoji":"🏐","title":"2D 볼리볼","description":"물리 기반의 2D 배구 게임에서 상대방 AI와 대결하세요.","rl_concept":"A 2D physics-based volleyball game."},
                        {"emoji":"🐍","title":"스네이크 게임","description":"먹이를 먹고 점점 길어지는 클래식 스네이크 게임입니다.","rl_concept":"The classic Snake game where the agent learns to eat food and avoid collisions."}
                    ];
                    
                    themeGrid.innerHTML = '';
                    themesData.forEach(theme => {
                        const card = document.createElement('div');
                        card.className = 'modal-card bg-slate-50 p-4 rounded-lg cursor-pointer border hover:border-amber-500 hover:bg-amber-50';
                        card.innerHTML = `<div class="text-3xl mb-2">${theme.emoji}</div><h3 class="font-bold text-slate-800">${theme.title}</h3><p class="text-sm text-slate-600 mt-1">${theme.description}</p>`;
                        card.addEventListener('click', () => {
                            const basePrompt = `You are a creative game designer. Based on the theme "[THEME_PLACEHOLDER]", please develop a detailed game plan...`;
                            const promptToCopy = basePrompt.replace('[THEME_PLACEHOLDER]', `"${theme.rl_concept}"`);
                            if(step1PromptCodeElement) step1PromptCodeElement.textContent = promptToCopy;
                            navigator.clipboard.writeText(promptToCopy).then(() => {
                                 alert(`'${theme.title}' 주제의 프롬프트가 클립보드에 복사되었습니다.`);
                            });
                            if(modal) modal.classList.add('hidden');
                        });
                        themeGrid.appendChild(card);
                    });
                } catch (error) { console.error("Could not load themes:", error); }
            }

            if(modal && openModalBtn && closeModalBtn) {
                 openModalBtn.addEventListener('click', () => modal.classList.remove('hidden'));
                 closeModalBtn.addEventListener('click', () => modal.classList.add('hidden'));
                 modal.addEventListener('click', (e) => { if (e.target.id === 'theme-modal') modal.classList.add('hidden'); });
                loadThemes();
            }
        });
    </script>
</body>
</html>
