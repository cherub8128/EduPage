<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pygame 게임으로 강화학습 시작하기 (Full ver.)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #282c34;
            color: #abb2bf;
        }
        .slide {
            display: none;
        }
        .slide.active {
            display: block;
        }
        .code-highlight {
            background-color: rgba(255, 255, 0, 0.15);
            display: block;
            margin: -0.25rem -0.5rem;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
        }
        pre[class*="language-"] {
            font-size: 0.9rem;
            line-height: 1.6;
        }
        .explanation-box {
            background-color: #21252b;
            border-left: 4px solid #61afef;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-7xl mx-auto bg-[#21252b] rounded-xl shadow-2xl overflow-hidden">
        <div class="p-8">
            <h1 class="text-3xl md:text-4xl font-bold text-white text-center">Pygame 게임으로 나만의 강화학습 환경 만들기</h1>
            <p class="text-center text-gray-400 mt-2">슬라이드를 넘기며 한 단계씩 따라 해보세요!</p>
        </div>

        <div id="slider-container" class="p-4 md:p-8 border-t border-gray-700 min-h-[500px]">
            <!-- Slides will be injected here by JS -->
        </div>

        <div class="bg-[#282c34] p-4 flex justify-between items-center">
            <button id="prevBtn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed">이전</button>
            <div id="slide-counter" class="text-white text-lg font-semibold"></div>
            <button id="nextBtn" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg transition duration-300">다음</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        const slides = [
            {
                title: "1. 목표: Pygame 게임을 AI 놀이터로 만들기",
                explanation: `
                    <p>우리의 목표는 Pygame으로 만든 게임을 강화학습 AI가 이해하고 플레이할 수 있는 표준화된 '놀이터(환경)'로 만드는 것입니다.</p>
                    <p class="mt-2">AI 에이전트는 <strong>'Gymnasium'</strong>이라는 표준 API(규칙)를 따르는 환경하고만 상호작용할 수 있습니다. 마치 표준 USB 포트에만 장치를 연결할 수 있는 것과 같죠.</p>
                    <div class="explanation-box">
                        <p><strong>핵심 작업:</strong><br>
                        Pygame 게임 로직을 <code class="bg-gray-700 p-1 rounded">gymnasium.Env</code> 클래스로 감싸서(Wrapping), AI와 소통할 수 있는 표준 함수(<code class="bg-gray-700 p-1 rounded">reset</code>, <code class="bg-gray-700 p-1 rounded">step</code>)를 가진 객체로 변환합니다.</p>
                    </div>
                `,
                code: ``
            },
            {
                title: "2. 기본 뼈대 만들기",
                explanation: `
                    <p>먼저, Gymnasium 라이브러리의 기본 환경 틀인 <code class="bg-gray-700 p-1 rounded">gym.Env</code>를 상속받는 우리만의 클래스를 만듭니다. 이것이 우리 환경의 기본 뼈대가 됩니다.</p>
                    <p class="mt-2">모든 강화학습 환경은 이 <code class="bg-gray-700 p-1 rounded">gym.Env</code> 라는 약속된 틀을 따라야 합니다.</p>
                `,
                code: `
<span class="code-highlight">import gymnasium as gym</span>
import pygame
import numpy as np
from gymnasium import spaces

<span class="code-highlight">class PygameEnv(gym.Env):</span>
    # 앞으로 이 안에 모든 코드를 작성할 거예요.
    pass
                `
            },
            {
                title: "3. `__init__` : 환경 설계도 (기본 설정)",
                explanation: `
                    <p><code class="bg-gray-700 p-1 rounded">__init__</code> 함수는 우리 환경이 처음 만들어질 때 딱 한 번 실행되는 '설계도'입니다. 여기서 게임의 기본 설정을 정합니다.</p>
                    <p class="mt-2">게임 창의 크기 같은 기본적인 것들을 설정해줍니다.</p>
                `,
                code: `
import gymnasium as gym
import pygame
import numpy as np
from gymnasium import spaces

class PygameEnv(gym.Env):
<span class="code-highlight">    def __init__(self):</span>
<span class="code-highlight">        super().__init__() # gym.Env의 초기 설정도 가져옵니다.</span>
<span class="code-highlight">        </span>
<span class="code-highlight">        # Pygame 창 크기 설정</span>
<span class="code-highlight">        self.width = 600</span>
<span class="code-highlight">        self.height = 400</span>
                `
            },
            {
                title: "4. `__init__` : 행동 공간 정의",
                explanation: `
                    <p>설계도에 이어서, AI가 할 수 있는 <strong>행동의 종류</strong>를 알려줘야 합니다. 이것을 '행동 공간(Action Space)'이라고 합니다.</p>
                    <p class="mt-2">TV 리모컨의 버튼을 정해주는 것과 같아요. 우리 게임에서는 '왼쪽', '가만히 있기', '오른쪽' 세 가지 버튼만 만들겠습니다.</p>
                    <p class="mt-2"><code class="bg-gray-700 p-1 rounded">spaces.Discrete(3)</code>는 0, 1, 2 세 개의 정수 중 하나를 행동으로 선택할 수 있다는 의미입니다.</p>
                `,
                code: `
class PygameEnv(gym.Env):
    def __init__(self):
        super().__init__()
        
        self.width = 600
        self.height = 400

<span class="code-highlight">        # 0: 왼쪽, 1: 가만히 있기, 2: 오른쪽</span>
<span class="code-highlight">        self.action_space = spaces.Discrete(3)</span>
                `
            },
            {
                title: "5. `__init__` : 관찰 공간 정의",
                explanation: `
                    <p>AI가 '보는' 것, 즉 <strong>상태 정보</strong>의 형태도 알려줘야 합니다. 이것을 '관찰 공간(Observation Space)'이라고 합니다.</p>
                    <p class="mt-2">AI에게 어떤 TV 화면을 보여줄지 정하는 것과 같아요. 우리는 게임 화면 전체를 컬러(RGB) 이미지로 보여줄 겁니다.</p>
                    <p class="mt-2"><code class="bg-gray-700 p-1 rounded">spaces.Box(...)</code>는 숫자들의 네모난 배열(이미지 픽셀)을 의미합니다. 각 픽셀은 0~255 사이의 RGB 값을 가집니다.</p>
                `,
                code: `
class PygameEnv(gym.Env):
    def __init__(self):
        # ... 이전 코드 생략 ...
        self.action_space = spaces.Discrete(3)

<span class="code-highlight">        # 게임 화면 픽셀을 관찰 공간으로 사용</span>
<span class="code-highlight">        self.observation_space = spaces.Box(</span>
<span class="code-highlight">            low=0, high=255, </span>
<span class="code-highlight">            shape=(self.width, self.height, 3), </span>
<span class="code-highlight">            dtype=np.uint8</span>
<span class="code-highlight">        )</span>
                `
            },
            {
                title: "6. `reset` : 새 게임 시작하기",
                explanation: `
                    <p><code class="bg-gray-700 p-1 rounded">reset</code> 함수는 게임 한 판이 끝나거나 처음 시작할 때 호출됩니다. 모든 것을 초기 상태로 되돌리는 역할을 합니다.</p>
                    <p class="mt-2">마치 게임기의 '리셋 버튼'과 같아요. 플레이어와 장애물을 처음 위치로 돌려놓고, AI에게 초기 화면(<code class="bg-gray-700 p-1 rounded">observation</code>)을 보여줍니다.</p>
                `,
                code: `
class PygameEnv(gym.Env):
    # ... __init__ 생략 ...

<span class="code-highlight">    def reset(self, seed=None, options=None):</span>
<span class="code-highlight">        super().reset(seed=seed)</span>
<span class="code-highlight">        </span>
<span class="code-highlight">        # 플레이어와 장애물 위치를 처음으로 되돌림</span>
<span class="code-highlight">        self.player_pos = [self.width // 2, self.height - 50]</span>
<span class="code-highlight">        self.obstacle_pos = [np.random.randint(0, self.width), 0]</span>
<span class="code-highlight">        </span>
<span class="code-highlight">        # _get_obs()는 현재 화면을 Numpy 배열로 바꿔주는 함수 (나중에 구현)</span>
<span class="code-highlight">        observation = self._get_obs() </span>
<span class="code-highlight">        info = {} # 추가 정보 (지금은 비워둠)</span>
<span class="code-highlight">        </span>
<span class="code-highlight">        return observation, info</span>
                `
            },
            {
                title: "7. `step` : 한 걸음 나아가기 (Action)",
                explanation: `
                    <p><code class="bg-gray-700 p-1 rounded">step</code> 함수는 AI가 행동을 하나 결정했을 때 호출됩니다. 이 함수 안에서 게임 세상의 시간이 한 프레임 흐릅니다.</p>
                    <p class="mt-2">가장 중요한 함수로, AI의 행동을 게임에 반영하고 그 결과를 AI에게 알려줍니다.</p>
                `,
                code: `
class PygameEnv(gym.Env):
    # ... 이전 코드 생략 ...

<span class="code-highlight">    def step(self, action):</span>
<span class="code-highlight">        # 1. AI가 선택한 행동(action)을 게임에 반영</span>
<span class="code-highlight">        if action == 0: self.player_pos[0] -= 10 # 왼쪽</span>
<span class="code-highlight">        elif action == 2: self.player_pos[0] += 10 # 오른쪽</span>
<span class="code-highlight">        </span>
<span class="code-highlight">        # 2. 게임 환경의 변화 (장애물 이동 등)</span>
<span class="code-highlight">        self.obstacle_pos[1] += 7</span>
<span class="code-highlight">        </span>
<span class="code-highlight">        # 3. 행동의 결과 계산 (보상, 게임 종료 여부)</span>
<span class="code-highlight">        # ... 다음 슬라이드에서 계속 ...</span>
                `
            },
            {
                title: "8. `step` : 결과 계산 (보상과 종료)",
                explanation: `
                    <p>AI의 행동이 어떤 결과를 낳았는지 계산합니다.</p>
                    <ul class="list-disc list-inside space-y-2 mt-2">
                        <li><strong>보상(reward)</strong>: 행동이 얼마나 좋았는지 알려주는 점수입니다. (피하면 +, 부딪히면 -)</li>
                        <li><strong>종료(terminated)</strong>: 게임이 끝났는지 알려주는 신호입니다. (부딪히면 True)</li>
                    </ul>
                    <p class="mt-2">이 보상과 종료 신호가 AI를 똑똑하게 만드는 핵심 재료입니다.</p>
                `,
                code: `
    def step(self, action):
        # ... 이전 코드 생략 ...

<span class="code-highlight">        terminated = False</span>
<span class="code-highlight">        reward = 0.1  # 살아있으면 기본 점수</span>

<span class="code-highlight">        # 플레이어와 장애물이 부딪혔나?</span>
<span class="code-highlight">        player_rect = pygame.Rect(self.player_pos[0], self.player_pos[1], 30, 30)</span>
<span class="code-highlight">        obstacle_rect = pygame.Rect(self.obstacle_pos[0], self.obstacle_pos[1], 30, 30)</span>
<span class="code-highlight">        if player_rect.colliderect(obstacle_rect):</span>
<span class="code-highlight">            terminated = True # 게임 종료!</span>
<span class="code-highlight">            reward = -10.0 # 큰 벌점</span>
<span class="code-highlight">        </span>
<span class="code-highlight">        # 장애물을 성공적으로 피했나?</span>
<span class="code-highlight">        if self.obstacle_pos[1] > self.height:</span>
<span class="code-highlight">            self.obstacle_pos = [np.random.randint(0, self.width), 0] # 새 장애물</span>
<span class="code-highlight">            reward = 1.0 # 상점</span>
                `
            },
            {
                title: "9. `step` : 결과 보고하기",
                explanation: `
                    <p>마지막으로, <code class="bg-gray-700 p-1 rounded">step</code> 함수는 계산된 모든 결과를 AI에게 '보고'해야 합니다. 이 보고서에는 정해진 5가지 항목이 포함되어야 합니다.</p>
                    <ol class="list-decimal list-inside space-y-1 mt-2">
                        <li><strong>observation</strong>: 행동 후의 게임 화면</li>
                        <li><strong>reward</strong>: 행동에 대한 점수</li>
                        <li><strong>terminated</strong>: 게임이 끝났는지 여부</li>
                        <li><strong>truncated</strong>: (시간 초과 등) 게임이 중단되었는지 여부 (지금은 False)</li>
                        <li><strong>info</strong>: 추가 정보 (지금은 빈 딕셔너리)</li>
                    </ol>
                `,
                code: `
    def step(self, action):
        # ... 이전 코드 생략 ...

<span class="code-highlight">        observation = self._get_obs()</span>
<span class="code-highlight">        info = {}</span>
<span class="code-highlight">        </span>
<span class="code-highlight">        return observation, reward, terminated, False, info</span>
                `
            },
            {
                title: "10. 보조 함수들: `render`, `_get_obs`, `close`",
                explanation: `
                    <p>마지막으로 환경을 원활하게 운영하기 위한 보조 함수들을 만듭니다.</p>
                    <ul class="list-disc list-inside space-y-2 mt-2">
                        <li><strong>_get_obs()</strong>: 현재 Pygame 화면을 AI가 이해할 수 있는 Numpy 배열로 변환합니다.</li>
                        <li><strong>render()</strong>: 우리가 직접 게임 화면을 보고 싶을 때 화면을 그려줍니다.</li>
                        <li><strong>close()</strong>: 학습이 모두 끝났을 때 Pygame 창을 안전하게 닫습니다.</li>
                    </ul>
                `,
                code: `
class PygameEnv(gym.Env):
    # ... 이전 코드 생략 ...
<span class="code-highlight">    def _get_obs(self):</span>
<span class="code-highlight">        # Pygame surface를 numpy array로 변환</span>
<span class="code-highlight">        return pygame.surfarray.array3d(self.screen).transpose([1, 0, 2])</span>

<span class="code-highlight">    def render(self):</span>
<span class="code-highlight">        # Pygame 화면을 그리는 로직 (전체 코드에서 확인)</span>
<span class="code-highlight">        pass</span>

<span class="code-highlight">    def close(self):</span>
<span class="code-highlight">        if self.screen is not None: pygame.quit()</span>
                `
            },
            {
                title: "11. 완성된 환경 코드 (PygameEnv)",
                explanation: `
                    <p>지금까지 우리가 만든 조각들을 모두 합치면 완전한 Gymnasium 환경 코드가 됩니다.</p>
                    <p class="mt-2">이제 이 <code class="bg-gray-700 p-1 rounded">PygameEnv</code> 클래스는 어떤 강화학습 라이브러리(예: Stable-Baselines3)와도 호환되는 완벽한 '게임팩'이 되었습니다.</p>
                    <div class="explanation-box">
                        <p><strong>핵심 기능 요약:</strong><br>
                        - <code class="bg-gray-700 p-1 rounded">__init__</code>: 행동/관찰 공간 정의<br>
                        - <code class="bg-gray-700 p-1 rounded">reset</code>: 게임 초기화<br>
                        - <code class="bg-gray-700 p-1 rounded">step</code>: 게임 진행 및 결과 반환
                        </p>
                    </div>
                `,
                code: `
import pygame
import numpy as np
import gymnasium as gym
from gymnasium import spaces

class PygameEnv(gym.Env):
    metadata = {"render_modes": ["human"], "render_fps": 30}

    def __init__(self, render_mode=None):
        # ... (전체 코드는 너무 길어 생략, 핵심 구조만 확인)
        pass

    def _get_obs(self):
        # ...
        pass

    def reset(self, seed=None, options=None):
        # ...
        return self._get_obs(), {}

    def step(self, action):
        # ...
        return self._get_obs(), reward, terminated, False, {}

    def render(self):
        # ...
        pass

    def _render_frame(self):
        # ...
        pass

    def close(self):
        # ...
        pass
                `
            },
            {
                title: "12. AI 에이전트 훈련시키기 (Stable-Baselines3)",
                explanation: `
                    <p>이제 완성된 환경을 가지고 실제 AI 에이전트를 훈련시켜 봅시다. <strong>Stable-Baselines3</strong>는 PPO, DQN 등 유명한 알고리즘들을 미리 구현해 놓은 강력한 라이브러리입니다.</p>
                    <div class="explanation-box">
                        <p>단 몇 줄의 코드로 훈련을 시작할 수 있습니다. 아래 코드는 별도의 파이썬 파일(<code class="bg-gray-700 p-1 rounded">train.py</code>)로 저장하여 실행합니다.</p>
                        <p class="text-sm mt-2">(라이브러리 설치: <code class="bg-gray-700 p-1 rounded">pip install stable-baselines3[extra]</code>)</p>
                    </div>
                `,
                code: `
# train.py
# from pygame_env import PygameEnv # 우리가 만든 환경 클래스 import
from stable_baselines3 import PPO

# 1. 환경 생성
env = PygameEnv(render_mode="human")
env.reset()

# 2. 모델 생성 (PPO 알고리즘 사용)
model = PPO("CnnPolicy", env, verbose=1)

# 3. 모델 학습 시작 (총 20,000 타임스텝)
model.learn(total_timesteps=20000)

# 4. 학습된 모델 저장
model.save("ppo_pygame")

env.close()
                `
            },
            {
                title: "13. 참고: 다양한 행동 공간(Action Space)",
                explanation: `
                    <p>AI의 행동은 게임에 따라 다양합니다. Gymnasium은 여러 종류의 행동 공간을 미리 정의해 두었습니다.</p>
                `,
                code: `
# --- 이산 공간 (정해진 개수 중 하나 선택) ---
# 예: 상, 하, 좌, 우 (4가지 행동)
<span class="code-highlight">action_space = spaces.Discrete(4)</span>
# action -> 0, 1, 2, 3 중 하나

# --- 연속 공간 (특정 범위 내의 실수 값) ---
# 예: 자동차 핸들 각도 (-1.0 ~ 1.0)
<span class="code-highlight">action_space = spaces.Box(low=-1.0, high=1.0, shape=(1,), dtype=np.float32)</span>
# action -> [-0.5], [0.8] 등

# --- 다중 이산 공간 (여러 개의 독립적인 이산 행동) ---
# 예: (이동: 상/하/좌/우) 와 (공격: A/B 버튼)을 동시에 선택
<span class="code-highlight">action_space = spaces.MultiDiscrete([4, 2])</span>
# action -> [2, 0] (좌로 이동하며 A버튼 누르기)

# --- 다중 바이너리 공간 (여러 개의 독립적인 On/Off 행동) ---
# 예: 키보드의 W, A, S, D 키를 동시에 누르거나 떼기
<span class="code-highlight">action_space = spaces.MultiBinary(4)</span>
# action -> [1, 0, 1, 0] (W와 S키를 누름)
                `
            },
            {
                title: "14. 참고: 다양한 관찰 공간(Observation Space)",
                explanation: `
                    <p>AI가 보는 세상(상태)도 여러 방식으로 표현할 수 있습니다. 게임 화면 전체를 줄 수도 있고, 핵심적인 숫자 데이터만 줄 수도 있습니다.</p>
                `,
                code: `
# --- 이미지 관찰 (Box) ---
# 예: 2D 게임 화면 (600x400 RGB)
<span class="code-highlight">observation_space = spaces.Box(low=0, high=255, shape=(600, 400, 3), dtype=np.uint8)</span>
# self._get_obs() -> return pygame.surfarray.array3d(self.screen) ...

# --- 벡터 관찰 (Box) ---
# 예: 플레이어 위치(x,y), 장애물 위치(x,y) 등 핵심 정보만 제공
<span class="code-highlight">observation_space = spaces.Box(low=-np.inf, high=np.inf, shape=(4,), dtype=np.float32)</span>
# self._get_obs() -> return np.array([self.player_pos_x, self.player_pos_y, ...])

# --- 사전 관찰 (Dict) ---
# 예: 이미지와 벡터 정보를 모두 제공
<span class="code-highlight">observation_space = spaces.Dict({</span>
<span class="code-highlight">    "image": spaces.Box(low=0, high=255, shape=(64, 64, 3), dtype=np.uint8),</span>
<span class="code-highlight">    "vector": spaces.Box(low=-np.inf, high=np.inf, shape=(4,), dtype=np.float32)</span>
<span class="code-highlight">})</span>
# self._get_obs() -> return { "image": ..., "vector": ... }
                `
            },
            {
                title: "15. 학습된 AI 시뮬레이션 (Pong)",
                explanation: `
                    <p>학습이 완료된 AI 에이전트가 어떻게 행동하는지 관찰해 보세요.</p>
                    <p class="mt-2">아래 시뮬레이션은 AI 패들이 공을 놓치지 않기 위해 공의 위치를 따라 좌우로 움직이는 모습을 보여줍니다.</p>
                    <div id="simulation-container" class="mt-4">
                         <div class="w-full max-w-sm mx-auto bg-gray-900 rounded-lg relative" style="height: 300px; border: 2px solid #4a5568;">
                             <div id="paddle" class="absolute bg-blue-400 rounded" style="width: 80px; height: 10px; bottom: 20px; left: calc(50% - 40px);"></div>
                             <div id="ball" class="absolute bg-yellow-300 rounded-full" style="width: 15px; height: 15px; top: 50px; left: 50%;"></div>
                         </div>
                         <div class="mt-4 text-center">
                            <button id="start-sim-btn" class="bg-indigo-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-indigo-700 transition" onclick="startSimulation()">시뮬레이션 시작</button>
                         </div>
                         <div class="mt-4 bg-gray-900 p-3 rounded-lg">
                            <h3 class="font-semibold mb-2 text-gray-400">시뮬레이션 로그:</h3>
                            <div id="sim-log" class="text-sm text-gray-400 font-mono h-20 overflow-y-auto"></div>
                         </div>
                    </div>
                `,
                code: ``
            }
        ];

        let currentSlide = 0;
        const sliderContainer = document.getElementById('slider-container');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const slideCounter = document.getElementById('slide-counter');

        function createSlide(slideData, index) {
            const slideElement = document.createElement('div');
            slideElement.className = 'slide p-4';
            slideElement.dataset.index = index;

            let codeHtml = '';
            if (slideData.code) {
                const tempDiv = document.createElement('div');
                const codeWithPlaceholders = slideData.code.trim()
                    .replace(/<span class="code-highlight">/g, '[[HIGHLIGHT_START]]')
                    .replace(/<\/span>/g, '[[HIGHLIGHT_END]]');

                tempDiv.textContent = codeWithPlaceholders;
                
                const finalCode = tempDiv.innerHTML
                    .replace(/\[\[HIGHLIGHT_START\]\]/g, '<span class="code-highlight">')
                    .replace(/\[\[HIGHLIGHT_END\]\]/g, '</span>');

                codeHtml = `
                    <div class="mt-6 bg-[#282c34] rounded-lg overflow-hidden border border-gray-700">
                        <pre class="language-python !text-sm !leading-relaxed"><code>${finalCode}</code></pre>
                    </div>
                `;
            }

            slideElement.innerHTML = `
                <div class="grid grid-cols-1 ${slideData.code ? 'md:grid-cols-2' : ''} gap-8 items-start">
                    <div class="prose prose-invert max-w-none">
                        <h2 class="text-2xl font-bold text-indigo-400 mb-4">${slideData.title}</h2>
                        <div class="text-gray-300 leading-relaxed space-y-2">${slideData.explanation}</div>
                    </div>
                    ${slideData.code ? `<div>${codeHtml}</div>` : ''}
                </div>
            `;
            return slideElement;
        }

        function updateSlider() {
            document.querySelectorAll('.slide').forEach((slide, index) => {
                slide.classList.toggle('active', index === currentSlide);
            });
            slideCounter.textContent = `${currentSlide + 1} / ${slides.length}`;
            prevBtn.disabled = currentSlide === 0;
            nextBtn.disabled = currentSlide === slides.length - 1;
            Prism.highlightAll();
        }

        prevBtn.addEventListener('click', () => {
            if (currentSlide > 0) {
                currentSlide--;
                updateSlider();
            }
        });

        nextBtn.addEventListener('click', () => {
            if (currentSlide < slides.length - 1) {
                currentSlide++;
                updateSlider();
            }
        });
        
        // --- Simulation Logic ---
        let simInterval;
        let paddleElem, ballElem, logElem, startBtn;
        let paddleX, ballX, ballY, ballVX, ballVY, score;
        const simWidth = 384; // max-w-sm
        const simHeight = 300;
        const paddleWidth = 80;
        const ballSize = 15;
        
        function logMessage(message) {
            if(logElem) {
                logElem.innerHTML += `<div>${message}</div>`;
                logElem.scrollTop = logElem.scrollHeight;
            }
        }

        function startSimulation() {
            clearInterval(simInterval);
            paddleElem = document.getElementById('paddle');
            ballElem = document.getElementById('ball');
            logElem = document.getElementById('sim-log');
            startBtn = document.getElementById('start-sim-btn');
            
            if(logElem) logElem.innerHTML = '';
            score = 0;
            
            ballX = simWidth / 2;
            ballY = 50;
            ballVX = (Math.random() > 0.5 ? 1 : -1) * 3;
            ballVY = 3;
            paddleX = (simWidth - paddleWidth) / 2;

            logMessage("Simulation Started...");
            if(startBtn) { startBtn.disabled = true; startBtn.innerText = "진행 중..."; }
            simInterval = setInterval(gameLoop, 1000 / 60);
        }

        function gameLoop() {
            // AI Agent Logic to move paddle
            const paddleCenterX = paddleX + paddleWidth / 2;
            const ballCenterX = ballX + ballSize / 2;
            let action = "Stay";
            
            if (paddleCenterX < ballCenterX - 5) {
                paddleX += 4; 
                action = "Right";
            } else if (paddleCenterX > ballCenterX + 5) {
                paddleX -= 4;
                action = "Left";
            }
            paddleX = Math.max(0, Math.min(simWidth - paddleWidth, paddleX));
            if(paddleElem) paddleElem.style.left = paddleX + 'px';

            // Update ball position
            ballX += ballVX;
            ballY += ballVY;

            // Wall collision
            if (ballX <= 0 || ballX >= simWidth - ballSize) {
                ballVX *= -1;
            }
            if (ballY <= 0) {
                ballVY *= -1;
            }

            // Paddle collision
            let reward = 0;
            if (ballY >= simHeight - 20 - 10 - ballSize && // paddle height + bottom offset
                ballY <= simHeight - 20 - 10 &&
                ballX > paddleX - ballSize && 
                ballX < paddleX + paddleWidth) 
            {
                ballVY *= -1;
                ballY = simHeight - 20 - 10 - ballSize - 1; // prevent sticking
                reward = 10;
                score += reward;
                logMessage(`[HIT] Action: ${action}, Reward: +${reward}, Score: ${score}`);
            } 
            // Miss
            else if (ballY >= simHeight) {
                reward = -100;
                score += reward;
                logMessage(`[MISS] Reward: ${reward}, Score: ${score}. GAME OVER.`);
                clearInterval(simInterval);
                if(startBtn) {
                    startBtn.disabled = false;
                    startBtn.innerText = "다시 시작";
                }
            }

            if(ballElem) { 
                ballElem.style.left = ballX + 'px'; 
                ballElem.style.top = ballY + 'px'; 
            }
        }


        // Initialize slider
        slides.forEach((slideData, index) => {
            sliderContainer.appendChild(createSlide(slideData, index));
        });
        updateSlider();
    </script>
</body>
</html>
